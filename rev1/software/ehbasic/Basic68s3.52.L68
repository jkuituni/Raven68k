00FF007A Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 2/1/2022 4:16:26 PM

00000000                             1  *************************************************************************************
00000000                             2  *                                                       *
00000000                             3  *   Enhanced BASIC for the Motorola MC680xx                         *
00000000                             4  *                                                       *
00000000                             5  *   This version for the EASy68k editor/simulator.                      *
00000000                             6  *   Includes new simulator graphics commands 2002/3/4/5/6/7             *
00000000                             7  *                                                       *
00000000                             8  *************************************************************************************
00000000                             9  *                                                       *
00000000                            10  *   Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed *
00000000                            11  *   for personal use only. All commercial rights are reserved.              *
00000000                            12  *                                                       *
00000000                            13  *   More 68000 and other projects can be found on my website at ..          *
00000000                            14  *                                                       *
00000000                            15  *    http://mycorner.no-ip.org/index.html                           *
00000000                            16  *                                                       *
00000000                            17  *   mail : leeedavison@googlemail.com                               *
00000000                            18  *                                                       *
00000000                            19  *************************************************************************************
00000000                            20  
00000000                            21  * EASy68k extensions Ver 2.33
00000000                            22  
00000000                            23  * Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
00000000                            24  * pointer in a3. this means that this could now be run as a task on a multitasking
00000000                            25  * system where memory resources may change.
00000000                            26  
00000000                            27  * Ver 3.52
00000000                            28  
00000000                            29  * Ver 3.52 stops USING$() from reading beyond the end of the format string
00000000                            30  * Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
00000000                            31  * Ver 3.50 uniary minus in concatenate generates a type mismatch error
00000000                            32  * Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
00000000                            33  * Ver 3.48 allows scientific notation underflow in the USING$() function
00000000                            34  * Ver 3.47 traps the use of array elements as the FOR loop variable
00000000                            35  * Ver 3.46 updates function and function variable handling
00000000                            36  
00000000                            37  *************************************************************************************
00000000                            38  *
00000000                            39  * Ver 3.45 makes the handling of non existant variables consistent and gives the
00000000                            40  * option of not returning an error for a non existant variable. If this is the
00000000                            41  * behaviour you want just change novar to some non zero value
00000000                            42  
00000000  =00000000                 43  novar       EQU 0               * non existant variables cause errors
00000000                            44  
00000000                            45  
00000000                            46  *************************************************************************************
00000000                            47  
00000000                            48  * Ver 3.44 adds overflow indication to the USING$() function
00000000                            49  * Ver 3.43 removes an undocumented feature of concatenating null strings
00000000                            50  * Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
00000000                            51  * Ver 3.41 removes undocumented features of the USING$() function
00000000                            52  * Ver 3.40 adds the USING$() function
00000000                            53  * Ver 3.33 adds the file requester to LOAD and SAVE
00000000                            54  * Ver 3.32 adds the optional ELSE clause to IF .. THEN
00000000                            55  
00000000                            56  *************************************************************************************
00000000                            57  
00000000                            58  * Version 3.25 adds the option to change the behaviour of INPUT so that a null
00000000                            59  * response does not cause a program break. If this is the behaviour you want just
00000000                            60  * change nobrk to some non zero value.
00000000                            61  
00000000  =00000000                 62  nobrk       EQU 0               * null response to INPUT causes a break
00000000                            63  
00000000                            64  
00000000                            65  *************************************************************************************
00000000                            66  
00000000                            67      OPT CRE
00000000                            68  
00000000                            69      INCLUDE "Basic68k3.41.inc"
00000000                            70  
00000000                            71  
00000400=                           72      OFFSET  $400            * start of RAM
00000400=                           73  
00000400=                           74  ram_strt    ds.l    $100            * allow 1K for the stack, this should be plenty
00000800=                           75                          * for any BASIC program that doesn't do something
00000800=                           76                          * silly, it could even be much less.
00000800=                           77  ram_base
00000800=                           78  LAB_WARM    ds.w    1           * BASIC warm start entry point
00000802=                           79  Wrmjpv  ds.l    1           * BASIC warm start jump vector
00000806=                           80  
00000806=                           81  Usrjmp  ds.w    1           * USR function JMP address
00000808=                           82  Usrjpv  ds.l    1           * USR function JMP vector
0000080C=                           83  
0000080C=                           84  
0000080C=                           85  V_INPT  ds.w    1           * non halting scan input device entry point
0000080E=                           86  V_INPTv ds.l    1           * non halting scan input device jump vector
00000812=                           87  
00000812=                           88  V_OUTP  ds.w    1           * send byte to output device entry point
00000814=                           89  V_OUTPv ds.l    1           * send byte to output device jump vector
00000818=                           90  
00000818=                           91  V_LOAD  ds.w    1           * load BASIC program entry point
0000081A=                           92  V_LOADv ds.l    1           * load BASIC program jump vector
0000081E=                           93  
0000081E=                           94  V_SAVE  ds.w    1           * save BASIC program entry point
00000820=                           95  V_SAVEv ds.l    1           * save BASIC program jump vector
00000824=                           96  
00000824=                           97  V_CTLC  ds.w    1           * save CTRL-C check entry point
00000826=                           98  V_CTLCv ds.l    1           * save CTRL-C check jump vector
0000082A=                           99  
0000082A=                          100  Itemp       ds.l    1           * temporary integer (for GOTO etc)
0000082E=                          101  
0000082E=                          102  Smeml       ds.l    1           * start of memory       (start of program)
00000832=                          103  
00000832=                          104  
00000832=                          105  Sfncl       ds.l    1           * start of functions    (end of Program)
00000836=                          106  
00000836=                          107  
00000836=                          108  Svarl       ds.l    1           * start of variables    (end of functions)
0000083A=                          109  
0000083A=                          110  
0000083A=                          111  Sstrl       ds.l    1           * start of strings  (end of variables)
0000083E=                          112  
0000083E=                          113  
0000083E=                          114  Sarryl  ds.l    1           * start of arrays       (end of strings)
00000842=                          115  
00000842=                          116  
00000842=                          117  Earryl  ds.l    1           * end of arrays     (start of free mem)
00000846=                          118  Sstorl  ds.l    1           * string storage        (moving down)
0000084A=                          119  Ememl       ds.l    1           * end of memory     (upper bound of RAM)
0000084E=                          120  Sutill  ds.l    1           * string utility ptr
00000852=                          121  Clinel  ds.l    1           * current line      (Basic line number)
00000856=                          122  Blinel  ds.l    1           * break line        (Basic line number)
0000085A=                          123  
0000085A=                          124  Cpntrl  ds.l    1           * continue pointer
0000085E=                          125  Dlinel  ds.l    1           * current DATA line
00000862=                          126  Dptrl       ds.l    1           * DATA pointer
00000866=                          127  Rdptrl  ds.l    1           * read pointer
0000086A=                          128  Varname ds.l    1           * current var name
0000086E=                          129  Cvaral  ds.l    1           * current var address
00000872=                          130  Lvarpl  ds.l    1           * variable pointer for LET and FOR/NEXT
00000876=                          131  
00000876=                          132  des_sk_e    ds.l    6           * descriptor stack end address
0000088E=                          133  des_sk                  * descriptor stack start address
0000088E=                          134                          * use a4 for the descriptor pointer
0000088E=                          135          ds.w    1           
00000890=                          136  Ibuffs  ds.l    $40         * start of input buffer
00000990=                          137  Ibuffe
00000990=                          138                          * end of input buffer
00000990=                          139  
00000990=                          140  FAC1_m  ds.l    1           * FAC1 mantissa1
00000994=                          141  FAC1_e  ds.w    1           * FAC1 exponent
00000996= =00000995                142  FAC1_s  EQU FAC1_e+1        * FAC1 sign (b7)
00000996=                          143          ds.w    1           
00000998=                          144  
00000998=                          145  FAC2_m  ds.l    1           * FAC2 mantissa1
0000099C=                          146  FAC2_e  ds.l    1           * FAC2 exponent
000009A0= =0000099D                147  FAC2_s  EQU FAC2_e+1        * FAC2 sign (b7)
000009A0= =0000099E                148  FAC_sc  EQU FAC2_e+2        * FAC sign comparison, Acc#1 vs #2
000009A0= =0000099F                149  flag        EQU FAC2_e+3        * flag byte for divide routine
000009A0=                          150  
000009A0=                          151  PRNlword    ds.l    1           * PRNG seed long word
000009A4=                          152  
000009A4=                          153  ut1_pl  ds.l    1           * utility pointer 1
000009A8=                          154  
000009A8=                          155  Asptl       ds.l    1           * array size/pointer
000009AC=                          156  Astrtl  ds.l    1           * array start pointer
000009B0=                          157  
000009B0= =000009AC                158  numexp  EQU Astrtl      * string to float number exponent count
000009B0= =000009AD                159  expcnt  EQU Astrtl+1        * string to float exponent count
000009B0=                          160  
000009B0= =000009AF                161  expneg  EQU Astrtl+3        * string to float eval exponent -ve flag
000009B0=                          162  
000009B0=                          163  func_l  ds.l    1           * function pointer
000009B4=                          164  
000009B4=                          165  
000009B4=                          166                          * these two need to be a word aligned pair !
000009B4=                          167  Defdim  ds.w    1           * default DIM flag
000009B6= =000009B4                168  cosout  EQU Defdim      * flag which CORDIC output (re-use byte)
000009B6= =000009B5                169  Dtypef  EQU Defdim+1        * data type flag, $80=string, $40=integer, $00=float
000009B6=                          170  
000009B6=                          171  
000009B6=                          172  Binss       ds.l    4           * number to bin string start (32 chrs)
000009C6=                          173  
000009C6=                          174  Decss       ds.l    1           * number to decimal string start (16 chrs)
000009CA=                          175          ds.w    1           *
000009CC=                          176  Usdss       ds.w    1           * unsigned decimal string start (10 chrs)
000009CE=                          177  
000009CE=                          178  Hexss       ds.l    2           * number to hex string start (8 chrs)
000009D6=                          179  
000009D6=                          180  BHsend  ds.w    1           * bin/decimal/hex string end
000009D8=                          181  
000009D8=                          182  
000009D8=                          183  prstk       ds.b    1           * stacked function index
000009D9=                          184  
000009D9=                          185  tpower  ds.b    1           * remember CORDIC power
000009DA=                          186  
000009DA=                          187  Asrch       ds.b    1           * scan-between-quotes flag, alt search character
000009DB=                          188  
000009DB=                          189  Dimcnt  ds.b    1           * # of dimensions
000009DC=                          190  
000009DC=                          191  Breakf  ds.b    1           * break flag, $00=END else=break
000009DD=                          192  Oquote  ds.b    1           * open quote flag (Flag: DATA; LIST; memory)
000009DE=                          193  Gclctd  ds.b    1           * garbage collected flag
000009DF=                          194  Sufnxf  ds.b    1           * subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
000009E0=                          195  Imode       ds.b    1           * input mode flag, $00=INPUT, $98=READ
000009E1=                          196  
000009E1=                          197  Cflag       ds.b    1           * comparison evaluation flag
000009E2=                          198  
000009E2=                          199  TabSiz  ds.b    1           * TAB step size
000009E3=                          200  
000009E3=                          201  comp_f  ds.b    1           * compare function flag, bits 0,1 and 2 used
000009E4=                          202                          * bit 2 set if >
000009E4=                          203                          * bit 1 set if =
000009E4=                          204                          * bit 0 set if <
000009E4=                          205  
000009E4=                          206  Nullct  ds.b    1           * nulls output after each line
000009E5=                          207  TPos        ds.b    1           * BASIC terminal position byte
000009E6=                          208  TWidth  ds.b    1           * BASIC terminal width byte
000009E7=                          209  Iclim       ds.b    1           * input column limit
000009E8=                          210  ccflag  ds.b    1           * CTRL-C check flag
000009E9=                          211  ccbyte  ds.b    1           * CTRL-C last received byte
000009EA=                          212  ccnull  ds.b    1           * CTRL-C last received byte 'life' timer
000009EB=                          213  
000009EB=                          214  
000009EB=                          215  file_byte   ds.b    1           * load/save data byte
000009EC=                          216  file_id ds.l    1           * load/save file ID
000009F0=                          217  
000009F0= 0000                     218          dc.w    0           * dummy even value and zero pad byte
000009F2=                          219  
000009F2=                          220  prg_strt
000009F2=                          221  
00000000                           222      ORG *
00000000                           223  
00000000  =00001000                224  ram_addr    EQU $1000       * RAM start address
00000000  =00080000                225  ram_size    EQU $80000      * RAM size
00000000                           226  
00000000                           227  -------------------- end include --------------------
00000000                           228                              * RAM offset definitions
00000000                           229                              
00000000                           230  *********************************
00000000                           231  * 68681 Duart Register Addresses
00000000                           232  *
00000000  =00200000                233  DUART equ $200000       * Base Addr of DUART
00000000  =00200001                234  MRA   equ DUART+1       * Mode Register A           (R/W)
00000000  =00200003                235  SRA   equ DUART+3       * Status Register A         (r)
00000000  =00200003                236  CSRA  equ DUART+3       * Clock Select Register A   (w)
00000000  =00200005                237  CRA   equ DUART+5       * Commands Register A       (w)
00000000  =00200007                238  RBA   equ DUART+7       * Receiver Buffer A         (r)
00000000  =00200007                239  TBA   equ DUART+7       * Transmitter Buffer A      (w)
00000000  =00200009                240  ACR   equ DUART+9       * Aux. Control Register     (R/W)
00000000  =0020000B                241  ISR   equ DUART+11      * Interrupt Status Register (R)
00000000  =0020000B                242  IMR   equ DUART+11      * Interrupt Mask Register   (W)
00000000  =00200011                243  MRB   equ DUART+17      * Mode Register B           (R/W)
00000000  =00200013                244  SRB   equ DUART+19      * Status Register B         (R)
00000000  =00200013                245  CSRB  equ DUART+19      * Clock Select Register B   (W)
00000000  =00200015                246  CRB   equ DUART+21      * Commands Register B       (W)
00000000  =00200017                247  RBB   equ DUART+23      * Reciever Buffer B         (R)
00000000  =00200017                248  TBB   equ DUART+23      * Transmitter Buffer B      (W)
00000000  =00200019                249  IVR   equ DUART+25      * Interrupt Vector Register (R/W)
00000000                           250  
00000000                           251  
00FF0000                           252      ORG     $FF0000         * past the vectors in a real system
00FF0000                           253  
00FF0000= 00000800                 254      DC.l    ram_base
00FF0004= 00FF007A                 255      DC.L    code_start
00FF0008                           256      
00FF0008                           257  *************************************************************************************
00FF0008                           258  *
00FF0008                           259  * the following code is simulator specific, change to suit your system
00FF0008                           260  
00FF0008                           261  * output character to the console from register d0.b
00FF0008                           262  
00FF0008                           263  VEC_OUT
00FF0008  0839 0002 00200003       264      btst    #2, SRA      * Check if transmitter ready bit is set
00FF0010  67F6                     265      beq     VEC_OUT
00FF0012  13C0 00200007            266      move.b  d0, TBA      * Transmit Character
00FF0018  4E75                     267      RTS
00FF001A                           268  
00FF001A                           269  
00FF001A                           270  *************************************************************************************
00FF001A                           271  *
00FF001A                           272  * input a character from the console into register d0
00FF001A                           273  * else return Cb=0 if there's no character available
00FF001A                           274  
00FF001A                           275  VEC_IN
00FF001A  0839 0000 00200003       276      btst    #0,  SRA     * Check if receiver ready bit is set
00FF0022  6600 0004                277      bne     RETCHR
00FF0026  4E75                     278      RTS
00FF0028                           279  
00FF0028                           280  RETCHR
00FF0028  1039 00200007            281      move.b  RBA, d0      * Read Character into D0
00FF002E  4A00                     282      TST.b       d0              * set the z flag on the received byte
00FF0030  003C 0001                283      ORI.b       #1,CCR          * set the carry, flag we got a byte
00FF0034  4E75                     284      RTS
00FF0036                           285  
00FF0036                           286  
00FF0036                           287  *************************************************************************************
00FF0036                           288  *
00FF0036                           289  * LOAD routine for the Easy68k simulator
00FF0036                           290  
00FF0036                           291  VEC_LD
00FF0036  7E2E                     292         MOVEQ           #$2E,d7                         * error code $2E "Not implemented" error
00FF0038  6000 016A                293         BRA             LAB_XERR                        * do error #d7, then warm start
00FF003C                           294  
00FF003C                           295  *************************************************************************************
00FF003C                           296  *
00FF003C                           297  * SAVE routine for the Easy68k simulator
00FF003C                           298  
00FF003C                           299  VEC_SV
00FF003C  7E2E                     300         MOVEQ           #$2E,d7                         * error code $2E "Not implemented" error
00FF003E  6000 0164                301         BRA             LAB_XERR                        * do error #d7, then warm start
00FF0042                           302  
00FF0042                           303  *************************************************************************************
00FF0042                           304  *
00FF0042                           305  * Initialize our console
00FF0042                           306  INIT_DUART
00FF0042  41F9 00200000            307      lea     DUART,a0
00FF0048  117C 0030 0005           308      move.b  #$30,5(a0)       * Reset Transmitter
00FF004E  117C 0020 0005           309      move.b  #$20,5(a0)       * Reset Reciever
00FF0054  117C 0010 0005           310      move.b  #$10,5(a0)       * Reset Mode Register Pointer
00FF005A                           311      
00FF005A  117C 0000 0009           312      move.b  #$00,9(a0)       * Baud Rate Set #1
00FF0060  117C 00CC 0003           313      move.b  #$CC,3(a0)       * Set Tx and Rx rates to 38400
00FF0066  117C 0013 0001           314      move.b  #$13,1(a0)       * 8-bit, No Parity ($93 for 8-bit, $92 for 7-bit)
00FF006C  117C 0007 0001           315      move.b  #$07,1(a0)       * Normal Mode, Not CTS/RTS, 1 stop bit
00FF0072                           316      
00FF0072  117C 0005 0005           317      move.b  #$05,5(a0)       * Enable Transmit/Recieve
00FF0078                           318  
00FF0078  4E75                     319      rts 
00FF007A                           320  
00FF007A                           321  *************************************************************************************
00FF007A                           322  *
00FF007A                           323  * init duart
00FF007A                           324  
00FF007A                           325  code_start
00FF007A  4FF8 0800                326      lea     ram_base,SP  * Set our stack pointer to be sure
00FF007E  61C2                     327      bsr     INIT_DUART
00FF0080                           328  
00FF0080                           329  * to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
00FF0080                           330  * in d0. these values are at the end of the .inc file
00FF0080                           331  
00FF0080  207C 00001000            332      MOVEA.l #ram_addr,a0        * tell BASIC where RAM starts
00FF0086  203C 00080000            333      MOVE.l  #ram_size,d0        * tell BASIC how big RAM is
00FF008C                           334  
00FF008C                           335  * end of simulator specific code
00FF008C                           336  
00FF008C                           337  
00FF008C                           338  ****************************************************************************************
00FF008C                           339  ****************************************************************************************
00FF008C                           340  ****************************************************************************************
00FF008C                           341  ****************************************************************************************
00FF008C                           342  *
00FF008C                           343  * Register use :- (must improve this !!)
00FF008C                           344  *
00FF008C                           345  *   a6 -    temp Bpntr              * temporary BASIC execute pointer
00FF008C                           346  *   a5 -    Bpntr                   * BASIC execute (get byte) pointer
00FF008C                           347  *   a4 -    des_sk              * descriptor stack pointer
00FF008C                           348  *   a3 -    ram_strt                * start of RAM. all RAM references are offsets
00FF008C                           349  *                           * from this value
00FF008C                           350  *
00FF008C                           351  
00FF008C                           352  *************************************************************************************
00FF008C                           353  *
00FF008C                           354  * BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
00FF008C                           355  * in d0
00FF008C                           356  
00FF008C                           357  LAB_COLD
00FF008C  B0BC 00004000            358      CMP.l       #$4000,d0           * compare size with 16k
00FF0092  6C04                     359      BGE.s       LAB_sizok           * branch if >= 16k
00FF0094                           360  
00FF0094  7005                     361      MOVEQ       #5,d0               * error 5 - not enough RAM
00FF0096  4E75                     362      RTS                     * just exit. this as stands will never execute
00FF0098                           363                              * but could be used to exit to an OS
00FF0098                           364  
00FF0098                           365  LAB_sizok
00FF0098  2648                     366      MOVEA.l a0,a3               * copy RAM base to a3
00FF009A  D1C0                     367      ADDA.l  d0,a0               * a0 is top of RAM
00FF009C  2748 084A                368      MOVE.l  a0,Ememl(a3)        * set end of mem
00FF00A0  4FEB 0800                369      LEA     ram_base(a3),sp     * set stack to RAM start + 1k
00FF00A4                           370  
00FF00A4  303C 4EF9                371      MOVE.w  #$4EF9,d0           * JMP opcode
00FF00A8  204F                     372      MOVEA.l sp,a0               * point to start of vector table
00FF00AA                           373  
00FF00AA  30C0                     374      MOVE.w  d0,(a0)+            * LAB_WARM
00FF00AC  43FA FFDE                375      LEA     LAB_COLD(pc),a1     * initial warm start vector
00FF00B0  20C9                     376      MOVE.l  a1,(a0)+            * set vector
00FF00B2                           377  
00FF00B2  30C0                     378      MOVE.w  d0,(a0)+            * Usrjmp
00FF00B4  43FA 00DC                379      LEA     LAB_FCER(pc),a1     * initial user function vector
00FF00B8                           380                              * "Function call" error
00FF00B8  20C9                     381      MOVE.l  a1,(a0)+            * set vector
00FF00BA                           382  
00FF00BA  30C0                     383      MOVE.w  d0,(a0)+            * V_INPT JMP opcode
00FF00BC  43FA FF5C                384      LEA     VEC_IN(pc),a1       * get byte from input device vector
00FF00C0  20C9                     385      MOVE.l  a1,(a0)+            * set vector
00FF00C2                           386  
00FF00C2  30C0                     387      MOVE.w  d0,(a0)+            * V_OUTP JMP opcode
00FF00C4  43FA FF42                388      LEA     VEC_OUT(pc),a1      * send byte to output device vector
00FF00C8  20C9                     389      MOVE.l  a1,(a0)+            * set vector
00FF00CA                           390  
00FF00CA  30C0                     391      MOVE.w  d0,(a0)+            * V_LOAD JMP opcode
00FF00CC  43FA FF68                392      LEA     VEC_LD(pc),a1       * load BASIC program vector
00FF00D0  20C9                     393      MOVE.l  a1,(a0)+            * set vector
00FF00D2                           394  
00FF00D2  30C0                     395      MOVE.w  d0,(a0)+            * V_SAVE JMP opcode
00FF00D4  43FA FF66                396      LEA     VEC_SV(pc),a1       * save BASIC program vector
00FF00D8  20C9                     397      MOVE.l  a1,(a0)+            * set vector
00FF00DA                           398  
00FF00DA  30C0                     399      MOVE.w  d0,(a0)+            * V_CTLC JMP opcode
00FF00DC  43FA 284A                400      LEA     VEC_CC(pc),a1       * save CTRL-C check vector
00FF00E0  20C9                     401      MOVE.l  a1,(a0)+            * set vector
00FF00E2                           402  
00FF00E2                           403  * set-up start values
00FF00E2                           404  
00FF00E2                           405  LAB_GMEM
00FF00E2  7000                     406      MOVEQ       #$00,d0         * clear d0
00FF00E4  1740 09E4                407      MOVE.b  d0,Nullct(a3)       * default NULL count
00FF00E8  1740 09E5                408      MOVE.b  d0,TPos(a3)         * clear terminal position
00FF00EC  1740 09E8                409      MOVE.b  d0,ccflag(a3)       * allow CTRL-C check
00FF00F0  3740 09F0                410      MOVE.w  d0,prg_strt-2(a3)       * clear start word
00FF00F4  3740 09D6                411      MOVE.w  d0,BHsend(a3)       * clear value to string end word
00FF00F8                           412  
00FF00F8  177C 0050 09E6           413      MOVE.b  #$50,TWidth(a3)     * default terminal width byte for simulator *##
00FF00FE                           414  *## MOVE.b  d0,TWidth(a3)       * default terminal width byte
00FF00FE                           415  
00FF00FE  177C 000E 09E2           416      MOVE.b  #$0E,TabSiz(a3)     * save default tab size = 14
00FF0104                           417  
00FF0104  177C 0038 09E7           418      MOVE.b  #$38,Iclim(a3)      * default limit for TAB = 14 for simulator *##
00FF010A                           419  *## MOVE.b  #$F2,Iclim(a3)      * default limit for TAB = 14
00FF010A                           420  
00FF010A  49EB 088E                421      LEA     des_sk(a3),a4       * set descriptor stack start
00FF010E                           422  
00FF010E  41EB 09F2                423      LEA     prg_strt(a3),a0     * get start of mem
00FF0112  2748 082E                424      MOVE.l  a0,Smeml(a3)        * save start of mem
00FF0116                           425  
00FF0116  6100 0322                426      BSR     LAB_1463            * do "NEW" and "CLEAR"
00FF011A  6100 0898                427      BSR     LAB_CRLF            * print CR/LF
00FF011E  202B 084A                428      MOVE.l  Ememl(a3),d0        * get end of mem
00FF0122  90AB 082E                429      SUB.l       Smeml(a3),d0        * subtract start of mem
00FF0126                           430  
00FF0126  6100 1DF8                431      BSR     LAB_295E            * print d0 as unsigned integer (bytes free)
00FF012A  41FA 36AE                432      LEA     LAB_SMSG(pc),a0     * point to start message
00FF012E  6100 08E2                433      BSR     LAB_18C3            * print null terminated string from memory
00FF0132                           434  
00FF0132  41FA 2BFE                435      LEA     LAB_RSED(pc),a0     * get pointer to value
00FF0136  6100 1C92                436      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
00FF013A                           437  
00FF013A  41FA 0092                438      LEA     LAB_1274(pc),a0     * get warm start vector
00FF013E  2748 0802                439      MOVE.l  a0,Wrmjpv(a3)       * set warm start vector
00FF0142  6100 21FE                440      BSR     LAB_RND         * initialise
00FF0146  4EEB 0800                441      JMP     LAB_WARM(a3)        * go do warm start
00FF014A                           442  
00FF014A                           443  
00FF014A                           444  *************************************************************************************
00FF014A                           445  *
00FF014A                           446  * do format error
00FF014A                           447  
00FF014A                           448  LAB_FOER
00FF014A  7E2C                     449      MOVEQ       #$2C,d7         * error code $2C "Format" error
00FF014C  6056                     450      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF014E                           451  
00FF014E                           452  
00FF014E                           453  *************************************************************************************
00FF014E                           454  *
00FF014E                           455  * do address error
00FF014E                           456  
00FF014E                           457  LAB_ADER
00FF014E  7E2A                     458      MOVEQ       #$2A,d7         * error code $2A "Address" error
00FF0150  6052                     459      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0152                           460  
00FF0152                           461  
00FF0152                           462  *************************************************************************************
00FF0152                           463  *
00FF0152                           464  * do wrong dimensions error
00FF0152                           465  
00FF0152                           466  LAB_WDER
00FF0152  7E28                     467      MOVEQ       #$28,d7         * error code $28 "Wrong dimensions" error
00FF0154  604E                     468      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0156                           469  
00FF0156                           470  
00FF0156                           471  *************************************************************************************
00FF0156                           472  *
00FF0156                           473  * do undimensioned array error
00FF0156                           474  
00FF0156                           475  LAB_UDER
00FF0156  7E26                     476      MOVEQ       #$26,d7         * error code $26 "undimensioned array" error
00FF0158  604A                     477      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF015A                           478  
00FF015A                           479  
00FF015A                           480  *************************************************************************************
00FF015A                           481  *
00FF015A                           482  * do undefined variable error
00FF015A                           483  
00FF015A                           484  LAB_UVER
00FF015A                           485  
00FF015A                           486  * if you do want a non existant variable to return an error then leave the novar
00FF015A                           487  * value at the top of this file set to zero
00FF015A                           488  
00FF015A                 TRUE      489   ifeq   novar
00FF015A                           490  
00FF015A  7E24                     491      MOVEQ       #$24,d7         * error code $24 "undefined variable" error
00FF015C  6046                     492      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF015E                           493  
00FF015E                           494   endc
00FF015E                           495  
00FF015E                           496  * if you want a non existant variable to return a null value then set the novar
00FF015E                           497  * value at the top of this file to some non zero value
00FF015E                           498  
00FF015E                 FALSE     499   ifne   novar
00FF015E                           500   endc
00FF015E                           501  
00FF015E                           502  
00FF015E                           503  *************************************************************************************
00FF015E                           504  *
00FF015E                           505  * do loop without do error
00FF015E                           506  
00FF015E                           507  LAB_LDER
00FF015E  7E22                     508      MOVEQ       #$22,d7         * error code $22 "LOOP without DO" error
00FF0160  6042                     509      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0162                           510  
00FF0162                           511  
00FF0162                           512  *************************************************************************************
00FF0162                           513  *
00FF0162                           514  * do undefined function error
00FF0162                           515  
00FF0162                           516  LAB_UFER
00FF0162  7E20                     517      MOVEQ       #$20,d7         * error code $20 "Undefined function" error
00FF0164  603E                     518      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0166                           519  
00FF0166                           520  
00FF0166                           521  *************************************************************************************
00FF0166                           522  *
00FF0166                           523  * do can't continue error
00FF0166                           524  
00FF0166                           525  LAB_CCER
00FF0166  7E1E                     526      MOVEQ       #$1E,d7         * error code $1E "Can't continue" error
00FF0168  603A                     527      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF016A                           528  
00FF016A                           529  
00FF016A                           530  *************************************************************************************
00FF016A                           531  *
00FF016A                           532  * do string too complex error
00FF016A                           533  
00FF016A                           534  LAB_SCER
00FF016A  7E1C                     535      MOVEQ       #$1C,d7         * error code $1C "String too complex" error
00FF016C  6036                     536      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF016E                           537  
00FF016E                           538  
00FF016E                           539  *************************************************************************************
00FF016E                           540  *
00FF016E                           541  * do string too long error
00FF016E                           542  
00FF016E                           543  LAB_SLER
00FF016E  7E1A                     544      MOVEQ       #$1A,d7         * error code $1A "String too long" error
00FF0170  6032                     545      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0172                           546  
00FF0172                           547  
00FF0172                           548  *************************************************************************************
00FF0172                           549  *
00FF0172                           550  * do type missmatch error
00FF0172                           551  
00FF0172                           552  LAB_TMER
00FF0172  7E18                     553      MOVEQ       #$18,d7         * error code $18 "Type mismatch" error
00FF0174  602E                     554      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0176                           555  
00FF0176                           556  
00FF0176                           557  *************************************************************************************
00FF0176                           558  *
00FF0176                           559  * do illegal direct error
00FF0176                           560  
00FF0176                           561  LAB_IDER
00FF0176  7E16                     562      MOVEQ       #$16,d7         * error code $16 "Illegal direct" error
00FF0178  602A                     563      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF017A                           564  
00FF017A                           565  
00FF017A                           566  *************************************************************************************
00FF017A                           567  *
00FF017A                           568  * do divide by zero error
00FF017A                           569  
00FF017A                           570  LAB_DZER
00FF017A  7E14                     571      MOVEQ       #$14,d7         * error code $14 "Divide by zero" error
00FF017C  6026                     572      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF017E                           573  
00FF017E                           574  
00FF017E                           575  *************************************************************************************
00FF017E                           576  *
00FF017E                           577  * do double dimension error
00FF017E                           578  
00FF017E                           579  LAB_DDER
00FF017E  7E12                     580      MOVEQ       #$12,d7         * error code $12 "Double dimension" error
00FF0180  6022                     581      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0182                           582  
00FF0182                           583  
00FF0182                           584  *************************************************************************************
00FF0182                           585  *
00FF0182                           586  * do array bounds error
00FF0182                           587  
00FF0182                           588  LAB_ABER
00FF0182  7E10                     589      MOVEQ       #$10,d7         * error code $10 "Array bounds" error
00FF0184  601E                     590      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0186                           591  
00FF0186                           592  
00FF0186                           593  *************************************************************************************
00FF0186                           594  *
00FF0186                           595  * do undefine satement error
00FF0186                           596  
00FF0186                           597  LAB_USER
00FF0186  7E0E                     598      MOVEQ       #$0E,d7         * error code $0E "Undefined statement" error
00FF0188  601A                     599      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF018A                           600  
00FF018A                           601  
00FF018A                           602  *************************************************************************************
00FF018A                           603  *
00FF018A                           604  * do out of memory error
00FF018A                           605  
00FF018A                           606  LAB_OMER
00FF018A  7E0C                     607      MOVEQ       #$0C,d7         * error code $0C "Out of memory" error
00FF018C  6016                     608      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF018E                           609  
00FF018E                           610  
00FF018E                           611  *************************************************************************************
00FF018E                           612  *
00FF018E                           613  * do overflow error
00FF018E                           614  
00FF018E                           615  LAB_OFER
00FF018E  7E0A                     616      MOVEQ       #$0A,d7         * error code $0A "Overflow" error
00FF0190  6012                     617      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0192                           618  
00FF0192                           619  
00FF0192                           620  *************************************************************************************
00FF0192                           621  *
00FF0192                           622  * do function call error
00FF0192                           623  
00FF0192                           624  LAB_FCER
00FF0192  7E08                     625      MOVEQ       #$08,d7         * error code $08 "Function call" error
00FF0194  600E                     626      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF0196                           627  
00FF0196                           628  
00FF0196                           629  *************************************************************************************
00FF0196                           630  *
00FF0196                           631  * do out of data error
00FF0196                           632  
00FF0196                           633  LAB_ODER
00FF0196  7E06                     634      MOVEQ       #$06,d7         * error code $06 "Out of DATA" error
00FF0198  600A                     635      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF019A                           636  
00FF019A                           637  
00FF019A                           638  *************************************************************************************
00FF019A                           639  *
00FF019A                           640  * do return without gosub error
00FF019A                           641  
00FF019A                           642  LAB_RGER
00FF019A  7E04                     643      MOVEQ       #$04,d7         * error code $04 "RETURN without GOSUB" error
00FF019C  6006                     644      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF019E                           645  
00FF019E                           646  
00FF019E                           647  *************************************************************************************
00FF019E                           648  *
00FF019E                           649  * do syntax error
00FF019E                           650  
00FF019E                           651  LAB_SNER
00FF019E  7E02                     652      MOVEQ       #$02,d7         * error code $02 "Syntax" error
00FF01A0  6002                     653      BRA.s       LAB_XERR            * do error #d7, then warm start
00FF01A2                           654  
00FF01A2                           655  
00FF01A2                           656  *************************************************************************************
00FF01A2                           657  *
00FF01A2                           658  * do next without for error
00FF01A2                           659  
00FF01A2                           660  LAB_NFER
00FF01A2  7E00                     661      MOVEQ       #$00,d7         * error code $00 "NEXT without FOR" error
00FF01A4                           662  
00FF01A4                           663  
00FF01A4                           664  *************************************************************************************
00FF01A4                           665  *
00FF01A4                           666  * do error #d7, then warm start
00FF01A4                           667  
00FF01A4                           668  LAB_XERR
00FF01A4  6100 02CA                669      BSR     LAB_1491            * flush stack & clear continue flag
00FF01A8  6100 080A                670      BSR     LAB_CRLF            * print CR/LF
00FF01AC  43FA 326E                671      LEA     LAB_BAER(pc),a1     * start of error message pointer table
00FF01B0  3E31 7000                672      MOVE.w  (a1,d7.w),d7        * get error message offset
00FF01B4  41F1 7000                673      LEA     (a1,d7.w),a0        * get error message address
00FF01B8  6100 0858                674      BSR     LAB_18C3            * print null terminated string from memory
00FF01BC  41FA 35DF                675      LEA     LAB_EMSG(pc),a0     * point to " Error" message
00FF01C0                           676  LAB_1269
00FF01C0  6100 0850                677      BSR     LAB_18C3            * print null terminated string from memory
00FF01C4  202B 0852                678      MOVE.l  Clinel(a3),d0       * get current line
00FF01C8  6B04                     679      BMI.s       LAB_1274            * go do warm start if -ve # (was immediate mode)
00FF01CA                           680  
00FF01CA                           681                              * else print line number
00FF01CA  6100 1D48                682      BSR     LAB_2953            * print " in line [LINE #]"
00FF01CE                           683  
00FF01CE                           684  * BASIC warm start entry point, wait for Basic command
00FF01CE                           685  
00FF01CE                           686  LAB_1274
00FF01CE  41FA 3600                687      LEA     LAB_RMSG(pc),a0     * point to "Ready" message
00FF01D2  6100 083E                688      BSR     LAB_18C3            * go do print string
00FF01D6                           689  
00FF01D6                           690  * wait for Basic command (no "Ready")
00FF01D6                           691  
00FF01D6                           692  LAB_127D
00FF01D6  72FF                     693      MOVEQ       #-1,d1          * set to -1
00FF01D8  2741 0852                694      MOVE.l  d1,Clinel(a3)       * set current line #
00FF01DC  1741 09DC                695      MOVE.b  d1,Breakf(a3)       * set break flag
00FF01E0  4BEB 0890                696      LEA     Ibuffs(a3),a5       * set BASIC execute pointer ready for new line
00FF01E4                           697  LAB_127E
00FF01E4  6100 00EC                698      BSR     LAB_1357            * call for BASIC input
00FF01E8  6100 0BF4                699      BSR     LAB_GBYT            * scan memory
00FF01EC  67F6                     700      BEQ.s       LAB_127E            * loop while null
00FF01EE                           701  
00FF01EE                           702  * got to interpret input line now ....
00FF01EE                           703  
00FF01EE  6508                     704      BCS.s       LAB_1295            * branch if numeric character, handle new
00FF01F0                           705                              * BASIC line
00FF01F0                           706  
00FF01F0                           707                              * no line number so do immediate mode, a5
00FF01F0                           708                              * points to the buffer start
00FF01F0  6100 0156                709      BSR     LAB_13A6            * crunch keywords into Basic tokens
00FF01F4                           710                              * crunch from (a5), output to (a0)
00FF01F4                           711                              * returns ..
00FF01F4                           712                              * d2 is length, d1 trashed, d0 trashed,
00FF01F4                           713                              * a1 trashed
00FF01F4  6000 03C4                714      BRA     LAB_15F6            * go scan & interpret code
00FF01F8                           715  
00FF01F8                           716  
00FF01F8                           717  *************************************************************************************
00FF01F8                           718  *
00FF01F8                           719  * handle a new BASIC line
00FF01F8                           720  
00FF01F8                           721  LAB_1295
00FF01F8  6100 063A                722      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00FF01FC  6100 014A                723      BSR     LAB_13A6            * crunch keywords into Basic tokens
00FF0200                           724                              * crunch from (a5), output to (a0)
00FF0200                           725                              * returns .. d2 is length,
00FF0200                           726                              * d1 trashed, d0 trashed, a1 trashed
00FF0200  222B 082A                727      MOVE.l  Itemp(a3),d1        * get required line #
00FF0204  6100 0218                728      BSR     LAB_SSLN            * search BASIC for d1 line number
00FF0208                           729                              * returns pointer in a0
00FF0208  6532                     730      BCS.s       LAB_12E6            * branch if not found
00FF020A                           731  
00FF020A                           732                              * aroooogah! line # already exists! delete it
00FF020A  2250                     733      MOVEA.l (a0),a1         * get start of block (next line pointer)
00FF020C  202B 0832                734      MOVE.l  Sfncl(a3),d0        * get end of block (start of functions)
00FF0210  9089                     735      SUB.l       a1,d0               * subtract start of block ( = bytes to move)
00FF0212  E288                     736      LSR.l       #1,d0               * /2 (word move)
00FF0214  5380                     737      SUBQ.l  #1,d0               * adjust for DBF loop
00FF0216  4840                     738      SWAP        d0              * swap high word to low word
00FF0218  2448                     739      MOVEA.l a0,a2               * copy destination
00FF021A                           740  LAB_12AE
00FF021A  4840                     741      SWAP        d0              * swap high word to low word
00FF021C                           742  LAB_12B0
00FF021C  34D9                     743      MOVE.w  (a1)+,(a2)+         * copy word
00FF021E  51C8 FFFC                744      DBF     d0,LAB_12B0         * decrement low count and loop until done
00FF0222                           745  
00FF0222  4840                     746      SWAP        d0              * swap high word to low word
00FF0224  51C8 FFF4                747      DBF     d0,LAB_12AE         * decrement high count and loop until done
00FF0228                           748  
00FF0228  274A 0832                749      MOVE.l  a2,Sfncl(a3)        * start of functions
00FF022C  274A 0836                750      MOVE.l  a2,Svarl(a3)        * save start of variables
00FF0230  274A 083A                751      MOVE.l  a2,Sstrl(a3)        * start of strings
00FF0234  274A 083E                752      MOVE.l  a2,Sarryl(a3)       * save start of arrays
00FF0238  274A 0842                753      MOVE.l  a2,Earryl(a3)       * save end of arrays
00FF023C                           754  
00FF023C                           755                              * got new line in buffer and no existing same #
00FF023C                           756  LAB_12E6
00FF023C  102B 0890                757      MOVE.b  Ibuffs(a3),d0       * get byte from start of input buffer
00FF0240  6764                     758      BEQ.s       LAB_1325            * if null line go do line chaining
00FF0242                           759  
00FF0242                           760                              * got new line and it isn't empty line
00FF0242  226B 0832                761      MOVEA.l Sfncl(a3),a1        * get start of functions (end of block to move)
00FF0246  45F1 2008                762      LEA     8(a1,d2),a2         * copy it, add line length and add room for
00FF024A                           763                              * pointer and line number
00FF024A                           764  
00FF024A  274A 0832                765      MOVE.l  a2,Sfncl(a3)        * start of functions
00FF024E  274A 0836                766      MOVE.l  a2,Svarl(a3)        * save start of variables
00FF0252  274A 083A                767      MOVE.l  a2,Sstrl(a3)        * start of strings
00FF0256  274A 083E                768      MOVE.l  a2,Sarryl(a3)       * save start of arrays
00FF025A  274A 0842                769      MOVE.l  a2,Earryl(a3)       * save end of arrays
00FF025E  276B 084A 0846           770      MOVE.l  Ememl(a3),Sstorl(a3)    * copy end of mem to start of strings, clear
00FF0264                           771                              * strings
00FF0264                           772  
00FF0264  2209                     773      MOVE.l  a1,d1               * copy end of block to move
00FF0266  9288                     774      SUB.l       a0,d1               * subtract start of block to move
00FF0268  E289                     775      LSR.l       #1,d1               * /2 (word copy)
00FF026A  5381                     776      SUBQ.l  #1,d1               * correct for loop end on -1
00FF026C  4841                     777      SWAP        d1              * swap high word to low word
00FF026E                           778  LAB_12FF
00FF026E  4841                     779      SWAP        d1              * swap high word to low word
00FF0270                           780  LAB_1301
00FF0270  3521                     781      MOVE.w  -(a1),-(a2)         * decrement pointers and copy word
00FF0272  51C9 FFFC                782      DBF     d1,LAB_1301         * decrement & loop
00FF0276                           783  
00FF0276  4841                     784      SWAP        d1              * swap high word to low word
00FF0278  51C9 FFF4                785      DBF     d1,LAB_12FF         * decrement high count and loop until done
00FF027C                           786  
00FF027C                           787  * space is opened up, now copy the crunched line from the input buffer into the space
00FF027C                           788  
00FF027C  43EB 0890                789      LEA     Ibuffs(a3),a1       * source is input buffer
00FF0280  2448                     790      MOVEA.l a0,a2               * copy destination
00FF0282  72FF                     791      MOVEQ       #-1,d1          * set to allow re-chaining
00FF0284  24C1                     792      MOVE.l  d1,(a2)+            * set next line pointer (allow re-chaining)
00FF0286  24EB 082A                793      MOVE.l  Itemp(a3),(a2)+     * save line number
00FF028A  E24A                     794      LSR.w       #1,d2               * /2 (word copy)
00FF028C  5342                     795      SUBQ.w  #1,d2               * correct for loop end on -1
00FF028E                           796  LAB_1303
00FF028E  34D9                     797      MOVE.w  (a1)+,(a2)+         * copy word
00FF0290  51CA FFFC                798      DBF     d2,LAB_1303         * decrement & loop
00FF0294                           799  
00FF0294  6010                     800      BRA.s       LAB_1325            * go test for end of prog
00FF0296                           801  
00FF0296                           802  * rebuild chaining of Basic lines
00FF0296                           803  
00FF0296                           804  LAB_132E
00FF0296  5048                     805      ADDQ.w  #8,a0               * point to first code byte of line, there is
00FF0298                           806                              * always 1 byte + [EOL] as null entries are
00FF0298                           807                              * deleted
00FF0298                           808  LAB_1330
00FF0298  4A18                     809      TST.b       (a0)+               * test byte 
00FF029A  66FC                     810      BNE.s       LAB_1330            * loop if not [EOL]
00FF029C                           811  
00FF029C                           812                              * was [EOL] so get next line start
00FF029C  3208                     813      MOVE.w  a0,d1               * past pad byte(s)
00FF029E  0241 0001                814      ANDI.w  #1,d1               * mask odd bit
00FF02A2  D0C1                     815      ADD.w       d1,a0               * add back to ensure even
00FF02A4  2288                     816      MOVE.l  a0,(a1)         * save next line pointer to current line
00FF02A6                           817  LAB_1325
00FF02A6  2248                     818      MOVEA.l a0,a1               * copy pointer for this line
00FF02A8  4A90                     819      TST.l       (a0)                * test pointer to next line
00FF02AA  66EA                     820      BNE.s       LAB_132E            * not end of program yet so we must
00FF02AC                           821                              * go and fix the pointers
00FF02AC                           822  
00FF02AC  6100 0198                823      BSR     LAB_1477            * reset execution to start, clear variables
00FF02B0                           824                              * and flush stack
00FF02B0  6000 FF24                825      BRA     LAB_127D            * now we just wait for Basic command, no "Ready"
00FF02B4                           826  
00FF02B4                           827  
00FF02B4                           828  *************************************************************************************
00FF02B4                           829  *
00FF02B4                           830  * receive a line from the keyboard
00FF02B4                           831                              * character $08 as delete key, BACKSPACE on
00FF02B4                           832                              * standard keyboard
00FF02B4                           833  LAB_134B
00FF02B4  6100 0776                834      BSR     LAB_PRNA            * go print the character
00FF02B8  7020                     835      MOVEQ       #' ',d0         * load [SPACE]
00FF02BA  6100 0770                836      BSR     LAB_PRNA            * go print
00FF02BE  7008                     837      MOVEQ       #$08,d0         * load [BACKSPACE]
00FF02C0  6100 076A                838      BSR     LAB_PRNA            * go print
00FF02C4  5341                     839      SUBQ.w  #$01,d1         * decrement the buffer index (delete)
00FF02C6  6010                     840      BRA.s       LAB_1359            * re-enter loop
00FF02C8                           841  
00FF02C8                           842  * print "? " and get BASIC input
00FF02C8                           843  * return a0 pointing to the buffer start
00FF02C8                           844  
00FF02C8                           845  LAB_INLN
00FF02C8  6100 0760                846      BSR     LAB_18E3            * print "?" character
00FF02CC  7020                     847      MOVEQ       #' ',d0         * load " "
00FF02CE  6100 075C                848      BSR     LAB_PRNA            * go print
00FF02D2                           849  
00FF02D2                           850  * call for BASIC input (main entry point)
00FF02D2                           851  * return a0 pointing to the buffer start
00FF02D2                           852  
00FF02D2                           853  LAB_1357
00FF02D2  7200                     854      MOVEQ       #$00,d1         * clear buffer index
00FF02D4  41EB 0890                855      LEA     Ibuffs(a3),a0       * set buffer base pointer
00FF02D8                           856  LAB_1359
00FF02D8  4EAB 080C                857      JSR     V_INPT(a3)          * call scan input device
00FF02DC  64FA                     858      BCC.s       LAB_1359            * loop if no byte
00FF02DE                           859  
00FF02DE  67F8                     860      BEQ.s       LAB_1359            * loop if null byte
00FF02E0                           861  
00FF02E0  B03C 0007                862      CMP.b       #$07,d0         * compare with [BELL]
00FF02E4  6718                     863      BEQ.s       LAB_1378            * branch if [BELL]
00FF02E6                           864  
00FF02E6  B03C 000D                865      CMP.b       #$0D,d0         * compare with [CR]
00FF02EA  6700 06C2                866      BEQ     LAB_1866            * do CR/LF exit if [CR]
00FF02EE                           867  
00FF02EE  4A41                     868      TST.w       d1              * set flags on buffer index
00FF02F0  6606                     869      BNE.s       LAB_1374            * branch if not empty
00FF02F2                           870  
00FF02F2                           871  * the next two lines ignore any non printing character and [SPACE] if the input buffer
00FF02F2                           872  * is empty
00FF02F2                           873  
00FF02F2  B03C 0020                874      CMP.b       #' ',d0         * compare with [SP]+1
00FF02F6  63E0                     875      BLS.s       LAB_1359            * if < ignore character
00FF02F8                           876  
00FF02F8                           877  *## CMP.b       #' '+1,d0           * compare with [SP]+1
00FF02F8                           878  *## BCS.s       LAB_1359            * if < ignore character
00FF02F8                           879  
00FF02F8                           880  LAB_1374
00FF02F8  B03C 0008                881      CMP.b       #$08,d0         * compare with [BACKSPACE]
00FF02FC  67B6                     882      BEQ.s       LAB_134B            * go delete last character
00FF02FE                           883  
00FF02FE                           884  LAB_1378
00FF02FE  B27C 00FF                885      CMP.w       #(Ibuffe-Ibuffs-1),d1   * compare character count with max-1
00FF0302  640C                     886      BCC.s       LAB_138E            * skip store & do [BELL] if buffer full
00FF0304                           887  
00FF0304  1180 1000                888      MOVE.b  d0,(a0,d1.w)        * else store in buffer
00FF0308  5241                     889      ADDQ.w  #$01,d1         * increment index
00FF030A                           890  LAB_137F
00FF030A  6100 0720                891      BSR     LAB_PRNA            * go print the character
00FF030E  60C8                     892      BRA.s       LAB_1359            * always loop for next character
00FF0310                           893  
00FF0310                           894  * announce buffer full
00FF0310                           895  
00FF0310                           896  LAB_138E
00FF0310  7007                     897      MOVEQ       #$07,d0         * [BELL] character into d0
00FF0312  60F6                     898      BRA.s       LAB_137F            * go print the [BELL] but ignore input character
00FF0314                           899  
00FF0314                           900  
00FF0314                           901  *************************************************************************************
00FF0314                           902  *
00FF0314                           903  * copy a hex value without crunching
00FF0314                           904  
00FF0314                           905  LAB_1392
00FF0314  1180 2000                906      MOVE.b  d0,(a0,d2.w)        * save the byte to the output
00FF0318  5242                     907      ADDQ.w  #1,d2               * increment the buffer save index
00FF031A                           908  
00FF031A  5241                     909      ADDQ.w  #1,d1               * increment the buffer read index
00FF031C  1035 1000                910      MOVE.b  (a5,d1.w),d0        * get a byte from the input buffer
00FF0320  6700 0094                911      BEQ     LAB_13EC            * if [EOL] go save it without crunching
00FF0324                           912  
00FF0324  B03C 0020                913      CMP.b       #' ',d0         * compare the character with " "
00FF0328  67EA                     914      BEQ.s       LAB_1392            * if [SPACE] just go save it and get another
00FF032A                           915  
00FF032A  B03C 0030                916      CMP.b       #'0',d0         * compare the character with "0"
00FF032E  654A                     917      BCS.s       LAB_13C6            * if < "0" quit the hex save loop
00FF0330                           918  
00FF0330  B03C 0039                919      CMP.b       #'9',d0         * compare with "9"
00FF0334  63DE                     920      BLS.s       LAB_1392            * if it is "0" to "9" save it and get another
00FF0336                           921  
00FF0336  7ADF                     922      MOVEQ       #-33,d5         * mask xx0x xxxx, ASCII upper case
00FF0338  CA00                     923      AND.b       d0,d5               * mask the character
00FF033A                           924  
00FF033A  BA3C 0041                925      CMP.b       #'A',d5         * compare with "A"
00FF033E  6540                     926      BCS.s       LAB_13CC            * if < "A" quit the hex save loop
00FF0340                           927  
00FF0340  BA3C 0046                928      CMP.b       #'F',d5         * compare with "F"
00FF0344  63CE                     929      BLS.s       LAB_1392            * if it is "A" to "F" save it and get another
00FF0346                           930  
00FF0346  6038                     931      BRA.s       LAB_13CC            * else continue crunching
00FF0348                           932  
00FF0348                           933  * crunch keywords into Basic tokens
00FF0348                           934  * crunch from (a5), output to (a0)
00FF0348                           935  * returns ..
00FF0348                           936  * d4 trashed
00FF0348                           937  * d3 trashed
00FF0348                           938  * d2 is length
00FF0348                           939  * d1 trashed
00FF0348                           940  * d0 trashed
00FF0348                           941  * a1 trashed
00FF0348                           942  
00FF0348                           943  * this is the improved BASIC crunch routine and is 10 to 100 times faster than the
00FF0348                           944  * old list search
00FF0348                           945  
00FF0348                           946  LAB_13A6
00FF0348  7200                     947      MOVEQ       #0,d1               * clear the read index
00FF034A  2401                     948      MOVE.l  d1,d2               * clear the save index
00FF034C  1741 09DD                949      MOVE.b  d1,Oquote(a3)       * clear the open quote/DATA flag
00FF0350                           950  LAB_13AC
00FF0350  7000                     951      MOVEQ       #0,d0               * clear word
00FF0352  1035 1000                952      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00FF0356  675E                     953      BEQ.s       LAB_13EC            * if null save byte then continue crunching
00FF0358                           954  
00FF0358  B03C 005F                955      CMP.b       #'_',d0         * compare with "_"
00FF035C  6458                     956      BCC.s       LAB_13EC            * if >= "_" save byte then continue crunching
00FF035E                           957  
00FF035E  B03C 003C                958      CMP.b       #'<',d0         * compare with "<"
00FF0362  641C                     959      BCC.s       LAB_13CC            * if >= "<" go crunch
00FF0364                           960  
00FF0364  B03C 0030                961      CMP.b       #'0',d0         * compare with "0"
00FF0368  644C                     962      BCC.s       LAB_13EC            * if >= "0" save byte then continue crunching
00FF036A                           963  
00FF036A  1740 09DA                964      MOVE.b  d0,Asrch(a3)        * save buffer byte as search character
00FF036E  B03C 0022                965      CMP.b       #$22,d0         * is it quote character?
00FF0372  6776                     966      BEQ.s       LAB_1410            * branch if so (copy quoted string)
00FF0374                           967  
00FF0374  B03C 0024                968      CMP.b       #'$',d0         * is it the hex value character?
00FF0378  679A                     969      BEQ.s       LAB_1392            * if so go copy a hex value
00FF037A                           970  
00FF037A                           971  LAB_13C6
00FF037A  B03C 002A                972      CMP.b       #'*',d0         * compare with "*"
00FF037E  6536                     973      BCS.s       LAB_13EC            * if <= "*" save byte then continue crunching
00FF0380                           974  
00FF0380                           975                              * crunch rest
00FF0380                           976  LAB_13CC
00FF0380  082B 0006 09DD           977      BTST.b  #6,Oquote(a3)       * test open quote/DATA token flag
00FF0386  662E                     978      BNE.s       LAB_13EC            * branch if b6 of Oquote set (was DATA)
00FF0388                           979                              * go save byte then continue crunching
00FF0388                           980  
00FF0388  0400 002A                981      SUB.b       #$2A,d0         * normalise byte
00FF038C  D040                     982      ADD.w       d0,d0               * *2 makes word offset (high byte=$00)
00FF038E  43FA 2E52                983      LEA     TAB_CHRT(pc),a1     * get keyword offset table address
00FF0392  3031 0000                984      MOVE.w  (a1,d0.w),d0        * get offset into keyword table
00FF0396  6B6E                     985      BMI.s       LAB_141F            * branch if no keywords for character
00FF0398                           986  
00FF0398  43FA 3208                987      LEA     TAB_STAR(pc),a1     * get keyword table address
00FF039C  D2C0                     988      ADDA.w  d0,a1               * add keyword offset
00FF039E  76FF                     989      MOVEQ       #-1,d3          * clear index
00FF03A0  3801                     990      MOVE.w  d1,d4               * copy read index
00FF03A2                           991  LAB_13D6
00FF03A2  5243                     992      ADDQ.w  #1,d3               * increment table index
00FF03A4  1031 3000                993      MOVE.b  (a1,d3.w),d0        * get byte from table
00FF03A8                           994  LAB_13D8
00FF03A8  6B0A                     995      BMI.s       LAB_13EA            * branch if is token, save token and continue
00FF03AA                           996                              * crunching
00FF03AA                           997  
00FF03AA  5244                     998      ADDQ.w  #1,d4               * increment read index
00FF03AC  B035 4000                999      CMP.b       (a5,d4.w),d0        * compare byte from input buffer
00FF03B0  67F0                    1000      BEQ.s       LAB_13D6            * loop if character match
00FF03B2                          1001  
00FF03B2  6040                    1002      BRA.s       LAB_1417            * branch if no match
00FF03B4                          1003  
00FF03B4                          1004  LAB_13EA
00FF03B4  3204                    1005      MOVE.w  d4,d1               * update read index
00FF03B6                          1006  LAB_13EC
00FF03B6  1180 2000               1007      MOVE.b  d0,(a0,d2.w)        * save byte to output
00FF03BA  5242                    1008      ADDQ.w  #1,d2               * increment buffer save index
00FF03BC  5241                    1009      ADDQ.w  #1,d1               * increment buffer read index
00FF03BE  4A00                    1010      TST.b       d0              * set flags
00FF03C0  674A                    1011      BEQ.s       LAB_142A            * branch if was null [EOL]
00FF03C2                          1012  
00FF03C2                          1013                              * d0 holds token or byte here
00FF03C2  0400 003A               1014      SUB.b       #$3A,d0         * subtract ":"
00FF03C6  6706                    1015      BEQ.s       LAB_13FF            * branch if it was ":" (is now $00)
00FF03C8                          1016  
00FF03C8                          1017                              * d0 now holds token-$3A
00FF03C8  B03C 0049               1018      CMP.b       #(TK_DATA-$3A),d0       * compare with DATA token - $3A
00FF03CC  6604                    1019      BNE.s       LAB_1401            * branch if not DATA
00FF03CE                          1020  
00FF03CE                          1021                              * token was : or DATA
00FF03CE                          1022  LAB_13FF
00FF03CE  1740 09DD               1023      MOVE.b  d0,Oquote(a3)       * save token-$3A ($00 for ":", TK_DATA-$3A for
00FF03D2                          1024                              * DATA)
00FF03D2                          1025  LAB_1401
00FF03D2  0400 0055               1026      SUB.b       #(TK_REM-$3A),d0        * subtract REM token offset
00FF03D6  6600 FF78               1027      BNE     LAB_13AC            * If wasn't REM then go crunch rest of line
00FF03DA                          1028  
00FF03DA  1740 09DA               1029      MOVE.b  d0,Asrch(a3)        * else was REM so set search for [EOL]
00FF03DE                          1030  
00FF03DE                          1031                              * loop for REM, "..." etc.
00FF03DE                          1032  LAB_1408
00FF03DE  1035 1000               1033      MOVE.b  (a5,d1.w),d0        * get byte from input buffer
00FF03E2  67D2                    1034      BEQ.s       LAB_13EC            * branch if null [EOL]
00FF03E4                          1035  
00FF03E4  B02B 09DA               1036      CMP.b       Asrch(a3),d0        * compare with stored character
00FF03E8  67CC                    1037      BEQ.s       LAB_13EC            * branch if match (end quote, REM, :, or DATA)
00FF03EA                          1038  
00FF03EA                          1039                              * entry for copy string in quotes, don't crunch
00FF03EA                          1040  LAB_1410
00FF03EA  1180 2000               1041      MOVE.b  d0,(a0,d2.w)        * save byte to output
00FF03EE  5242                    1042      ADDQ.w  #1,d2               * increment buffer save index
00FF03F0  5241                    1043      ADDQ.w  #1,d1               * increment buffer read index
00FF03F2  60EA                    1044      BRA.s       LAB_1408            * loop
00FF03F4                          1045  
00FF03F4                          1046  * not found keyword this go so find the end of this word in the table
00FF03F4                          1047  
00FF03F4                          1048  LAB_1417
00FF03F4  3801                    1049      MOVE.w  d1,d4               * reset read pointer
00FF03F6                          1050  LAB_141B
00FF03F6  5243                    1051      ADDQ.w  #1,d3               * increment keyword table pointer, flag
00FF03F8                          1052                              * unchanged
00FF03F8  1031 3000               1053      MOVE.b  (a1,d3.w),d0        * get keyword table byte
00FF03FC  6AF8                    1054      BPL.s       LAB_141B            * if not end of keyword go do next byte
00FF03FE                          1055  
00FF03FE  5243                    1056      ADDQ.w  #1,d3               * increment keyword table pointer flag
00FF0400                          1057                              * unchanged
00FF0400  1031 3000               1058      MOVE.b  (a1,d3.w),d0        * get keyword table byte
00FF0404  66A2                    1059      BNE.s       LAB_13D8            * go test next word if not zero byte (table end)
00FF0406                          1060  
00FF0406                          1061                              * reached end of table with no match
00FF0406                          1062  LAB_141F
00FF0406  1035 1000               1063      MOVE.b  (a5,d1.w),d0        * restore byte from input buffer
00FF040A  60AA                    1064      BRA.s       LAB_13EC            * go save byte in output and continue crunching
00FF040C                          1065  
00FF040C                          1066                              * reached [EOL]
00FF040C                          1067  LAB_142A
00FF040C  7000                    1068      MOVEQ       #0,d0               * ensure longword clear
00FF040E  0102                    1069      BTST        d0,d2               * test odd bit (fastest)
00FF0410  6706                    1070      BEQ.s       LAB_142C            * branch if no bytes to fill
00FF0412                          1071  
00FF0412  1180 2000               1072      MOVE.b  d0,(a0,d2.w)        * clear next byte
00FF0416  5242                    1073      ADDQ.w  #1,d2               * increment buffer save index
00FF0418                          1074  LAB_142C
00FF0418  2180 2000               1075      MOVE.l  d0,(a0,d2.w)        * clear next line pointer, EOT in immediate mode
00FF041C  4E75                    1076      RTS
00FF041E                          1077  
00FF041E                          1078  
00FF041E                          1079  *************************************************************************************
00FF041E                          1080  *
00FF041E                          1081  * search Basic for d1 line number from start of mem
00FF041E                          1082  
00FF041E                          1083  LAB_SSLN
00FF041E  206B 082E               1084      MOVEA.l Smeml(a3),a0        * get start of program mem
00FF0422  6002                    1085      BRA.s       LAB_SCLN            * go search for required line from a0
00FF0424                          1086  
00FF0424                          1087  LAB_145F
00FF0424  2040                    1088      MOVEA.l d0,a0               * copy next line pointer
00FF0426                          1089  
00FF0426                          1090  * search Basic for d1 line number from a0
00FF0426                          1091  * returns Cb=0 if found
00FF0426                          1092  * returns a0 pointer to found or next higher (not found) line
00FF0426                          1093  
00FF0426                          1094  LAB_SCLN
00FF0426  2018                    1095      MOVE.l  (a0)+,d0            * get next line pointer and point to line #
00FF0428  6708                    1096      BEQ.s       LAB_145E            * is end marker so we're done, do 'no line' exit
00FF042A                          1097  
00FF042A  B290                    1098      CMP.l       (a0),d1         * compare this line # with required line #
00FF042C  6EF6                    1099      BGT.s       LAB_145F            * loop if required # > this #
00FF042E                          1100  
00FF042E  5948                    1101      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00FF0430  4E75                    1102      RTS
00FF0432                          1103  
00FF0432                          1104  LAB_145E
00FF0432  5948                    1105      SUBQ.w  #4,a0               * adjust pointer, flags not changed
00FF0434  5380                    1106      SUBQ.l  #1,d0               * make end program found = -1, set carry
00FF0436  4E75                    1107      RTS
00FF0438                          1108  
00FF0438                          1109  
00FF0438                          1110  *************************************************************************************
00FF0438                          1111  *
00FF0438                          1112  * perform NEW
00FF0438                          1113  
00FF0438                          1114  LAB_NEW
00FF0438  664C                    1115      BNE.s       RTS_005         * exit if not end of statement (do syntax error)
00FF043A                          1116  
00FF043A                          1117  LAB_1463
00FF043A  206B 082E               1118      MOVEA.l Smeml(a3),a0        * point to start of program memory
00FF043E  7000                    1119      MOVEQ       #0,d0               * clear longword
00FF0440  20C0                    1120      MOVE.l  d0,(a0)+            * clear first line, next line pointer
00FF0442  2748 0832               1121      MOVE.l  a0,Sfncl(a3)        * set start of functions
00FF0446                          1122  
00FF0446                          1123  * reset execution to start, clear variables and flush stack
00FF0446                          1124  
00FF0446                          1125  LAB_1477
00FF0446  2A6B 082E               1126      MOVEA.l Smeml(a3),a5        * reset BASIC execute pointer
00FF044A  534D                    1127      SUBQ.w  #1,a5               * -1 (as end of previous line)
00FF044C                          1128  
00FF044C                          1129  * "CLEAR" command gets here
00FF044C                          1130  
00FF044C                          1131  LAB_147A
00FF044C  276B 084A 0846          1132      MOVE.l  Ememl(a3),Sstorl(a3)    * save end of mem as bottom of string space
00FF0452  202B 0832               1133      MOVE.l  Sfncl(a3),d0        * get start of functions
00FF0456  2740 0836               1134      MOVE.l  d0,Svarl(a3)        * start of variables
00FF045A  2740 083A               1135      MOVE.l  d0,Sstrl(a3)        * start of strings
00FF045E  2740 083E               1136      MOVE.l  d0,Sarryl(a3)       * set start of arrays
00FF0462  2740 0842               1137      MOVE.l  d0,Earryl(a3)       * set end of arrays
00FF0466  7000                    1138      MOVEQ       #0,d0               * set Zb
00FF0468  1740 09EA               1139      MOVE.b  d0,ccnull(a3)       * clear get byte countdown
00FF046C  6100 01CE               1140      BSR     LAB_RESTORE         * perform RESTORE command
00FF0470                          1141  
00FF0470                          1142  * flush stack & clear continue flag
00FF0470                          1143  
00FF0470                          1144  LAB_1491
00FF0470  49EB 088E               1145      LEA     des_sk(a3),a4       * reset descriptor stack pointer
00FF0474                          1146  
00FF0474  201F                    1147      MOVE.l  (sp)+,d0            * pull return address
00FF0476  4FEB 0800               1148      LEA     ram_base(a3),sp     * set stack to RAM start + 1k, flush stack
00FF047A  2F00                    1149      MOVE.l  d0,-(sp)            * restore return address
00FF047C                          1150  
00FF047C  7000                    1151      MOVEQ       #0,d0               * clear longword
00FF047E  2740 085A               1152      MOVE.l  d0,Cpntrl(a3)       * clear continue pointer
00FF0482  1740 09DF               1153      MOVE.b  d0,Sufnxf(a3)       * clear subscript/FNX flag
00FF0486                          1154  RTS_005
00FF0486  4E75                    1155      RTS
00FF0488                          1156  
00FF0488                          1157  
00FF0488                          1158  *************************************************************************************
00FF0488                          1159  *
00FF0488                          1160  * perform CLEAR
00FF0488                          1161  
00FF0488                          1162  LAB_CLEAR
00FF0488  67C2                    1163      BEQ.s       LAB_147A            * if no following byte go do "CLEAR"
00FF048A                          1164  
00FF048A  4E75                    1165      RTS                     * was following byte (go do syntax error)
00FF048C                          1166  
00FF048C                          1167  
00FF048C                          1168  *************************************************************************************
00FF048C                          1169  *
00FF048C                          1170  * perform LIST [n][-m]
00FF048C                          1171  
00FF048C                          1172  LAB_LIST
00FF048C  6512                    1173      BCS.s       LAB_14BD            * branch if next character numeric (LIST n...)
00FF048E                          1174  
00FF048E  72FF                    1175      MOVEQ       #-1,d1          * set end to $FFFFFFFF
00FF0490  2741 082A               1176      MOVE.l  d1,Itemp(a3)        * save to Itemp
00FF0494                          1177  
00FF0494  7200                    1178      MOVEQ       #0,d1               * set start to $00000000
00FF0496  4A00                    1179      TST.b       d0              * test next byte
00FF0498  670A                    1180      BEQ.s       LAB_14C0            * branch if next character [NULL] (LIST)
00FF049A                          1181  
00FF049A  B03C 00C0               1182      CMP.b       #TK_MINUS,d0        * compare with token for -
00FF049E  66E6                    1183      BNE.s       RTS_005         * exit if not - (LIST -m)
00FF04A0                          1184  
00FF04A0                          1185                              * LIST [[n]-[m]] this sets the n, if present,
00FF04A0                          1186                              * as the start and end
00FF04A0                          1187  LAB_14BD
00FF04A0  6100 0392               1188      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00FF04A4                          1189  LAB_14C0
00FF04A4  6100 FF78               1190      BSR     LAB_SSLN            * search BASIC for d1 line number
00FF04A8                          1191                              * (pointer in a0)
00FF04A8  6100 0934               1192      BSR     LAB_GBYT            * scan memory
00FF04AC  6716                    1193      BEQ.s       LAB_14D4            * branch if no more characters
00FF04AE                          1194  
00FF04AE                          1195                              * this bit checks the - is present
00FF04AE  B03C 00C0               1196      CMP.b       #TK_MINUS,d0        * compare with token for -
00FF04B2  66D2                    1197      BNE.s       RTS_005         * return if not "-" (will be Syntax error)
00FF04B4                          1198  
00FF04B4  72FF                    1199      MOVEQ       #-1,d1          * set end to $FFFFFFFF
00FF04B6  2741 082A               1200      MOVE.l  d1,Itemp(a3)        * save Itemp
00FF04BA                          1201  
00FF04BA                          1202                              * LIST [n]-[m] the - was there so see if
00FF04BA                          1203                              * there is an m to set as the end value
00FF04BA  6100 0920               1204      BSR     LAB_IGBY            * increment & scan memory
00FF04BE  6704                    1205      BEQ.s       LAB_14D4            * branch if was [NULL] (LIST n-)
00FF04C0                          1206  
00FF04C0  6100 0372               1207      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00FF04C4                          1208  LAB_14D4
00FF04C4  177C 0000 09DD          1209      MOVE.b  #$00,Oquote(a3)     * clear open quote flag
00FF04CA  6100 04E8               1210      BSR     LAB_CRLF            * print CR/LF
00FF04CE  2018                    1211      MOVE.l  (a0)+,d0            * get next line pointer
00FF04D0  67B4                    1212      BEQ.s       RTS_005         * if null all done so exit
00FF04D2                          1213  
00FF04D2  2240                    1214      MOVEA.l d0,a1               * copy next line pointer
00FF04D4  6100 012C               1215      BSR     LAB_1629            * do CRTL-C check vector
00FF04D8                          1216  
00FF04D8  2018                    1217      MOVE.l  (a0)+,d0            * get this line #
00FF04DA  B0AB 082A               1218      CMP.l       Itemp(a3),d0        * compare end line # with this line #
00FF04DE  62A6                    1219      BHI.s       RTS_005         * if this line greater all done so exit
00FF04E0                          1220  
00FF04E0                          1221  LAB_14E2
00FF04E0  48E7 00C0               1222      MOVEM.l a0-a1,-(sp)         * save registers
00FF04E4  6100 1A3A               1223      BSR     LAB_295E            * print d0 as unsigned integer
00FF04E8  4CDF 0300               1224      MOVEM.l (sp)+,a0-a1         * restore registers
00FF04EC  7020                    1225      MOVEQ       #$20,d0         * space is the next character
00FF04EE                          1226  LAB_150C
00FF04EE  6100 053C               1227      BSR     LAB_PRNA            * go print the character
00FF04F2  B03C 0022               1228      CMP.b       #$22,d0         * was it " character
00FF04F6  6606                    1229      BNE.s       LAB_1519            * branch if not
00FF04F8                          1230  
00FF04F8                          1231                              * we're either entering or leaving quotes
00FF04F8  0A2B 00FF 09DD          1232      EOR.b       #$FF,Oquote(a3)     * toggle open quote flag
00FF04FE                          1233  LAB_1519
00FF04FE  1018                    1234      MOVE.b  (a0)+,d0            * get byte and increment pointer
00FF0500  6608                    1235      BNE.s       LAB_152E            * branch if not [EOL] (go print)
00FF0502                          1236  
00FF0502                          1237                              * was [EOL]
00FF0502  2049                    1238      MOVEA.l a1,a0               * copy next line pointer
00FF0504  2008                    1239      MOVE.l  a0,d0               * copy to set flags
00FF0506  66BC                    1240      BNE.s       LAB_14D4            * go do next line if not [EOT]
00FF0508                          1241  
00FF0508  4E75                    1242      RTS
00FF050A                          1243  
00FF050A                          1244  LAB_152E
00FF050A  6AE2                    1245      BPL.s       LAB_150C            * just go print it if not token byte
00FF050C                          1246  
00FF050C                          1247                              * else it was a token byte so maybe uncrunch it
00FF050C  4A2B 09DD               1248      TST.b       Oquote(a3)          * test the open quote flag
00FF0510  6BDC                    1249      BMI.s       LAB_150C            * just go print character if open quote set
00FF0512                          1250  
00FF0512                          1251                              * else uncrunch BASIC token
00FF0512  45FA 2D38               1252      LEA     LAB_KEYT(pc),a2     * get keyword table address
00FF0516  727F                    1253      MOVEQ       #$7F,d1         * mask into d1
00FF0518  C200                    1254      AND.b       d0,d1               * copy and mask token
00FF051A  E549                    1255      LSL.w       #2,d1               * *4
00FF051C  45F2 1000               1256      LEA     (a2,d1.w),a2        * get keyword entry address
00FF0520  101A                    1257      MOVE.b  (a2)+,d0            * get byte from keyword table
00FF0522  6100 0508               1258      BSR     LAB_PRNA            * go print the first character
00FF0526  7200                    1259      MOVEQ       #0,d1               * clear d1
00FF0528  121A                    1260      MOVE.b  (a2)+,d1            * get remaining length byte from keyword table
00FF052A  6BD2                    1261      BMI.s       LAB_1519            * if -ve done so go get next byte
00FF052C                          1262  
00FF052C  3012                    1263      MOVE.w  (a2),d0         * get offset to rest
00FF052E  45FA 3072               1264      LEA     TAB_STAR(pc),a2     * get keyword table address
00FF0532  45F2 0000               1265      LEA     (a2,d0.w),a2        * get address of rest
00FF0536                          1266  LAB_1540
00FF0536  101A                    1267      MOVE.b  (a2)+,d0            * get byte from keyword table
00FF0538  6100 04F2               1268      BSR     LAB_PRNA            * go print the character
00FF053C  51C9 FFF8               1269      DBF     d1,LAB_1540         * decrement and loop if more to do
00FF0540                          1270  
00FF0540  60BC                    1271      BRA.s       LAB_1519            * go get next byte
00FF0542                          1272  
00FF0542                          1273  
00FF0542                          1274  *************************************************************************************
00FF0542                          1275  *
00FF0542                          1276  * perform FOR
00FF0542                          1277  
00FF0542                          1278  LAB_FOR
00FF0542  6100 0390               1279      BSR     LAB_LET         * go do LET
00FF0546                          1280  
00FF0546  202B 0872               1281      MOVE.l  Lvarpl(a3),d0       * get the loop variable pointer
00FF054A  B0AB 083A               1282      CMP.l       Sstrl(a3),d0        * compare it with the end of vars memory
00FF054E  6C00 FC22               1283      BGE     LAB_TMER            * if greater go do type mismatch error
00FF0552                          1284  
00FF0552                          1285  * test for not less than the start of variables memory if needed
00FF0552                          1286  *
00FF0552                          1287  *   CMP.l       Svarl(a3),d0        * compare it with the start of variables memory
00FF0552                          1288  *   BLT     LAB_TMER            * if not variables memory do type mismatch error
00FF0552                          1289  
00FF0552                          1290  *   MOVEQ       #28,d0          * we need 28 bytes !
00FF0552                          1291  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00FF0552  6100 0214               1292      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00FF0556                          1293                              * returns a0 as pointer to [:] or [EOL]
00FF0556  2E88                    1294      MOVE.l  a0,(sp)         * push onto stack (and dump the return address)
00FF0558  2F2B 0852               1295      MOVE.l  Clinel(a3),-(sp)        * push current line onto stack
00FF055C                          1296  
00FF055C  70B7                    1297      MOVEQ       #TK_TO-$100,d0      * set "TO" token
00FF055E  6100 0874               1298      BSR     LAB_SCCA            * scan for CHR$(d0) else syntax error/warm start
00FF0562  6100 0702               1299      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00FF0566  1F2B 09B5               1300      MOVE.b  Dtypef(a3),-(sp)        * push the FOR variable data type onto stack
00FF056A  6100 06F8               1301      BSR     LAB_EVNM            * evaluate expression and check is numeric else
00FF056E                          1302                              * do type mismatch
00FF056E                          1303  
00FF056E  2F2B 0990               1304      MOVE.l  FAC1_m(a3),-(sp)        * push TO value mantissa
00FF0572  3F2B 0994               1305      MOVE.w  FAC1_e(a3),-(sp)        * push TO value exponent and sign
00FF0576                          1306  
00FF0576  277C 80000000 0990      1307      MOVE.l  #$80000000,FAC1_m(a3)   * set default STEP size mantissa
00FF057E  377C 8100 0994          1308      MOVE.w  #$8100,FAC1_e(a3)       * set default STEP size exponent and sign
00FF0584                          1309  
00FF0584  6100 0858               1310      BSR     LAB_GBYT            * scan memory
00FF0588  B03C 00BC               1311      CMP.b       #TK_STEP,d0         * compare with STEP token
00FF058C  6608                    1312      BNE.s       LAB_15B3            * jump if not "STEP"
00FF058E                          1313  
00FF058E                          1314                              * was STEP token so ....
00FF058E  6100 084C               1315      BSR     LAB_IGBY            * increment & scan memory
00FF0592  6100 06D0               1316      BSR     LAB_EVNM            * evaluate expression & check is numeric
00FF0596                          1317                              * else do type mismatch
00FF0596                          1318  LAB_15B3
00FF0596  2F2B 0990               1319      MOVE.l  FAC1_m(a3),-(sp)        * push STEP value mantissa
00FF059A  3F2B 0994               1320      MOVE.w  FAC1_e(a3),-(sp)        * push STEP value exponent and sign
00FF059E                          1321  
00FF059E  2F2B 0872               1322      MOVE.l  Lvarpl(a3),-(sp)        * push variable pointer for FOR/NEXT
00FF05A2  3F3C 0081               1323      MOVE.w  #TK_FOR,-(sp)       * push FOR token on stack
00FF05A6                          1324  
00FF05A6  6018                    1325      BRA.s       LAB_15C2            * go do interpreter inner loop
00FF05A8                          1326  
00FF05A8                          1327  LAB_15DC                        * have reached [EOL]+1
00FF05A8  300D                    1328      MOVE.w  a5,d0               * copy BASIC execute pointer
00FF05AA  C07C 0001               1329      AND.w       #1,d0               * and make line start address even
00FF05AE  DAC0                    1330      ADD.w       d0,a5               * add to BASIC execute pointer
00FF05B0  201D                    1331      MOVE.l  (a5)+,d0            * get next line pointer
00FF05B2  6700 FC1A               1332      BEQ     LAB_1274            * if null go to immediate mode, no "BREAK"
00FF05B6                          1333                              * message (was immediate or [EOT] marker)
00FF05B6                          1334  
00FF05B6  275D 0852               1335      MOVE.l  (a5)+,Clinel(a3)        * save (new) current line #
00FF05BA                          1336  LAB_15F6
00FF05BA  6100 0822               1337      BSR     LAB_GBYT            * get BASIC byte
00FF05BE  611A                    1338      BSR.s       LAB_15FF            * go interpret BASIC code from (a5)
00FF05C0                          1339  
00FF05C0                          1340  * interpreter inner loop (re)entry point
00FF05C0                          1341  
00FF05C0                          1342  LAB_15C2
00FF05C0  6140                    1343      BSR.s       LAB_1629            * do CRTL-C check vector
00FF05C2  4A2B 0852               1344      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00FF05C6  6B04                    1345      BMI.s       LAB_15D1            * branch if immediate mode
00FF05C8                          1346  
00FF05C8  274D 085A               1347      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00FF05CC                          1348  LAB_15D1
00FF05CC  101D                    1349      MOVE.b  (a5)+,d0            * get this byte & increment pointer
00FF05CE  67D8                    1350      BEQ.s       LAB_15DC            * loop if [EOL]
00FF05D0                          1351  
00FF05D0  B03C 003A               1352      CMP.b       #$3A,d0         * compare with ":"
00FF05D4  67E4                    1353      BEQ.s       LAB_15F6            * loop if was statement separator
00FF05D6                          1354  
00FF05D6  6000 FBC6               1355      BRA     LAB_SNER            * else syntax error, then warm start
00FF05DA                          1356  
00FF05DA                          1357  
00FF05DA                          1358  *************************************************************************************
00FF05DA                          1359  *
00FF05DA                          1360  * interpret BASIC code from (a5)
00FF05DA                          1361  
00FF05DA                          1362  LAB_15FF
00FF05DA  6700 008C               1363      BEQ     RTS_006         * exit if zero [EOL]
00FF05DE                          1364  
00FF05DE                          1365  LAB_1602
00FF05DE  0A00 0080               1366      EORI.b  #$80,d0         * normalise token
00FF05E2  6B00 02F0               1367      BMI     LAB_LET         * if not token, go do implied LET
00FF05E6                          1368  
00FF05E6  B03C 0035               1369      CMP.b       #(TK_TAB-$80),d0        * compare normalised token with TAB
00FF05EA  6400 FBB2               1370      BCC     LAB_SNER            * branch if d0>=TAB, syntax error/warm start
00FF05EE                          1371                              * only tokens before TAB can start a statement
00FF05EE                          1372  
00FF05EE  4880                    1373      EXT.w       d0              * byte to word (clear high byte)
00FF05F0  D040                    1374      ADD.w       d0,d0               * *2
00FF05F2  41FA 2A94               1375      LEA     LAB_CTBL(pc),a0     * get vector table base address
00FF05F6  3030 0000               1376      MOVE.w  (a0,d0.w),d0        * get offset to vector
00FF05FA  4870 0000               1377      PEA     (a0,d0.w)           * push vector
00FF05FE  6000 07DC               1378      BRA     LAB_IGBY            * get following byte & execute vector
00FF0602                          1379  
00FF0602                          1380  
00FF0602                          1381  *************************************************************************************
00FF0602                          1382  *
00FF0602                          1383  * CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
00FF0602                          1384  * key press is detected.
00FF0602                          1385  
00FF0602                          1386  LAB_1629
00FF0602  4EEB 0824               1387      JMP     V_CTLC(a3)          * ctrl c check vector
00FF0606                          1388  
00FF0606                          1389  * if there was a key press it gets back here .....
00FF0606                          1390  
00FF0606                          1391  LAB_1636
00FF0606  B03C 0003               1392      CMP.b       #$03,d0         * compare with CTRL-C
00FF060A  670C                    1393      BEQ.s       LAB_163B            * STOP if was CTRL-C
00FF060C                          1394  
00FF060C                          1395  LAB_1639
00FF060C  4E75                    1396      RTS
00FF060E                          1397  
00FF060E                          1398  
00FF060E                          1399  *************************************************************************************
00FF060E                          1400  *
00FF060E                          1401  * perform END
00FF060E                          1402  
00FF060E                          1403  LAB_END
00FF060E  66FC                    1404      BNE.s       LAB_1639            * exit if something follows STOP
00FF0610  177C 0000 09DC          1405      MOVE.b  #0,Breakf(a3)       * clear break flag, indicate program end
00FF0616                          1406  
00FF0616                          1407  
00FF0616                          1408  *************************************************************************************
00FF0616                          1409  *
00FF0616                          1410  * perform STOP
00FF0616                          1411  
00FF0616                          1412  LAB_STOP
00FF0616  66F4                    1413      BNE.s       LAB_1639            * exit if something follows STOP
00FF0618                          1414  
00FF0618                          1415  LAB_163B
00FF0618  43EB 0990               1416      LEA     Ibuffe(a3),a1       * get buffer end
00FF061C  BBC9                    1417      CMPA.l  a1,a5               * compare execute address with buffer end
00FF061E  650A                    1418      BCS.s       LAB_164F            * branch if BASIC pointer is in buffer
00FF0620                          1419                              * can't continue in immediate mode
00FF0620                          1420  
00FF0620                          1421                              * else...
00FF0620  274D 085A               1422      MOVE.l  a5,Cpntrl(a3)       * save BASIC execute pointer as continue pointer
00FF0624                          1423  LAB_1647
00FF0624  276B 0852 0856          1424      MOVE.l  Clinel(a3),Blinel(a3)   * save break line
00FF062A                          1425  LAB_164F
00FF062A  584F                    1426      ADDQ.w  #4,sp               * dump return address, don't return to execute
00FF062C                          1427                              * loop
00FF062C  102B 09DC               1428      MOVE.b  Breakf(a3),d0       * get break flag
00FF0630  6700 FB9C               1429      BEQ     LAB_1274            * go do warm start if was program end
00FF0634                          1430  
00FF0634  41FA 315F               1431      LEA     LAB_BMSG(pc),a0     * point to "Break"
00FF0638  6000 FB86               1432      BRA     LAB_1269            * print "Break" and do warm start
00FF063C                          1433  
00FF063C                          1434  
00FF063C                          1435  *************************************************************************************
00FF063C                          1436  *
00FF063C                          1437  * perform RESTORE
00FF063C                          1438  
00FF063C                          1439  LAB_RESTORE
00FF063C  206B 082E               1440      MOVEA.l Smeml(a3),a0        * copy start of memory
00FF0640  6720                    1441      BEQ.s       LAB_1624            * branch if next character null (RESTORE)
00FF0642                          1442  
00FF0642  6100 01F0               1443      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00FF0646  B2AB 0852               1444      CMP.l       Clinel(a3),d1       * compare current line # with required line #
00FF064A  630E                    1445      BLS.s       LAB_GSCH            * branch if >= (start search from beginning)
00FF064C                          1446  
00FF064C  204D                    1447      MOVEA.l a5,a0               * copy BASIC execute pointer
00FF064E                          1448  LAB_RESs
00FF064E  4A18                    1449      TST.b       (a0)+               * test next byte & increment pointer
00FF0650  66FC                    1450      BNE.s       LAB_RESs            * loop if not EOL
00FF0652                          1451  
00FF0652  3008                    1452      MOVE.w  a0,d0               * copy pointer
00FF0654  C07C 0001               1453      AND.w       #1,d0               * mask odd bit
00FF0658  D0C0                    1454      ADD.w       d0,a0               * add pointer
00FF065A                          1455                              * search for line in Itemp from (a0)
00FF065A                          1456  LAB_GSCH
00FF065A  6100 FDCA               1457      BSR     LAB_SCLN            * search for d1 line number from a0
00FF065E                          1458                              * returns Cb=0 if found
00FF065E  6500 FB26               1459      BCS     LAB_USER            * go do "Undefined statement" error if not found
00FF0662                          1460  
00FF0662                          1461  LAB_1624
00FF0662  4A20                    1462      TST.b       -(a0)               * decrement pointer (faster)
00FF0664  2748 0862               1463      MOVE.l  a0,Dptrl(a3)        * save DATA pointer
00FF0668                          1464  RTS_006
00FF0668  4E75                    1465      RTS
00FF066A                          1466  
00FF066A                          1467  
00FF066A                          1468  *************************************************************************************
00FF066A                          1469  *
00FF066A                          1470  * perform NULL
00FF066A                          1471  
00FF066A                          1472  LAB_NULL
00FF066A  6100 10E2               1473      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00FF066E  1740 09E4               1474      MOVE.b  d0,Nullct(a3)       * save new NULL count
00FF0672  4E75                    1475      RTS
00FF0674                          1476  
00FF0674                          1477  
00FF0674                          1478  *************************************************************************************
00FF0674                          1479  *
00FF0674                          1480  * perform CONT
00FF0674                          1481  
00FF0674                          1482  LAB_CONT
00FF0674  6600 FB28               1483      BNE     LAB_SNER            * if following byte exit to do syntax error
00FF0678                          1484  
00FF0678  4A2B 0852               1485      TST.b       Clinel(a3)          * test current line #, is -ve for immediate mode
00FF067C  6A00 FAE8               1486      BPL     LAB_CCER            * if running go do can't continue error
00FF0680                          1487  
00FF0680  202B 085A               1488      MOVE.l  Cpntrl(a3),d0       * get continue pointer
00FF0684  6700 FAE0               1489      BEQ     LAB_CCER            * go do can't continue error if we can't
00FF0688                          1490  
00FF0688                          1491                              * we can continue so ...
00FF0688  2A40                    1492      MOVEA.l d0,a5               * save continue pointer as BASIC execute pointer
00FF068A  276B 0856 0852          1493      MOVE.l  Blinel(a3),Clinel(a3)   * set break line as current line
00FF0690  4E75                    1494      RTS
00FF0692                          1495  
00FF0692                          1496  
00FF0692                          1497  *************************************************************************************
00FF0692                          1498  *
00FF0692                          1499  * perform RUN
00FF0692                          1500  
00FF0692                          1501  LAB_RUN
00FF0692  660C                    1502      BNE.s       LAB_RUNn            * if following byte do RUN n
00FF0694                          1503  
00FF0694  6100 FDB0               1504      BSR     LAB_1477            * execution to start, clear vars & flush stack
00FF0698  274D 085A               1505      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00FF069C  6000 FF22               1506      BRA     LAB_15C2            * go do interpreter inner loop
00FF06A0                          1507                              * (can't RTS, we flushed the stack!)
00FF06A0                          1508  
00FF06A0                          1509  LAB_RUNn
00FF06A0  6100 FDAA               1510      BSR     LAB_147A            * go do "CLEAR"
00FF06A4  601C                    1511      BRA.s       LAB_16B0            * get n and do GOTO n
00FF06A6                          1512  
00FF06A6                          1513  
00FF06A6                          1514  *************************************************************************************
00FF06A6                          1515  *
00FF06A6                          1516  * perform DO
00FF06A6                          1517  
00FF06A6                          1518  LAB_DO
00FF06A6                          1519  *   MOVE.l  #$05,d0         * need 5 bytes for DO 
00FF06A6                          1520  *   BSR.s       LAB_1212            * check room on stack for A bytes
00FF06A6  2F0D                    1521      MOVE.l  a5,-(sp)            * push BASIC execute pointer on stack
00FF06A8  2F2B 0852               1522      MOVE.l  Clinel(a3),-(sp)        * push current line on stack
00FF06AC  3F3C 009C               1523      MOVE.w  #TK_DO,-(sp)        * push token for DO on stack
00FF06B0  487A FF0E               1524      PEA     LAB_15C2(pc)        * set return address
00FF06B4  6000 0728               1525      BRA     LAB_GBYT            * scan memory and return to interpreter inner
00FF06B8                          1526                              * loop
00FF06B8                          1527  
00FF06B8                          1528  
00FF06B8                          1529  *************************************************************************************
00FF06B8                          1530  *
00FF06B8                          1531  * perform GOSUB
00FF06B8                          1532  
00FF06B8                          1533  LAB_GOSUB
00FF06B8                          1534  *   MOVE.l  #10,d0          * need 10 bytes for GOSUB 
00FF06B8                          1535  *   BSR.s       LAB_1212            * check room on stack for d0 bytes
00FF06B8  2F0D                    1536      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00FF06BA  2F2B 0852               1537      MOVE.l  Clinel(a3),-(sp)        * push current line
00FF06BE  3F3C 008D               1538      MOVE.w  #TK_GOSUB,-(sp)     * push token for GOSUB
00FF06C2                          1539  LAB_16B0
00FF06C2  6100 071A               1540      BSR     LAB_GBYT            * scan memory
00FF06C6  487A FEF8               1541      PEA     LAB_15C2(pc)        * return to interpreter inner loop after GOTO n
00FF06CA                          1542  
00FF06CA                          1543  * this PEA is needed because either we just cleared the stack and have nowhere to return
00FF06CA                          1544  * to or, in the case of GOSUB, we have just dropped a load on the stack and the address
00FF06CA                          1545  * we whould have returned to is buried. This burried return address will be unstacked by
00FF06CA                          1546  * the corresponding RETURN command
00FF06CA                          1547  
00FF06CA                          1548  
00FF06CA                          1549  *************************************************************************************
00FF06CA                          1550  *
00FF06CA                          1551  * perform GOTO
00FF06CA                          1552  
00FF06CA                          1553  LAB_GOTO
00FF06CA  6100 0168               1554      BSR     LAB_GFPN            * get fixed-point number into temp integer & d1
00FF06CE  206B 082E               1555      MOVEA.l Smeml(a3),a0        * get start of memory
00FF06D2  B2AB 0852               1556      CMP.l       Clinel(a3),d1       * compare current line with wanted #
00FF06D6  630E                    1557      BLS.s       LAB_16D0            * branch if current # => wanted #
00FF06D8                          1558  
00FF06D8  204D                    1559      MOVEA.l a5,a0               * copy BASIC execute pointer
00FF06DA                          1560  LAB_GOTs
00FF06DA  4A18                    1561      TST.b       (a0)+               * test next byte & increment pointer
00FF06DC  66FC                    1562      BNE.s       LAB_GOTs            * loop if not EOL
00FF06DE                          1563  
00FF06DE  3008                    1564      MOVE.w  a0,d0               * past pad byte(s)
00FF06E0  C07C 0001               1565      AND.w       #1,d0               * mask odd bit
00FF06E4  D0C0                    1566      ADD.w       d0,a0               * add to pointer
00FF06E6                          1567  
00FF06E6                          1568  LAB_16D0
00FF06E6  6100 FD3E               1569      BSR     LAB_SCLN            * search for d1 line number from a0
00FF06EA                          1570                              * returns Cb=0 if found
00FF06EA  6500 FA9A               1571      BCS     LAB_USER            * if carry set go do "Undefined statement" error
00FF06EE                          1572  
00FF06EE  2A48                    1573      MOVEA.l a0,a5               * copy to BASIC execute pointer
00FF06F0  534D                    1574      SUBQ.w  #1,a5               * decrement pointer
00FF06F2  274D 085A               1575      MOVE.l  a5,Cpntrl(a3)       * save as continue pointer
00FF06F6  4E75                    1576      RTS
00FF06F8                          1577  
00FF06F8                          1578  
00FF06F8                          1579  *************************************************************************************
00FF06F8                          1580  *
00FF06F8                          1581  * perform LOOP
00FF06F8                          1582  
00FF06F8                          1583  LAB_LOOP
00FF06F8  0C6F 009C 0004          1584      CMP.w       #TK_DO,4(sp)        * compare token on stack with DO token
00FF06FE  6600 FA5E               1585      BNE     LAB_LDER            * branch if no matching DO
00FF0702                          1586  
00FF0702  1E00                    1587      MOVE.b  d0,d7               * copy following token (byte)
00FF0704  672E                    1588      BEQ.s       LoopAlways          * if no following token loop forever
00FF0706                          1589  
00FF0706  BE3C 003A               1590      CMP.b       #':',d7         * compare with ":"
00FF070A  6728                    1591      BEQ.s       LoopAlways          * if no following token loop forever
00FF070C                          1592  
00FF070C  0407 00BD               1593      SUB.b       #TK_UNTIL,d7        * subtract token for UNTIL
00FF0710  6708                    1594      BEQ.s       DoRest          * branch if was UNTIL
00FF0712                          1595  
00FF0712  5307                    1596      SUBQ.b  #1,d7               * decrement result
00FF0714  6600 FA88               1597      BNE     LAB_SNER            * if not WHILE go do syntax error & warm start
00FF0718                          1598                              * only if the token was WHILE will this fail
00FF0718                          1599  
00FF0718  7EFF                    1600      MOVEQ       #-1,d7          * set invert result longword
00FF071A                          1601  DoRest
00FF071A  6100 06C0               1602      BSR     LAB_IGBY            * increment & scan memory
00FF071E  6100 055C               1603      BSR     LAB_EVEX            * evaluate expression
00FF0722  4A2B 0994               1604      TST.b       FAC1_e(a3)          * test FAC1 exponent
00FF0726  6706                    1605      BEQ.s       DoCmp               * if = 0 go do straight compare
00FF0728                          1606  
00FF0728  177C 00FF 0994          1607      MOVE.b  #$FF,FAC1_e(a3)     * else set all bits
00FF072E                          1608  DoCmp
00FF072E  BF2B 0994               1609      EOR.b       d7,FAC1_e(a3)       * EOR with invert byte
00FF0732  6614                    1610      BNE.s       LoopDone            * if <> 0 clear stack & back to interpreter loop
00FF0734                          1611  
00FF0734                          1612                              * loop condition wasn't met so do it again
00FF0734                          1613  LoopAlways
00FF0734  276F 0006 0852          1614      MOVE.l  6(sp),Clinel(a3)        * copy DO current line
00FF073A  2A6F 000A               1615      MOVE.l  10(sp),a5           * save BASIC execute pointer
00FF073E                          1616  
00FF073E  41FA FE80               1617      LEA     LAB_15C2(pc),a0     * get return address
00FF0742  2E88                    1618      MOVE.l  a0,(sp)         * dump the call to this routine and set the
00FF0744                          1619                              * return address
00FF0744  6000 0698               1620      BRA     LAB_GBYT            * scan memory and return to interpreter inner
00FF0748                          1621                              * loop
00FF0748                          1622  
00FF0748                          1623                              * clear stack & back to interpreter loop
00FF0748                          1624  LoopDone
00FF0748  4FEF 000E               1625      LEA     14(sp),sp           * dump structure and call from stack
00FF074C  6014                    1626      BRA.s       LAB_DATA            * go perform DATA (find : or [EOL])
00FF074E                          1627  
00FF074E                          1628  
00FF074E                          1629  *************************************************************************************
00FF074E                          1630  *
00FF074E                          1631  * perform RETURN
00FF074E                          1632  
00FF074E                          1633  LAB_RETURN
00FF074E  6616                    1634      BNE.s       RTS_007         * exit if following token to allow syntax error
00FF0750                          1635  
00FF0750  0C6F 008D 0004          1636      CMP.w       #TK_GOSUB,4(sp)     * compare token from stack with GOSUB
00FF0756  6600 FA42               1637      BNE     LAB_RGER            * do RETURN without GOSUB error if no matching
00FF075A                          1638                              * GOSUB
00FF075A                          1639  
00FF075A  5C4F                    1640      ADDQ.w  #6,sp               * dump calling address & token
00FF075C  275F 0852               1641      MOVE.l  (sp)+,Clinel(a3)        * pull current line
00FF0760  2A5F                    1642      MOVE.l  (sp)+,a5            * pull BASIC execute pointer
00FF0762                          1643                              * now do perform "DATA" statement as we could be
00FF0762                          1644                              * returning into the middle of an ON <var> GOSUB
00FF0762                          1645                              * n,m,p,q line (the return address used by the
00FF0762                          1646                              * DATA statement is the one pushed before the
00FF0762                          1647                              * GOSUB was executed!)
00FF0762                          1648  
00FF0762                          1649  
00FF0762                          1650  *************************************************************************************
00FF0762                          1651  *
00FF0762                          1652  * perform DATA
00FF0762                          1653  
00FF0762                          1654  LAB_DATA
00FF0762  6104                    1655      BSR.s       LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00FF0764                          1656                              * returns a0 as pointer to [:] or [EOL]
00FF0764  2A48                    1657      MOVEA.l a0,a5               * skip rest of statement
00FF0766                          1658  RTS_007
00FF0766  4E75                    1659      RTS
00FF0768                          1660  
00FF0768                          1661  
00FF0768                          1662  *************************************************************************************
00FF0768                          1663  *
00FF0768                          1664  * scan for next BASIC statement ([:] or [EOL])
00FF0768                          1665  * returns a0 as pointer to [:] or [EOL]
00FF0768                          1666  
00FF0768                          1667  LAB_SNBS
00FF0768  204D                    1668      MOVEA.l a5,a0               * copy BASIC execute pointer
00FF076A  7222                    1669      MOVEQ       #$22,d1         * set string quote character
00FF076C  743A                    1670      MOVEQ       #$3A,d2         * set look for character = ":"
00FF076E  6008                    1671      BRA.s       LAB_172D            * go do search
00FF0770                          1672  
00FF0770                          1673  LAB_172C
00FF0770  B400                    1674      CMP.b       d0,d2               * compare with ":"
00FF0772  6708                    1675      BEQ.s       RTS_007a            * exit if found
00FF0774                          1676  
00FF0774  B200                    1677      CMP.b       d0,d1               * compare with '"'
00FF0776  670C                    1678      BEQ.s       LAB_1725            * if found go search for [EOL]
00FF0778                          1679  
00FF0778                          1680  LAB_172D
00FF0778  1018                    1681      MOVE.b  (a0)+,d0            * get next byte
00FF077A  66F4                    1682      BNE.s       LAB_172C            * loop if not null [EOL]
00FF077C                          1683  
00FF077C                          1684  RTS_007a
00FF077C  5348                    1685      SUBQ.w  #1,a0               * correct pointer
00FF077E  4E75                    1686      RTS
00FF0780                          1687  
00FF0780                          1688  LAB_1723
00FF0780  B200                    1689      CMP.b       d0,d1               * compare with '"'
00FF0782  67F4                    1690      BEQ.s       LAB_172D            * if found go search for ":" or [EOL]
00FF0784                          1691  
00FF0784                          1692  LAB_1725
00FF0784  1018                    1693      MOVE.b  (a0)+,d0            * get next byte
00FF0786  66F8                    1694      BNE.s       LAB_1723            * loop if not null [EOL]
00FF0788                          1695  
00FF0788  60F2                    1696      BRA.s       RTS_007a            * correct pointer & return
00FF078A                          1697  
00FF078A                          1698  
00FF078A                          1699  *************************************************************************************
00FF078A                          1700  *
00FF078A                          1701  * perform IF
00FF078A                          1702  
00FF078A                          1703  LAB_IF
00FF078A  6100 04F0               1704      BSR     LAB_EVEX            * evaluate expression
00FF078E  6100 064E               1705      BSR     LAB_GBYT            * scan memory
00FF0792  B03C 00BA               1706      CMP.b       #TK_THEN,d0         * compare with THEN token
00FF0796  6714                    1707      BEQ.s       LAB_174B            * if it was THEN then continue
00FF0798                          1708  
00FF0798                          1709                              * wasn't IF .. THEN so must be IF .. GOTO
00FF0798  B03C 0089               1710      CMP.b       #TK_GOTO,d0         * compare with GOTO token
00FF079C  6600 FA00               1711      BNE     LAB_SNER            * if not GOTO token do syntax error/warm start
00FF07A0                          1712  
00FF07A0                          1713                              * was GOTO so check for GOTO <n>
00FF07A0  204D                    1714      MOVE.l  a5,a0               * save the execute pointer
00FF07A2  6100 0638               1715      BSR     LAB_IGBY            * scan memory, test for a numeric character
00FF07A6  2A48                    1716      MOVE.l  a0,a5               * restore the execute pointer
00FF07A8  6400 F9F4               1717      BCC     LAB_SNER            * if not numeric do syntax error/warm start
00FF07AC                          1718  
00FF07AC                          1719  LAB_174B
00FF07AC  102B 0994               1720      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00FF07B0  671E                    1721      BEQ.s       LAB_174E            * if result was zero go look for an ELSE
00FF07B2                          1722  
00FF07B2  6100 0628               1723      BSR     LAB_IGBY            * increment & scan memory
00FF07B6  6500 FF12               1724      BCS     LAB_GOTO            * if numeric do GOTO n
00FF07BA                          1725                              * a GOTO <n> will never return to the IF
00FF07BA                          1726                              * statement so there is no need to return
00FF07BA                          1727                              * to this code
00FF07BA                          1728  
00FF07BA  B03C 008E               1729      CMP.b       #TK_RETURN,d0       * compare with RETURN token
00FF07BE  6700 FE1E               1730      BEQ     LAB_1602            * if RETURN then interpret BASIC code from (a5)
00FF07C2                          1731                              * and don't return here
00FF07C2                          1732  
00FF07C2  6100 FE16               1733      BSR     LAB_15FF            * else interpret BASIC code from (a5)
00FF07C6                          1734  
00FF07C6                          1735  * the IF was executed and there may be a following ELSE so the code needs to return
00FF07C6                          1736  * here to check and ignore the ELSE if present
00FF07C6                          1737  
00FF07C6  1015                    1738      MOVE.b  (a5),d0         * get the next basic byte
00FF07C8  B03C 00B6               1739      CMP.b       #TK_ELSE,d0         * compare it with the token for ELSE
00FF07CC  6794                    1740      BEQ     LAB_DATA            * if ELSE ignore the following statement
00FF07CE                          1741  
00FF07CE                          1742  * there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
00FF07CE                          1743  * following ELSE will, correctly, cause a syntax error
00FF07CE                          1744  
00FF07CE  4E75                    1745      RTS                     * else return to interpreter inner loop
00FF07D0                          1746  
00FF07D0                          1747  * perform ELSE after IF
00FF07D0                          1748  
00FF07D0                          1749  LAB_174E
00FF07D0  101D                    1750      MOVE.b  (a5)+,d0            * faster increment past THEN
00FF07D2  76B6                    1751      MOVEQ       #TK_ELSE,d3         * set search for ELSE token
00FF07D4  788B                    1752      MOVEQ       #TK_IF,d4           * set search for IF token
00FF07D6  7A00                    1753      MOVEQ       #0,d5               * clear the nesting depth
00FF07D8                          1754  LAB_1750
00FF07D8  101D                    1755      MOVE.b  (a5)+,d0            * get next BASIC byte & increment ptr
00FF07DA  6720                    1756      BEQ.s       LAB_1754            * if EOL correct the pointer and return
00FF07DC                          1757  
00FF07DC  B004                    1758      CMP.b       d4,d0               * compare with "IF" token
00FF07DE  6604                    1759      BNE.s       LAB_1752            * skip if not nested IF
00FF07E0                          1760  
00FF07E0  5245                    1761      ADDQ.w  #1,d5               * else increment the nesting depth ..
00FF07E2  60F4                    1762      BRA.s       LAB_1750            * .. and continue looking
00FF07E4                          1763  
00FF07E4                          1764  LAB_1752
00FF07E4  B003                    1765      CMP.b       d3,d0               * compare with ELSE token
00FF07E6  66F0                    1766      BNE.s       LAB_1750            * if not ELSE continue looking
00FF07E8                          1767  
00FF07E8                          1768  LAB_1756
00FF07E8  51CD FFEE               1769      DBF     d5,LAB_1750         * loop if still nested
00FF07EC                          1770  
00FF07EC                          1771  * found the matching ELSE, now do <{n|statement}>
00FF07EC                          1772  
00FF07EC  6100 05F0               1773      BSR     LAB_GBYT            * scan memory
00FF07F0  6500 FED8               1774      BCS     LAB_GOTO            * if numeric do GOTO n
00FF07F4                          1775                              * code will return to the interpreter loop
00FF07F4                          1776                              * at the tail end of the GOTO <n>
00FF07F4                          1777  
00FF07F4  6000 FDE4               1778      BRA     LAB_15FF            * else interpret BASIC code from (a5)
00FF07F8                          1779                              * code will return to the interpreter loop
00FF07F8                          1780                              * at the tail end of the <statement>
00FF07F8                          1781  
00FF07F8                          1782  
00FF07F8                          1783  *************************************************************************************
00FF07F8                          1784  *
00FF07F8                          1785  * perform REM, skip (rest of) line
00FF07F8                          1786  
00FF07F8                          1787  LAB_REM
00FF07F8  4A1D                    1788      TST.b       (a5)+               * test byte & increment pointer
00FF07FA  66FC                    1789      BNE.s       LAB_REM         * loop if not EOL
00FF07FC                          1790  
00FF07FC                          1791  LAB_1754
00FF07FC  534D                    1792      SUBQ.w  #1,a5               * correct the execute pointer
00FF07FE  4E75                    1793      RTS
00FF0800                          1794  
00FF0800                          1795  
00FF0800                          1796  *************************************************************************************
00FF0800                          1797  *
00FF0800                          1798  * perform ON
00FF0800                          1799  
00FF0800                          1800  LAB_ON
00FF0800  6100 0F4C               1801      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00FF0804  1400                    1802      MOVE.b  d0,d2               * copy byte
00FF0806  6100 05D6               1803      BSR     LAB_GBYT            * restore BASIC byte
00FF080A  3F00                    1804      MOVE.w  d0,-(sp)            * push GOTO/GOSUB token
00FF080C  B03C 008D               1805      CMP.b       #TK_GOSUB,d0        * compare with GOSUB token
00FF0810  6708                    1806      BEQ.s       LAB_176C            * branch if GOSUB
00FF0812                          1807  
00FF0812  B03C 0089               1808      CMP.b       #TK_GOTO,d0         * compare with GOTO token
00FF0816  6600 F986               1809      BNE     LAB_SNER            * if not GOTO do syntax error, then warm start
00FF081A                          1810  
00FF081A                          1811  * next character was GOTO or GOSUB
00FF081A                          1812  
00FF081A                          1813  LAB_176C
00FF081A  5302                    1814      SUBQ.b  #1,d2               * decrement index (byte value)
00FF081C  6606                    1815      BNE.s       LAB_1773            * branch if not zero
00FF081E                          1816  
00FF081E  301F                    1817      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token
00FF0820  6000 FDBC               1818      BRA     LAB_1602            * go execute it
00FF0824                          1819  
00FF0824                          1820  LAB_1773
00FF0824  6100 05B6               1821      BSR     LAB_IGBY            * increment & scan memory
00FF0828  610A                    1822      BSR.s       LAB_GFPN            * get fixed-point number into temp integer & d1
00FF082A                          1823                              * (skip this n)
00FF082A  B03C 002C               1824      CMP.b       #$2C,d0         * compare next character with ","
00FF082E  67EA                    1825      BEQ.s       LAB_176C            * loop if ","
00FF0830                          1826  
00FF0830  301F                    1827      MOVE.w  (sp)+,d0            * pull GOTO/GOSUB token (run out of options)
00FF0832  4E75                    1828      RTS                     * and exit
00FF0834                          1829  
00FF0834                          1830  
00FF0834                          1831  *************************************************************************************
00FF0834                          1832  *
00FF0834                          1833  * get fixed-point number into temp integer & d1
00FF0834                          1834  * interpret number from (a5), leave (a5) pointing to byte after #
00FF0834                          1835  
00FF0834                          1836  LAB_GFPN
00FF0834  7200                    1837      MOVEQ       #$00,d1         * clear integer register
00FF0836  2001                    1838      MOVE.l  d1,d0               * clear d0
00FF0838  6100 05A4               1839      BSR     LAB_GBYT            * scan memory, Cb=1 if "0"-"9", & get byte
00FF083C  642E                    1840      BCC.s       LAB_1786            * return if carry clear, chr was not "0"-"9"
00FF083E                          1841  
00FF083E  2F02                    1842      MOVE.l  d2,-(sp)            * save d2
00FF0840                          1843  LAB_1785
00FF0840  2401                    1844      MOVE.l  d1,d2               * copy integer register
00FF0842  D281                    1845      ADD.l       d1,d1               * *2
00FF0844  6500 F958               1846      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00FF0848                          1847  
00FF0848  D281                    1848      ADD.l       d1,d1               * *4
00FF084A  6500 F952               1849      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00FF084E                          1850  
00FF084E  D282                    1851      ADD.l       d2,d1               * *1 + *4
00FF0850  6500 F94C               1852      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00FF0854                          1853  
00FF0854  D281                    1854      ADD.l       d1,d1               * *10
00FF0856  6500 F946               1855      BCS     LAB_SNER            * if overflow do syntax error, then warm start
00FF085A                          1856  
00FF085A  0400 0030               1857      SUB.b       #$30,d0         * subtract $30 from byte
00FF085E  D280                    1858      ADD.l       d0,d1               * add to integer register, the top 24 bits are
00FF0860                          1859                              * always clear
00FF0860  6900 F93C               1860      BVS     LAB_SNER            * if overflow do syntax error, then warm start
00FF0864                          1861                              * this makes the maximum line number 2147483647
00FF0864  6100 0576               1862      BSR     LAB_IGBY            * increment & scan memory
00FF0868  65D6                    1863      BCS.s       LAB_1785            * loop for next character if "0"-"9"
00FF086A                          1864  
00FF086A  241F                    1865      MOVE.l  (sp)+,d2            * restore d2
00FF086C                          1866  LAB_1786
00FF086C  2741 082A               1867      MOVE.l  d1,Itemp(a3)        * save Itemp
00FF0870  4E75                    1868      RTS
00FF0872                          1869  
00FF0872                          1870  
00FF0872                          1871  *************************************************************************************
00FF0872                          1872  *
00FF0872                          1873  * perform DEC
00FF0872                          1874  
00FF0872                          1875  LAB_DEC
00FF0872  3F3C 8180               1876      MOVE.w  #$8180,-(sp)        * set -1 sign/exponent
00FF0876  600A                    1877      BRA.s       LAB_17B7            * go do DEC
00FF0878                          1878  
00FF0878                          1879  
00FF0878                          1880  *************************************************************************************
00FF0878                          1881  *
00FF0878                          1882  * perform INC
00FF0878                          1883  
00FF0878                          1884  LAB_INC
00FF0878  3F3C 8100               1885      MOVE.w  #$8100,-(sp)        * set 1 sign/exponent
00FF087C  6004                    1886      BRA.s       LAB_17B7            * go do INC
00FF087E                          1887  
00FF087E                          1888                              * was "," so another INCR variable to do
00FF087E                          1889  LAB_17B8
00FF087E  6100 055C               1890      BSR     LAB_IGBY            * increment and scan memory
00FF0882                          1891  LAB_17B7
00FF0882  6100 0770               1892      BSR     LAB_GVAR            * get variable address in a0
00FF0886                          1893  
00FF0886                          1894  * if you want a non existant variable to return a null value then set the novar
00FF0886                          1895  * value at the top of this file to some non zero value
00FF0886                          1896  
00FF0886                 FALSE    1897   ifne   novar
00FF0886                          1898   endc
00FF0886                          1899  
00FF0886  4A2B 09B5               1900      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00FF088A                          1901                              * $00=float
00FF088A  6B00 F8E6               1902      BMI     LAB_TMER            * if string do "Type mismatch" error/warm start
00FF088E                          1903  
00FF088E  6636                    1904      BNE.s       LAB_INCI            * go do integer INC/DEC
00FF0890                          1905  
00FF0890  2748 0872               1906      MOVE.l  a0,Lvarpl(a3)       * save var address
00FF0894  6100 1534               1907      BSR     LAB_UFAC            * unpack memory (a0) into FAC1
00FF0898  277C 80000000 0998      1908      MOVE.l  #$80000000,FAC2_m(a3)   * set FAC2 mantissa for 1
00FF08A0  3017                    1909      MOVE.w  (sp),d0         * move exponent & sign to d0
00FF08A2  3740 099C               1910      MOVE.w  d0,FAC2_e(a3)       * move exponent & sign to FAC2
00FF08A6  176B 0995 099E          1911      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
00FF08AC  B12B 099E               1912      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
00FF08B0  6100 1234               1913      BSR     LAB_ADD         * add FAC2 to FAC1
00FF08B4  6100 1530               1914      BSR     LAB_PFAC            * pack FAC1 into variable (Lvarpl)
00FF08B8                          1915  LAB_INCT
00FF08B8  6100 0524               1916      BSR     LAB_GBYT            * scan memory
00FF08BC  0C00 002C               1917      CMPI.b  #$2C,d0         * compare with ","
00FF08C0  67BC                    1918      BEQ.s       LAB_17B8            * continue if "," (another variable to do)
00FF08C2                          1919  
00FF08C2  544F                    1920      ADDQ.w  #2,sp               * else dump sign & exponent
00FF08C4  4E75                    1921      RTS
00FF08C6                          1922  
00FF08C6                          1923  LAB_INCI
00FF08C6  4A2F 0001               1924      TST.b       1(sp)               * test sign
00FF08CA  6604                    1925      BNE.s       LAB_DECI            * branch if DEC
00FF08CC                          1926  
00FF08CC  5290                    1927      ADDQ.l  #1,(a0)         * increment variable
00FF08CE  60E8                    1928      BRA.s       LAB_INCT            * go scan for more
00FF08D0                          1929  
00FF08D0                          1930  LAB_DECI
00FF08D0  5390                    1931      SUBQ.l  #1,(a0)         * decrement variable
00FF08D2  60E4                    1932      BRA.s       LAB_INCT            * go scan for more
00FF08D4                          1933  
00FF08D4                          1934  
00FF08D4                          1935  *************************************************************************************
00FF08D4                          1936  *
00FF08D4                          1937  * perform LET
00FF08D4                          1938  
00FF08D4                          1939  LAB_LET
00FF08D4  6100 071A               1940      BSR     LAB_SVAR            * search for or create a variable
00FF08D8                          1941                              * return the variable address in a0
00FF08D8  2748 0872               1942      MOVE.l  a0,Lvarpl(a3)       * save variable address
00FF08DC  1F2B 09B5               1943      MOVE.b  Dtypef(a3),-(sp)        * push var data type, $80=string, $40=integer,
00FF08E0                          1944                              * $00=float
00FF08E0  70CA                    1945      MOVEQ       #TK_EQUAL-$100,d0       * get = token
00FF08E2  6100 04F0               1946      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
00FF08E6                          1947                              * start
00FF08E6  6100 0394               1948      BSR     LAB_EVEX            * evaluate expression
00FF08EA  102B 09B5               1949      MOVE.b  Dtypef(a3),d0       * copy expression data type
00FF08EE  175F 09B5               1950      MOVE.b  (sp)+,Dtypef(a3)        * pop variable data type
00FF08F2  E318                    1951      ROL.b       #1,d0               * set carry if expression type = string
00FF08F4  6100 0372               1952      BSR     LAB_CKTM            * type match check, set C for string
00FF08F8  6700 14EC               1953      BEQ     LAB_PFAC            * if number pack FAC1 into variable Lvarpl & RET
00FF08FC                          1954  
00FF08FC                          1955  * string LET
00FF08FC                          1956  
00FF08FC                          1957  LAB_17D5
00FF08FC  246B 0872               1958      MOVEA.l Lvarpl(a3),a2       * get pointer to variable
00FF0900                          1959  LAB_17D6
00FF0900  206B 0990               1960      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
00FF0904  2250                    1961      MOVEA.l (a0),a1         * get string pointer
00FF0906  B3EB 0846               1962      CMP.l       Sstorl(a3),a1       * compare string memory start with string
00FF090A                          1963                              * pointer
00FF090A  6516                    1964      BCS.s       LAB_1811            * if it was in program memory assign the value
00FF090C                          1965                              * and exit
00FF090C                          1966  
00FF090C  B1EB 0832               1967      CMPA.l  Sfncl(a3),a0        * compare functions start with descriptor
00FF0910                          1968                              * pointer
00FF0910  6510                    1969      BCS.s       LAB_1811            * branch if >= (string is on stack)
00FF0912                          1970  
00FF0912                          1971                              * string is variable$ make space and copy string
00FF0912                          1972  LAB_1810
00FF0912  7200                    1973      MOVEQ       #0,d1               * clear length
00FF0914  3228 0004               1974      MOVE.w  4(a0),d1            * get string length
00FF0918  2050                    1975      MOVEA.l (a0),a0         * get string pointer
00FF091A  6100 0B0C               1976      BSR     LAB_20C9            * copy string
00FF091E  206B 0990               1977      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer back
00FF0922                          1978                              * clean stack & assign value to string variable
00FF0922                          1979  LAB_1811
00FF0922  B9C8                    1980      CMPA.l  a0,a4               * is string on the descriptor stack
00FF0924  6602                    1981      BNE.s       LAB_1813            * skip pop if not
00FF0926                          1982  
00FF0926  5C4C                    1983      ADDQ.w  #$06,a4         * else update stack pointer
00FF0928                          1984  LAB_1813
00FF0928  24D8                    1985      MOVE.l  (a0)+,(a2)+         * save pointer to variable
00FF092A  3490                    1986      MOVE.w  (a0),(a2)           * save length to variable
00FF092C                          1987  RTS_008
00FF092C  4E75                    1988      RTS
00FF092E                          1989  
00FF092E                          1990  
00FF092E                          1991  *************************************************************************************
00FF092E                          1992  *
00FF092E                          1993  * perform GET
00FF092E                          1994  
00FF092E                          1995  LAB_GET
00FF092E  6100 06C0               1996      BSR     LAB_SVAR            * search for or create a variable
00FF0932                          1997                              * return the variable address in a0
00FF0932  2748 0872               1998      MOVE.l  a0,Lvarpl(a3)       * save variable address as GET variable
00FF0936  4A2B 09B5               1999      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00FF093A                          2000                              * $00=float
00FF093A  6B0C                    2001      BMI.s       LAB_GETS            * go get string character
00FF093C                          2002  
00FF093C                          2003                              * was numeric get
00FF093C  6100 2010               2004      BSR     INGET               * get input byte
00FF0940  6100 09C2               2005      BSR     LAB_1FD0            * convert d0 to unsigned byte in FAC1
00FF0944  6000 14A0               2006      BRA     LAB_PFAC            * pack FAC1 into variable (Lvarpl) & return
00FF0948                          2007  
00FF0948                          2008  LAB_GETS
00FF0948  7200                    2009      MOVEQ       #$00,d1         * assume no byte
00FF094A  2041                    2010      MOVE.l  d1,a0               * assume null string
00FF094C  6100 2000               2011      BSR     INGET               * get input byte
00FF0950  6408                    2012      BCC.s       LAB_NoSt            * branch if no byte received
00FF0952                          2013  
00FF0952  7201                    2014      MOVEQ       #$01,d1         * string is single byte
00FF0954  6100 0B04               2015      BSR     LAB_2115            * make string space d1 bytes long
00FF0958                          2016                              * return a0 = pointer, other registers unchanged
00FF0958                          2017  
00FF0958  1080                    2018      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
00FF095A                          2019  LAB_NoSt
00FF095A  6100 0AE4               2020      BSR     LAB_RTST            * push string on descriptor stack
00FF095E                          2021                              * a0 = pointer, d1 = length
00FF095E                          2022  
00FF095E  609C                    2023      BRA.s       LAB_17D5            * do string LET & return
00FF0960                          2024  
00FF0960                          2025  
00FF0960                          2026  *************************************************************************************
00FF0960                          2027  *
00FF0960                          2028  * PRINT
00FF0960                          2029  
00FF0960                          2030  LAB_1829
00FF0960  6100 00B4               2031      BSR     LAB_18C6            * print string from stack
00FF0964                          2032  LAB_182C
00FF0964  6100 0478               2033      BSR     LAB_GBYT            * scan memory
00FF0968                          2034  
00FF0968                          2035  * perform PRINT
00FF0968                          2036  
00FF0968                          2037  LAB_PRINT
00FF0968  674A                    2038      BEQ.s       LAB_CRLF            * if nothing following just print CR/LF
00FF096A                          2039  
00FF096A                          2040  LAB_1831
00FF096A  B03C 00B5               2041      CMP.b       #TK_TAB,d0          * compare with TAB( token
00FF096E  6764                    2042      BEQ.s       LAB_18A2            * go do TAB/SPC
00FF0970                          2043  
00FF0970  B03C 00B9               2044      CMP.b       #TK_SPC,d0          * compare with SPC( token
00FF0974  675E                    2045      BEQ.s       LAB_18A2            * go do TAB/SPC
00FF0976                          2046  
00FF0976  B03C 002C               2047      CMP.b       #',',d0         * compare with ","
00FF097A  6740                    2048      BEQ.s       LAB_188B            * go do move to next TAB mark
00FF097C                          2049  
00FF097C  B03C 003B               2050      CMP.b       #';',d0         * compare with ";"
00FF0980  6700 0086               2051      BEQ     LAB_18BD            * if ";" continue with PRINT processing
00FF0984                          2052  
00FF0984  6100 02F6               2053      BSR     LAB_EVEX            * evaluate expression
00FF0988  4A2B 09B5               2054      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00FF098C                          2055                              * $00=float
00FF098C  6BD2                    2056      BMI.s       LAB_1829            * branch if string
00FF098E                          2057  
00FF098E                          2058  ** replace the two lines above with this code
00FF098E                          2059  
00FF098E                          2060  **  MOVE.b  Dtypef(a3),d0       * get data type flag, $80=string, $00=numeric
00FF098E                          2061  **  BMI.s       LAB_1829            * branch if string
00FF098E                          2062  
00FF098E  6100 15D6               2063      BSR     LAB_2970            * convert FAC1 to string
00FF0992  6100 0A66               2064      BSR     LAB_20AE            * print " terminated string to FAC1 stack
00FF0996                          2065  
00FF0996                          2066  * don't check fit if terminal width byte is zero
00FF0996                          2067  
00FF0996  7000                    2068      MOVEQ       #0,d0               * clear d0
00FF0998  102B 09E6               2069      MOVE.b  TWidth(a3),d0       * get terminal width byte
00FF099C  670C                    2070      BEQ.s       LAB_185E            * skip check if zero
00FF099E                          2071  
00FF099E  902C 0007               2072      SUB.b       7(a4),d0            * subtract string length
00FF09A2  902B 09E5               2073      SUB.b       TPos(a3),d0         * subtract terminal position
00FF09A6  6402                    2074      BCC.s       LAB_185E            * branch if less than terminal width
00FF09A8                          2075  
00FF09A8  610A                    2076      BSR.s       LAB_CRLF            * else print CR/LF
00FF09AA                          2077  LAB_185E
00FF09AA  616A                    2078      BSR.s       LAB_18C6            * print string from stack
00FF09AC  60B6                    2079      BRA.s       LAB_182C            * always go continue processing line
00FF09AE                          2080  
00FF09AE                          2081  
00FF09AE                          2082  *************************************************************************************
00FF09AE                          2083  *
00FF09AE                          2084  * CR/LF return to BASIC from BASIC input handler
00FF09AE                          2085  * leaves a0 pointing to the buffer start
00FF09AE                          2086  
00FF09AE                          2087  LAB_1866
00FF09AE  11BC 0000 1000          2088      MOVE.b  #$00,(a0,d1.w)      * null terminate input
00FF09B4                          2089  
00FF09B4                          2090  * print CR/LF
00FF09B4                          2091  
00FF09B4                          2092  LAB_CRLF
00FF09B4  700D                    2093      MOVEQ       #$0D,d0         * load [CR]
00FF09B6  6174                    2094      BSR.s       LAB_PRNA            * go print the character
00FF09B8  700A                    2095      MOVEQ       #$0A,d0         * load [LF]
00FF09BA  6070                    2096      BRA.s       LAB_PRNA            * go print the character & return
00FF09BC                          2097  
00FF09BC                          2098  LAB_188B
00FF09BC  142B 09E5               2099      MOVE.b  TPos(a3),d2         * get terminal position
00FF09C0  B42B 09E7               2100      CMP.b       Iclim(a3),d2        * compare with input column limit
00FF09C4  6504                    2101      BCS.s       LAB_1898            * branch if less than Iclim
00FF09C6                          2102  
00FF09C6  61EC                    2103      BSR.s       LAB_CRLF            * else print CR/LF (next line)
00FF09C8  603E                    2104      BRA.s       LAB_18BD            * continue with PRINT processing
00FF09CA                          2105  
00FF09CA                          2106  LAB_1898
00FF09CA  942B 09E2               2107      SUB.b       TabSiz(a3),d2       * subtract TAB size
00FF09CE  64FA                    2108      BCC.s       LAB_1898            * loop if result was >= 0
00FF09D0                          2109  
00FF09D0  4402                    2110      NEG.b       d2              * twos complement it
00FF09D2  6022                    2111      BRA.s       LAB_18B7            * print d2 spaces
00FF09D4                          2112  
00FF09D4                          2113                              * do TAB/SPC
00FF09D4                          2114  LAB_18A2
00FF09D4  3F00                    2115      MOVE.w  d0,-(sp)            * save token
00FF09D6  6100 0D72               2116      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
00FF09DA  3400                    2117      MOVE.w  d0,d2               * copy byte
00FF09DC  6100 0400               2118      BSR     LAB_GBYT            * get basic byte back
00FF09E0  B03C 0029               2119      CMP.b       #$29,d0         * is next character ")"
00FF09E4  6600 F7B8               2120      BNE     LAB_SNER            * if not do syntax error, then warm start
00FF09E8                          2121  
00FF09E8  301F                    2122      MOVE.w  (sp)+,d0            * get token back
00FF09EA  B03C 00B5               2123      CMP.b       #TK_TAB,d0          * was it TAB ?
00FF09EE  6606                    2124      BNE.s       LAB_18B7            * branch if not (was SPC)
00FF09F0                          2125  
00FF09F0                          2126                              * calculate TAB offset
00FF09F0  942B 09E5               2127      SUB.b       TPos(a3),d2         * subtract terminal position
00FF09F4  6312                    2128      BLS.s       LAB_18BD            * branch if result was <= 0
00FF09F6                          2129                              * can't TAB backwards or already there
00FF09F6                          2130  
00FF09F6                          2131                              * print d2.b spaces
00FF09F6                          2132  LAB_18B7
00FF09F6  7000                    2133      MOVEQ       #0,d0               * clear longword
00FF09F8  5300                    2134      SUBQ.b  #1,d0               * make d0 = $FF
00FF09FA  C480                    2135      AND.l       d0,d2               * mask for byte only
00FF09FC  670A                    2136      BEQ.s       LAB_18BD            * branch if zero
00FF09FE                          2137  
00FF09FE  7020                    2138      MOVEQ       #$20,d0         * load " "
00FF0A00  5302                    2139      SUBQ.b  #1,d2               * adjust for DBF loop
00FF0A02                          2140  LAB_18B8
00FF0A02  6128                    2141      BSR.s       LAB_PRNA            * go print
00FF0A04  51CA FFFC               2142      DBF     d2,LAB_18B8         * decrement count and loop if not all done
00FF0A08                          2143  
00FF0A08                          2144                              * continue with PRINT processing
00FF0A08                          2145  LAB_18BD
00FF0A08  6100 03D2               2146      BSR     LAB_IGBY            * increment & scan memory
00FF0A0C  6600 FF5C               2147      BNE     LAB_1831            * if byte continue executing PRINT
00FF0A10                          2148  
00FF0A10  4E75                    2149      RTS                     * exit if nothing more to print
00FF0A12                          2150  
00FF0A12                          2151  
00FF0A12                          2152  *************************************************************************************
00FF0A12                          2153  *
00FF0A12                          2154  * print null terminated string from a0
00FF0A12                          2155  
00FF0A12                          2156  LAB_18C3
00FF0A12  6100 09E6               2157      BSR     LAB_20AE            * print terminated string to FAC1/stack
00FF0A16                          2158  
00FF0A16                          2159  * print string from stack
00FF0A16                          2160  
00FF0A16                          2161  LAB_18C6
00FF0A16  6100 0BD6               2162      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00FF0A1A                          2163                              * returns with d0 = length, a0 = pointer
00FF0A1A  670C                    2164      BEQ.s       RTS_009         * exit (RTS) if null string
00FF0A1C                          2165  
00FF0A1C  3200                    2166      MOVE.w  d0,d1               * copy length & set Z flag
00FF0A1E  5341                    2167      SUBQ.w  #1,d1               * -1 for BF loop
00FF0A20                          2168  LAB_18CD
00FF0A20  1018                    2169      MOVE.b  (a0)+,d0            * get byte from string
00FF0A22  6108                    2170      BSR.s       LAB_PRNA            * go print the character
00FF0A24  51C9 FFFA               2171      DBF     d1,LAB_18CD         * decrement count and loop if not done yet
00FF0A28                          2172  
00FF0A28                          2173  RTS_009
00FF0A28  4E75                    2174      RTS
00FF0A2A                          2175  
00FF0A2A                          2176  
00FF0A2A                          2177  *************************************************************************************
00FF0A2A                          2178  *
00FF0A2A                          2179  * print "?" character
00FF0A2A                          2180  
00FF0A2A                          2181  LAB_18E3
00FF0A2A  703F                    2182      MOVEQ       #$3F,d0         * load "?" character
00FF0A2C                          2183  
00FF0A2C                          2184  
00FF0A2C                          2185  *************************************************************************************
00FF0A2C                          2186  *
00FF0A2C                          2187  * print character in d0, includes the null handler and infinite line length code
00FF0A2C                          2188  * changes no registers
00FF0A2C                          2189  
00FF0A2C                          2190  LAB_PRNA
00FF0A2C  2F01                    2191      MOVE.l  d1,-(sp)            * save d1
00FF0A2E  B03C 0020               2192      CMP.b       #$20,d0         * compare with " "
00FF0A32  6528                    2193      BCS.s       LAB_18F9            * branch if less, non printing character
00FF0A34                          2194  
00FF0A34                          2195                              * don't check fit if terminal width byte is zero
00FF0A34  122B 09E6               2196      MOVE.b  TWidth(a3),d1       * get terminal width
00FF0A38  6610                    2197      BNE.s       LAB_18F0            * branch if not zero (not infinite length)
00FF0A3A                          2198  
00FF0A3A                          2199                              * is "infinite line" so check TAB position
00FF0A3A  122B 09E5               2200      MOVE.b  TPos(a3),d1         * get position
00FF0A3E  922B 09E2               2201      SUB.b       TabSiz(a3),d1       * subtract TAB size
00FF0A42  6614                    2202      BNE.s       LAB_18F7            * skip reset if different
00FF0A44                          2203  
00FF0A44  1741 09E5               2204      MOVE.b  d1,TPos(a3)         * else reset position
00FF0A48  600E                    2205      BRA.s       LAB_18F7            * go print character
00FF0A4A                          2206  
00FF0A4A                          2207  LAB_18F0
00FF0A4A  B22B 09E5               2208      CMP.b       TPos(a3),d1         * compare with terminal character position
00FF0A4E  6608                    2209      BNE.s       LAB_18F7            * branch if not at end of line
00FF0A50                          2210  
00FF0A50  2F00                    2211      MOVE.l  d0,-(sp)            * save d0
00FF0A52  6100 FF60               2212      BSR     LAB_CRLF            * else print CR/LF
00FF0A56  201F                    2213      MOVE.l  (sp)+,d0            * restore d0
00FF0A58                          2214  LAB_18F7
00FF0A58  522B 09E5               2215      ADDQ.b  #$01,TPos(a3)       * increment terminal position
00FF0A5C                          2216  LAB_18F9
00FF0A5C  4EAB 0812               2217      JSR     V_OUTP(a3)          * output byte via output vector
00FF0A60  B03C 000D               2218      CMP.b       #$0D,d0         * compare with [CR]
00FF0A64  6618                    2219      BNE.s       LAB_188A            * branch if not [CR]
00FF0A66                          2220  
00FF0A66                          2221                              * else print nullct nulls after the [CR]
00FF0A66  7200                    2222      MOVEQ       #$00,d1         * clear d1
00FF0A68  122B 09E4               2223      MOVE.b  Nullct(a3),d1       * get null count
00FF0A6C  670C                    2224      BEQ.s       LAB_1886            * branch if no nulls
00FF0A6E                          2225  
00FF0A6E  7000                    2226      MOVEQ       #$00,d0         * load [NULL]
00FF0A70                          2227  LAB_1880
00FF0A70  4EAB 0812               2228      JSR     V_OUTP(a3)          * go print the character
00FF0A74  51C9 FFFA               2229      DBF     d1,LAB_1880         * decrement count and loop if not all done
00FF0A78                          2230  
00FF0A78  700D                    2231      MOVEQ       #$0D,d0         * restore the character
00FF0A7A                          2232  LAB_1886
00FF0A7A  1741 09E5               2233      MOVE.b  d1,TPos(a3)         * clear terminal position
00FF0A7E                          2234  LAB_188A
00FF0A7E  221F                    2235      MOVE.l  (sp)+,d1            * restore d1
00FF0A80  4E75                    2236      RTS
00FF0A82                          2237  
00FF0A82                          2238  
00FF0A82                          2239  *************************************************************************************
00FF0A82                          2240  *
00FF0A82                          2241  * handle bad input data
00FF0A82                          2242  
00FF0A82                          2243  LAB_1904
00FF0A82  2A5F                    2244      MOVEA.l (sp)+,a5            * restore execute pointer
00FF0A84  4A2B 09E0               2245      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
00FF0A88  6A0A                    2246      BPL.s       LAB_1913            * branch if INPUT (go do redo)
00FF0A8A                          2247  
00FF0A8A  276B 085E 0852          2248      MOVE.l  Dlinel(a3),Clinel(a3)   * save DATA line as current line
00FF0A90  6000 F6E0               2249      BRA     LAB_TMER            * do type mismatch error, then warm start
00FF0A94                          2250  
00FF0A94                          2251                              * mode was INPUT
00FF0A94                          2252  LAB_1913
00FF0A94  41FA 2D28               2253      LEA     LAB_REDO(pc),a0     * point to redo message
00FF0A98  6100 FF78               2254      BSR     LAB_18C3            * print null terminated string from memory
00FF0A9C  2A6B 085A               2255      MOVEA.l Cpntrl(a3),a5       * save continue pointer as BASIC execute pointer
00FF0AA0  4E75                    2256      RTS
00FF0AA2                          2257  
00FF0AA2                          2258  
00FF0AA2                          2259  *************************************************************************************
00FF0AA2                          2260  *
00FF0AA2                          2261  * perform INPUT
00FF0AA2                          2262  
00FF0AA2                          2263  LAB_INPUT
00FF0AA2  6100 0868               2264      BSR     LAB_CKRN            * check not direct (back here if ok)
00FF0AA6  B03C 0022               2265      CMP.b       #'"',d0         * compare the next byte with open quote
00FF0AAA  660E                    2266      BNE.s       LAB_1934            * if no prompt string just go get the input
00FF0AAC                          2267  
00FF0AAC  6100 0306               2268      BSR     LAB_1BC1            * print "..." string
00FF0AB0  703B                    2269      MOVEQ       #';',d0         * set the search character to ";"
00FF0AB2  6100 0320               2270      BSR     LAB_SCCA            * scan for CHR$(d0), else do syntax error/warm
00FF0AB6                          2271                              * start
00FF0AB6  6100 FF5E               2272      BSR     LAB_18C6            * print string from Sutill/Sutilh
00FF0ABA                          2273                              * finished the prompt, now read the data
00FF0ABA                          2274  LAB_1934
00FF0ABA  6100 F80C               2275      BSR     LAB_INLN            * print "? " and get BASIC input
00FF0ABE                          2276                              * return a0 pointing to the buffer start
00FF0ABE  7000                    2277      MOVEQ       #0,d0               * flag INPUT
00FF0AC0                          2278  
00FF0AC0                          2279  * if you don't want a null response to INPUT to break the program then set the nobrk
00FF0AC0                          2280  * value at the top of this file to some non zero value
00FF0AC0                          2281  
00FF0AC0                 FALSE    2282   ifne   nobrk
00FF0AC0                          2283   endc
00FF0AC0                          2284  
00FF0AC0                          2285  * if you do want a null response to INPUT to break the program then leave the nobrk
00FF0AC0                          2286  * value at the top of this file set to zero
00FF0AC0                          2287  
00FF0AC0                 TRUE     2288   ifeq   nobrk
00FF0AC0                          2289  
00FF0AC0  4A10                    2290      TST.b       (a0)                * test first byte from buffer
00FF0AC2  660A                    2291      BNE.s       LAB_1953            * branch if not null input
00FF0AC4                          2292  
00FF0AC4  6000 FB5E               2293      BRA     LAB_1647            * else go do BREAK exit
00FF0AC8                          2294  
00FF0AC8                          2295   endc
00FF0AC8                          2296  
00FF0AC8                          2297  
00FF0AC8                          2298  *************************************************************************************
00FF0AC8                          2299  *
00FF0AC8                          2300  * perform READ
00FF0AC8                          2301  
00FF0AC8                          2302  LAB_READ
00FF0AC8  206B 0862               2303      MOVEA.l Dptrl(a3),a0        * get the DATA pointer
00FF0ACC  7098                    2304      MOVEQ       #$98-$100,d0        * flag READ
00FF0ACE                          2305  LAB_1953
00FF0ACE  1740 09E0               2306      MOVE.b  d0,Imode(a3)        * set input mode flag, $00=INPUT, $98=READ
00FF0AD2  2748 0866               2307      MOVE.l  a0,Rdptrl(a3)       * save READ pointer
00FF0AD6                          2308  
00FF0AD6                          2309                              * READ or INPUT the next variable from list
00FF0AD6                          2310  LAB_195B
00FF0AD6  6100 0518               2311      BSR     LAB_SVAR            * search for or create a variable
00FF0ADA                          2312                              * return the variable address in a0
00FF0ADA  2748 0872               2313      MOVE.l  a0,Lvarpl(a3)       * save variable address as LET variable
00FF0ADE  2F0D                    2314      MOVE.l  a5,-(sp)            * save BASIC execute pointer
00FF0AE0                          2315  LAB_1961
00FF0AE0  2A6B 0866               2316      MOVEA.l Rdptrl(a3),a5       * set READ pointer as BASIC execute pointer
00FF0AE4  6100 02F8               2317      BSR     LAB_GBYT            * scan memory
00FF0AE8  661E                    2318      BNE.s       LAB_1986            * if not null go get the value
00FF0AEA                          2319  
00FF0AEA                          2320                              * the pointer was to a null entry
00FF0AEA  4A2B 09E0               2321      TST.b       Imode(a3)           * test input mode flag, $00=INPUT, $98=READ
00FF0AEE  6B72                    2322      BMI.s       LAB_19DD            * branch if READ (go find the next statement)
00FF0AF0                          2323  
00FF0AF0                          2324                              * else the mode was INPUT so get more
00FF0AF0  6100 FF38               2325      BSR     LAB_18E3            * print a "?" character
00FF0AF4  6100 F7D2               2326      BSR     LAB_INLN            * print "? " and get BASIC input
00FF0AF8                          2327                              * return a0 pointing to the buffer start
00FF0AF8                          2328  
00FF0AF8                          2329  * if you don't want a null response to INPUT to break the program then set the nobrk
00FF0AF8                          2330  * value at the top of this file to some non zero value
00FF0AF8                          2331  
00FF0AF8                 FALSE    2332   ifne   nobrk
00FF0AF8                          2333   endc
00FF0AF8                          2334  
00FF0AF8                          2335  * if you do want a null response to INPUT to break the program then leave the nobrk
00FF0AF8                          2336  * value at the top of this file set to zero
00FF0AF8                          2337  
00FF0AF8                 TRUE     2338   ifeq   nobrk
00FF0AF8                          2339  
00FF0AF8  4A10                    2340      TST.b       (a0)                * test the first byte from the buffer
00FF0AFA  6604                    2341      BNE.s       LAB_1984            * if not null input go handle it
00FF0AFC                          2342  
00FF0AFC  6000 FB26               2343      BRA     LAB_1647            * else go do the BREAK exit
00FF0B00                          2344  
00FF0B00                          2345  LAB_1984
00FF0B00  2A48                    2346      MOVEA.l a0,a5               * set the execute pointer to the buffer
00FF0B02  534D                    2347      SUBQ.w  #1,a5               * decrement the execute pointer
00FF0B04                          2348  
00FF0B04                          2349   endc
00FF0B04                          2350  
00FF0B04                          2351  LAB_1985
00FF0B04  6100 02D6               2352      BSR     LAB_IGBY            * increment & scan memory
00FF0B08                          2353  LAB_1986
00FF0B08  4A2B 09B5               2354      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00FF0B0C                          2355                              * $00=float
00FF0B0C  6A20                    2356      BPL.s       LAB_19B0            * branch if numeric
00FF0B0E                          2357  
00FF0B0E                          2358                              * else get string
00FF0B0E  1400                    2359      MOVE.b  d0,d2               * save search character
00FF0B10  B03C 0022               2360      CMP.b       #$22,d0         * was it " ?
00FF0B14  6706                    2361      BEQ.s       LAB_1999            * branch if so
00FF0B16                          2362  
00FF0B16  743A                    2363      MOVEQ       #':',d2         * set new search character
00FF0B18  702C                    2364      MOVEQ       #',',d0         * other search character is ","
00FF0B1A  534D                    2365      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00FF0B1C                          2366  LAB_1999
00FF0B1C  524D                    2367      ADDQ.w  #1,a5               * increment BASIC execute pointer
00FF0B1E  1600                    2368      MOVE.b  d0,d3               * set second search character
00FF0B20  204D                    2369      MOVEA.l a5,a0               * BASIC execute pointer is source
00FF0B22                          2370  
00FF0B22  6100 08DA               2371      BSR     LAB_20B4            * print d2/d3 terminated string to FAC1 stack
00FF0B26                          2372                              * d2 = Srchc, d3 = Asrch, a0 is source
00FF0B26  2A4A                    2373      MOVEA.l a2,a5               * copy end of string to BASIC execute pointer
00FF0B28  6100 FDD2               2374      BSR     LAB_17D5            * go do string LET
00FF0B2C  6010                    2375      BRA.s       LAB_19B6            * go check string terminator
00FF0B2E                          2376  
00FF0B2E                          2377                              * get numeric INPUT
00FF0B2E                          2378  LAB_19B0
00FF0B2E  1F2B 09B5               2379      MOVE.b  Dtypef(a3),-(sp)        * save variable data type
00FF0B32  6100 1FC4               2380      BSR     LAB_2887            * get FAC1 from string
00FF0B36  175F 09B5               2381      MOVE.b  (sp)+,Dtypef(a3)        * restore variable data type
00FF0B3A  6100 12AA               2382      BSR     LAB_PFAC            * pack FAC1 into (Lvarpl)
00FF0B3E                          2383  LAB_19B6
00FF0B3E  6100 029E               2384      BSR     LAB_GBYT            * scan memory
00FF0B42  670A                    2385      BEQ.s       LAB_19C2            * branch if null (last entry)
00FF0B44                          2386  
00FF0B44  B03C 002C               2387      CMP.b       #',',d0         * else compare with ","
00FF0B48  6600 FF38               2388      BNE     LAB_1904            * if not "," go handle bad input data
00FF0B4C                          2389  
00FF0B4C  524D                    2390      ADDQ.w  #1,a5               * else was "," so point to next chr
00FF0B4E                          2391                              * got good input data
00FF0B4E                          2392  LAB_19C2
00FF0B4E  274D 0866               2393      MOVE.l  a5,Rdptrl(a3)       * save the read pointer for now
00FF0B52  2A5F                    2394      MOVEA.l (sp)+,a5            * restore the execute pointer
00FF0B54  6100 0288               2395      BSR     LAB_GBYT            * scan the memory
00FF0B58  6736                    2396      BEQ.s       LAB_1A03            * if null go do extra ignored message
00FF0B5A                          2397  
00FF0B5A  487A FF7A               2398      PEA     LAB_195B(pc)        * set return address
00FF0B5E  6000 0272               2399      BRA     LAB_1C01            * scan for "," else do syntax error/warm start
00FF0B62                          2400                              * then go INPUT next variable from list
00FF0B62                          2401  
00FF0B62                          2402                              * find next DATA statement or do "Out of Data"
00FF0B62                          2403                              * error
00FF0B62                          2404  LAB_19DD
00FF0B62  6100 FC04               2405      BSR     LAB_SNBS            * scan for next BASIC statement ([:] or [EOL])
00FF0B66                          2406                              * returns a0 as pointer to [:] or [EOL]
00FF0B66  2A48                    2407      MOVEA.l a0,a5               * add index, now = pointer to [EOL]/[EOS]
00FF0B68  524D                    2408      ADDQ.w  #1,a5               * pointer to next character
00FF0B6A  B03C 003A               2409      CMP.b       #':',d0         * was it statement end?
00FF0B6E  6712                    2410      BEQ.s       LAB_19F6            * branch if [:]
00FF0B70                          2411  
00FF0B70                          2412                              * was [EOL] so find next line
00FF0B70                          2413  
00FF0B70  320D                    2414      MOVE.w  a5,d1               * past pad byte(s)
00FF0B72  C27C 0001               2415      AND.w       #1,d1               * mask odd bit
00FF0B76  DAC1                    2416      ADD.w       d1,a5               * add pointer
00FF0B78  241D                    2417      MOVE.l  (a5)+,d2            * get next line pointer
00FF0B7A  6700 F61A               2418      BEQ     LAB_ODER            * branch if end of program
00FF0B7E                          2419  
00FF0B7E  275D 085E               2420      MOVE.l  (a5)+,Dlinel(a3)        * save current DATA line
00FF0B82                          2421  LAB_19F6
00FF0B82  6100 025A               2422      BSR     LAB_GBYT            * scan memory
00FF0B86  B03C 0083               2423      CMP.b       #TK_DATA,d0         * compare with "DATA" token
00FF0B8A  6700 FF78               2424      BEQ     LAB_1985            * was "DATA" so go do next READ
00FF0B8E                          2425  
00FF0B8E  60D2                    2426      BRA.s       LAB_19DD            * go find next statement if not "DATA"
00FF0B90                          2427  
00FF0B90                          2428  * end of INPUT/READ routine
00FF0B90                          2429  
00FF0B90                          2430  LAB_1A03
00FF0B90  206B 0866               2431      MOVEA.l Rdptrl(a3),a0       * get temp READ pointer
00FF0B94  4A2B 09E0               2432      TST.b       Imode(a3)           * get input mode flag, $00=INPUT, $98=READ
00FF0B98  6A06                    2433      BPL.s       LAB_1A0E            * branch if INPUT
00FF0B9A                          2434  
00FF0B9A  2748 0862               2435      MOVE.l  a0,Dptrl(a3)        * else save temp READ pointer as DATA pointer
00FF0B9E  4E75                    2436      RTS
00FF0BA0                          2437  
00FF0BA0                          2438                              * we were getting INPUT
00FF0BA0                          2439  LAB_1A0E
00FF0BA0  4A10                    2440      TST.b       (a0)                * test next byte
00FF0BA2  6602                    2441      BNE.s       LAB_1A1B            * error if not end of INPUT
00FF0BA4                          2442  
00FF0BA4  4E75                    2443      RTS
00FF0BA6                          2444                              * user typed too much
00FF0BA6                          2445  LAB_1A1B
00FF0BA6  41FA 2C06               2446      LEA     LAB_IMSG(pc),a0     * point to extra ignored message
00FF0BAA  6000 FE66               2447      BRA     LAB_18C3            * print null terminated string from memory & RTS
00FF0BAE                          2448  
00FF0BAE                          2449  
00FF0BAE                          2450  *************************************************************************************
00FF0BAE                          2451  *
00FF0BAE                          2452  * perform NEXT
00FF0BAE                          2453  
00FF0BAE                          2454  LAB_NEXT
00FF0BAE  6610                    2455      BNE.s       LAB_1A46            * branch if NEXT var
00FF0BB0                          2456  
00FF0BB0  584F                    2457      ADDQ.w  #4,sp               * back past return address
00FF0BB2  0C57 0081               2458      CMP.w       #TK_FOR,(sp)        * is FOR token on stack?
00FF0BB6  6600 F5EA               2459      BNE     LAB_NFER            * if not do NEXT without FOR err/warm start
00FF0BBA                          2460  
00FF0BBA  206F 0002               2461      MOVEA.l 2(sp),a0            * get stacked FOR variable pointer
00FF0BBE  601C                    2462      BRA.s       LAB_11BD            * branch always (no variable to search for)
00FF0BC0                          2463  
00FF0BC0                          2464  * NEXT var
00FF0BC0                          2465  
00FF0BC0                          2466  LAB_1A46
00FF0BC0  6100 0432               2467      BSR     LAB_GVAR            * get variable address in a0
00FF0BC4  584F                    2468      ADDQ.w  #4,sp               * back past return address
00FF0BC6  303C 0081               2469      MOVE.w  #TK_FOR,d0          * set for FOR token
00FF0BCA  721C                    2470      MOVEQ       #$1C,d1         * set for FOR use size
00FF0BCC  6002                    2471      BRA.s       LAB_11A6            * enter loop for next variable search
00FF0BCE                          2472  
00FF0BCE                          2473  LAB_11A5
00FF0BCE  DFC1                    2474      ADDA.l  d1,sp               * add FOR stack use size
00FF0BD0                          2475  LAB_11A6
00FF0BD0  B057                    2476      CMP.w       (sp),d0         * is FOR token on stack?
00FF0BD2  6600 F5CE               2477      BNE     LAB_NFER            * if not found do NEXT without FOR error and
00FF0BD6                          2478                              * warm start
00FF0BD6                          2479  
00FF0BD6                          2480                              * was FOR token
00FF0BD6  B1EF 0002               2481      CMPA.l  2(sp),a0            * compare var pointer with stacked var pointer
00FF0BDA  66F2                    2482      BNE.s       LAB_11A5            * loop if no match found
00FF0BDC                          2483  
00FF0BDC                          2484  LAB_11BD
00FF0BDC  376F 0006 099C          2485      MOVE.w  6(sp),FAC2_e(a3)        * get STEP value exponent and sign
00FF0BE2  276F 0008 0998          2486      MOVE.l  8(sp),FAC2_m(a3)        * get STEP value mantissa
00FF0BE8                          2487  
00FF0BE8  176F 0012 09B5          2488      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type
00FF0BEE  6100 021C               2489      BSR     LAB_1C19            * check type and unpack (a0)
00FF0BF2                          2490  
00FF0BF2  176B 099D 099E          2491      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
00FF0BF8  102B 0995               2492      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00FF0BFC  B12B 099E               2493      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00FF0C00                          2494  
00FF0C00  2748 0872               2495      MOVE.l  a0,Lvarpl(a3)       * save variable pointer
00FF0C04  6100 0EE0               2496      BSR     LAB_ADD         * add STEP value to FOR variable
00FF0C08  176F 0012 09B5          2497      MOVE.b  18(sp),Dtypef(a3)       * restore FOR variable data type (again)
00FF0C0E  6100 11D6               2498      BSR     LAB_PFAC            * pack FAC1 into FOR variable (Lvarpl)
00FF0C12                          2499  
00FF0C12  376F 000C 099C          2500      MOVE.w  12(sp),FAC2_e(a3)       * get TO value exponent and sign
00FF0C18  276F 000E 0998          2501      MOVE.l  14(sp),FAC2_m(a3)       * get TO value mantissa
00FF0C1E                          2502  
00FF0C1E  176B 099D 099E          2503      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * save FAC2 sign as sign compare
00FF0C24  102B 0995               2504      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00FF0C28  B12B 099E               2505      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00FF0C2C                          2506  
00FF0C2C  6100 1262               2507      BSR     LAB_27FA            * compare FAC1 with FAC2 (TO value)
00FF0C30                          2508                              * returns d0=+1 if FAC1 > FAC2
00FF0C30                          2509                              * returns d0= 0 if FAC1 = FAC2
00FF0C30                          2510                              * returns d0=-1 if FAC1 < FAC2
00FF0C30                          2511  
00FF0C30  322F 0006               2512      MOVE.w  6(sp),d1            * get STEP value exponent and sign
00FF0C34  B141                    2513      EOR.w       d0,d1               * EOR compare result with STEP exponent and sign
00FF0C36                          2514  
00FF0C36  4A00                    2515      TST.b       d0              * test for =
00FF0C38  6704                    2516      BEQ.s       LAB_1A90            * branch if = (loop INcomplete)
00FF0C3A                          2517  
00FF0C3A  4A01                    2518      TST.b       d1              * test result
00FF0C3C  6A0E                    2519      BPL.s       LAB_1A9B            * branch if > (loop complete)
00FF0C3E                          2520  
00FF0C3E                          2521                              * loop back and do it all again
00FF0C3E                          2522  LAB_1A90
00FF0C3E  276F 0014 0852          2523      MOVE.l  20(sp),Clinel(a3)       * reset current line
00FF0C44  2A6F 0018               2524      MOVE.l  24(sp),a5           * reset BASIC execute pointer
00FF0C48  6000 F976               2525      BRA     LAB_15C2            * go do interpreter inner loop
00FF0C4C                          2526  
00FF0C4C                          2527                              * loop complete so carry on
00FF0C4C                          2528  LAB_1A9B
00FF0C4C  DEFC 001C               2529      ADDA.w  #28,sp          * add 28 to dump FOR structure
00FF0C50  6100 018C               2530      BSR     LAB_GBYT            * scan memory
00FF0C54  B03C 002C               2531      CMP.b       #$2C,d0         * compare with ","
00FF0C58  6600 F966               2532      BNE     LAB_15C2            * if not "," go do interpreter inner loop
00FF0C5C                          2533  
00FF0C5C                          2534                              * was "," so another NEXT variable to do
00FF0C5C  6100 017E               2535      BSR     LAB_IGBY            * else increment & scan memory
00FF0C60  6100 FF5E               2536      BSR     LAB_1A46            * do NEXT (var)
00FF0C64                          2537  
00FF0C64                          2538  
00FF0C64                          2539  *************************************************************************************
00FF0C64                          2540  *
00FF0C64                          2541  * evaluate expression & check is numeric, else do type mismatch
00FF0C64                          2542  
00FF0C64                          2543  LAB_EVNM
00FF0C64  6116                    2544      BSR.s       LAB_EVEX            * evaluate expression
00FF0C66                          2545  
00FF0C66                          2546  
00FF0C66                          2547  *************************************************************************************
00FF0C66                          2548  *
00FF0C66                          2549  * check if source is numeric, else do type mismatch
00FF0C66                          2550  
00FF0C66                          2551  LAB_CTNM
00FF0C66  B040                    2552      CMP.w       d0,d0               * required type is numeric so clear carry
00FF0C68                          2553  
00FF0C68                          2554  
00FF0C68                          2555  *************************************************************************************
00FF0C68                          2556  *
00FF0C68                          2557  * type match check, set C for string, clear C for numeric
00FF0C68                          2558  
00FF0C68                          2559  LAB_CKTM
00FF0C68  082B 0007 09B5          2560      BTST.b  #7,Dtypef(a3)       * test data type flag, don't change carry
00FF0C6E  6606                    2561      BNE.s       LAB_1ABA            * branch if data type is string
00FF0C70                          2562  
00FF0C70                          2563                              * else data type was numeric
00FF0C70  6500 F500               2564      BCS     LAB_TMER            * if required type is string do type mismatch
00FF0C74                          2565                              * error
00FF0C74                          2566  
00FF0C74  4E75                    2567      RTS
00FF0C76                          2568                              * data type was string, now check required type
00FF0C76                          2569  LAB_1ABA
00FF0C76  6400 F4FA               2570      BCC     LAB_TMER            * if required type is numeric do type mismatch
00FF0C7A                          2571                              * error
00FF0C7A  4E75                    2572      RTS
00FF0C7C                          2573  
00FF0C7C                          2574  
00FF0C7C                          2575  *************************************************************************************
00FF0C7C                          2576  *
00FF0C7C                          2577  * this routine evaluates any type of expression. first it pushes an end marker so
00FF0C7C                          2578  * it knows when the expression has been evaluated, this is a precedence value of zero.
00FF0C7C                          2579  * next the first value is evaluated, this can be an in line value, either numeric or
00FF0C7C                          2580  * string, a variable or array element of any type, a function or even an expression
00FF0C7C                          2581  * in parenthesis. this value is kept in FAC_1
00FF0C7C                          2582  * after the value is evaluated a test is made on the next BASIC program byte, if it
00FF0C7C                          2583  * is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
00FF0C7C                          2584  * in the comparison evaluation flag. this test loops until no more comparrison operators
00FF0C7C                          2585  * are found or more than one of any type is found. in the last case an error is generated
00FF0C7C                          2586  
00FF0C7C                          2587  * evaluate expression
00FF0C7C                          2588  
00FF0C7C                          2589  LAB_EVEX
00FF0C7C  534D                    2590      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00FF0C7E                          2591  LAB_EVEZ
00FF0C7E  7200                    2592      MOVEQ       #0,d1               * clear precedence word
00FF0C80  1741 09B5               2593      MOVE.b  d1,Dtypef(a3)       * clear the data type, $80=string, $40=integer,
00FF0C84                          2594                              * $00=float
00FF0C84  601C                    2595      BRA.s       LAB_1ACD            * enter loop
00FF0C86                          2596  
00FF0C86                          2597  * get vector, set up operator then continue evaluation
00FF0C86                          2598  
00FF0C86                          2599  LAB_1B43                        *
00FF0C86  41FA 250A               2600      LEA     LAB_OPPT(pc),a0     * point to operator vector table
00FF0C8A  3030 1002               2601      MOVE.w  2(a0,d1.w),d0       * get vector offset
00FF0C8E  4870 0000               2602      PEA     (a0,d0.w)           * push vector
00FF0C92                          2603  
00FF0C92  2F2B 0990               2604      MOVE.l  FAC1_m(a3),-(sp)        * push FAC1 mantissa
00FF0C96  3F2B 0994               2605      MOVE.w  FAC1_e(a3),-(sp)        * push sign and exponent
00FF0C9A  1F2B 09E3               2606      MOVE.b  comp_f(a3),-(sp)        * push comparison evaluation flag
00FF0C9E                          2607  
00FF0C9E  3230 1000               2608      MOVE.w  (a0,d1.w),d1        * get precedence value
00FF0CA2                          2609  LAB_1ACD
00FF0CA2  3F01                    2610      MOVE.w  d1,-(sp)            * push precedence value
00FF0CA4  6100 00E4               2611      BSR     LAB_GVAL            * get value from line
00FF0CA8  177C 0000 09E3          2612      MOVE.b  #$00,comp_f(a3)     * clear compare function flag
00FF0CAE                          2613  LAB_1ADB
00FF0CAE  6100 012E               2614      BSR     LAB_GBYT            * scan memory
00FF0CB2                          2615  LAB_1ADE
00FF0CB2  0400 00C9               2616      SUB.b       #TK_GT,d0           * subtract token for > (lowest compare function)
00FF0CB6  652A                    2617      BCS.s       LAB_1AFA            * branch if < TK_GT
00FF0CB8                          2618  
00FF0CB8  B03C 0003               2619      CMP.b       #$03,d0         * compare with ">" to "<" tokens
00FF0CBC  650A                    2620      BCS.s       LAB_1AE0            * branch if <= TK_SGN (is compare function)
00FF0CBE                          2621  
00FF0CBE  4A2B 09E3               2622      TST.b       comp_f(a3)          * test compare function flag
00FF0CC2  6660                    2623      BNE.s       LAB_1B2A            * branch if compare function
00FF0CC4                          2624  
00FF0CC4  6000 0086               2625      BRA     LAB_1B78            * go do functions
00FF0CC8                          2626  
00FF0CC8                          2627                              * was token for > = or < (d0 = 0, 1 or 2)
00FF0CC8                          2628  LAB_1AE0
00FF0CC8  7201                    2629      MOVEQ       #1,d1               * set to 0000 0001
00FF0CCA  E121                    2630      ASL.b       d0,d1               * 1 if >, 2 if =, 4 if <
00FF0CCC  102B 09E3               2631      MOVE.b  comp_f(a3),d0       * copy old compare function flag
00FF0CD0  B32B 09E3               2632      EOR.b       d1,comp_f(a3)       * EOR in this compare function bit
00FF0CD4  B02B 09E3               2633      CMP.b       comp_f(a3),d0       * compare old with new compare function flag
00FF0CD8  6400 F4C4               2634      BCC     LAB_SNER            * if new <= old comp_f do syntax error and warm
00FF0CDC                          2635                              * start, there was more than one <, = or >
00FF0CDC  6100 00FE               2636      BSR     LAB_IGBY            * increment & scan memory
00FF0CE0  60D0                    2637      BRA.s       LAB_1ADE            * go do next character
00FF0CE2                          2638  
00FF0CE2                          2639                              * token is < ">" or > "<" tokens
00FF0CE2                          2640  LAB_1AFA
00FF0CE2  4A2B 09E3               2641      TST.b       comp_f(a3)          * test compare function flag
00FF0CE6  663C                    2642      BNE.s       LAB_1B2A            * branch if compare function
00FF0CE8                          2643  
00FF0CE8                          2644                              * was < TK_GT so is operator or lower
00FF0CE8  0600 000A               2645      ADD.b   #(TK_GT-TK_PLUS),d0     * add # of operators (+ - * / ^ AND OR EOR)
00FF0CEC  645E                    2646      BCC.s       LAB_1B78            * branch if < + operator
00FF0CEE                          2647  
00FF0CEE  6608                    2648      BNE.s       LAB_1B0B            * branch if not + token
00FF0CF0                          2649  
00FF0CF0  4A2B 09B5               2650      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00FF0CF4                          2651                              * $00=float
00FF0CF4  6B00 0884               2652      BMI     LAB_224D            * type is string & token was +
00FF0CF8                          2653  
00FF0CF8                          2654  LAB_1B0B
00FF0CF8  7200                    2655      MOVEQ       #0,d1               * clear longword
00FF0CFA  D000                    2656      ADD.b       d0,d0               * *2
00FF0CFC  D000                    2657      ADD.b       d0,d0               * *4
00FF0CFE  1200                    2658      MOVE.b  d0,d1               * copy to index
00FF0D00                          2659  LAB_1B13
00FF0D00  301F                    2660      MOVE.w  (sp)+,d0            * pull previous precedence
00FF0D02  41FA 248E               2661      LEA     LAB_OPPT(pc),a0     * set pointer to operator table
00FF0D06  B070 1000               2662      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
00FF0D0A  6446                    2663      BCC.s       LAB_1B7D            * branch if previous precedence (d0) >=
00FF0D0C                          2664  
00FF0D0C  6100 FF58               2665      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00FF0D10                          2666  LAB_1B1C
00FF0D10  3F00                    2667      MOVE.w  d0,-(sp)            * save precedence
00FF0D12                          2668  LAB_1B1D
00FF0D12  6100 FF72               2669      BSR     LAB_1B43            * get vector, set-up operator and continue
00FF0D16                          2670                              * evaluation
00FF0D16  301F                    2671      MOVE.w  (sp)+,d0            * restore precedence
00FF0D18  222B 09D8               2672      MOVE.l  prstk(a3),d1        * get stacked function pointer
00FF0D1C  6A22                    2673      BPL.s       LAB_1B3C            * branch if stacked values
00FF0D1E                          2674  
00FF0D1E  3000                    2675      MOVE.w  d0,d0               * copy precedence (set flags)
00FF0D20  672E                    2676      BEQ.s       LAB_1B7B            * exit if done
00FF0D22                          2677  
00FF0D22  603C                    2678      BRA.s       LAB_1B86            * else pop FAC2 & return (do function)
00FF0D24                          2679  
00FF0D24                          2680                              * was compare function (< = >)
00FF0D24                          2681  LAB_1B2A
00FF0D24  102B 09B5               2682      MOVE.b  Dtypef(a3),d0       * get data type flag
00FF0D28  122B 09E3               2683      MOVE.b  comp_f(a3),d1       * get compare function flag
00FF0D2C  D000                    2684      ADD.b       d0,d0               * string bit flag into X bit
00FF0D2E  D301                    2685      ADDX.b  d1,d1               * shift compare function flag
00FF0D30                          2686  
00FF0D30  177C 0000 09B5          2687      MOVE.b  #0,Dtypef(a3)       * clear data type flag, $00=float
00FF0D36  1741 09E3               2688      MOVE.b  d1,comp_f(a3)       * save new compare function flag
00FF0D3A  534D                    2689      SUBQ.w  #1,a5               * decrement BASIC execute pointer
00FF0D3C  7230                    2690      MOVEQ       #(TK_LT-TK_PLUS)*4,d1   * set offset to last operator entry
00FF0D3E  60C0                    2691      BRA.s       LAB_1B13            * branch always
00FF0D40                          2692  
00FF0D40                          2693  LAB_1B3C
00FF0D40  41FA 2450               2694      LEA     LAB_OPPT(pc),a0     * point to function vector table
00FF0D44  B070 1000               2695      CMP.w       (a0,d1.w),d0        * compare with this opperator precedence
00FF0D48  6416                    2696      BCC.s       LAB_1B86            * branch if d0 >=, pop FAC2 & return
00FF0D4A                          2697  
00FF0D4A  60C4                    2698      BRA.s       LAB_1B1C            * branch always
00FF0D4C                          2699  
00FF0D4C                          2700  * do functions
00FF0D4C                          2701  
00FF0D4C                          2702  LAB_1B78
00FF0D4C  72FF                    2703      MOVEQ       #-1,d1          * flag all done
00FF0D4E  301F                    2704      MOVE.w  (sp)+,d0            * pull precedence word
00FF0D50                          2705  LAB_1B7B
00FF0D50  6732                    2706      BEQ.s       LAB_1B9D            * exit if done
00FF0D52                          2707  
00FF0D52                          2708  LAB_1B7D
00FF0D52  B07C 0064               2709      CMP.w       #$64,d0         * compare previous precedence with $64
00FF0D56  6704                    2710      BEQ.s       LAB_1B84            * branch if was $64 (< function can be string)
00FF0D58                          2711  
00FF0D58  6100 FF0C               2712      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00FF0D5C                          2713  LAB_1B84
00FF0D5C  2741 09D8               2714      MOVE.l  d1,prstk(a3)        * save current operator index
00FF0D60                          2715  
00FF0D60                          2716                              * pop FAC2 & return
00FF0D60                          2717  LAB_1B86
00FF0D60  101F                    2718      MOVE.b  (sp)+,d0            * pop comparison evaluation flag
00FF0D62  1200                    2719      MOVE.b  d0,d1               * copy comparison evaluation flag
00FF0D64  E208                    2720      LSR.b       #1,d0               * shift out comparison evaluation lowest bit
00FF0D66  1740 09E1               2721      MOVE.b  d0,Cflag(a3)        * save comparison evaluation flag
00FF0D6A  375F 099C               2722      MOVE.w  (sp)+,FAC2_e(a3)        * pop exponent and sign
00FF0D6E  275F 0998               2723      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
00FF0D72  176B 099D 099E          2724      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign
00FF0D78  102B 0995               2725      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00FF0D7C  B12B 099E               2726      EOR.b       d0,FAC_sc(a3)       * EOR FAC1 sign and set sign compare
00FF0D80                          2727  
00FF0D80  E209                    2728      LSR.b       #1,d1               * type bit into X and C
00FF0D82  4E75                    2729      RTS
00FF0D84                          2730  
00FF0D84                          2731  LAB_1B9D
00FF0D84  102B 0994               2732      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00FF0D88  4E75                    2733      RTS
00FF0D8A                          2734  
00FF0D8A                          2735  
00FF0D8A                          2736  *************************************************************************************
00FF0D8A                          2737  *
00FF0D8A                          2738  * get a value from the BASIC line
00FF0D8A                          2739  
00FF0D8A                          2740  LAB_GVAL
00FF0D8A  6150                    2741      BSR.s       LAB_IGBY            * increment & scan memory
00FF0D8C  6500 1D6A               2742      BCS     LAB_2887            * if numeric get FAC1 from string & return
00FF0D90                          2743  
00FF0D90  4A00                    2744      TST.b       d0              * test byte
00FF0D92  6B00 008E               2745      BMI     LAB_1BD0            * if -ve go test token values
00FF0D96                          2746  
00FF0D96                          2747                              * else it is either a string, number, variable
00FF0D96                          2748                              * or (<expr>)
00FF0D96  B03C 0024               2749      CMP.b       #'$',d0         * compare with "$"
00FF0D9A  6700 1D5C               2750      BEQ     LAB_2887            * if "$" get hex number from string & return
00FF0D9E                          2751  
00FF0D9E  B03C 0025               2752      CMP.b       #'%',d0         * else compare with "%"
00FF0DA2  6700 1D54               2753      BEQ     LAB_2887            * if "%" get binary number from string & return
00FF0DA6                          2754  
00FF0DA6  B03C 002E               2755      CMP.b       #$2E,d0         * compare with "."
00FF0DAA  6700 1D4C               2756      BEQ     LAB_2887            * if so get FAC1 from string and return
00FF0DAE                          2757                              * (e.g. .123)
00FF0DAE                          2758  
00FF0DAE                          2759                              * wasn't a number so ...
00FF0DAE  B03C 0022               2760      CMP.b       #$22,d0         * compare with "
00FF0DB2  660C                    2761      BNE.s       LAB_1BF3            * if not open quote then it must be a variable
00FF0DB4                          2762                              * or an open bracket
00FF0DB4                          2763  
00FF0DB4                          2764                              * was open quote so get the enclosed string
00FF0DB4                          2765  
00FF0DB4                          2766  * print "..." string to string stack
00FF0DB4                          2767  
00FF0DB4                          2768  LAB_1BC1
00FF0DB4  101D                    2769      MOVE.b  (a5)+,d0            * increment BASIC execute pointer (past ")
00FF0DB6                          2770                              * fastest/shortest method
00FF0DB6  204D                    2771      MOVEA.l a5,a0               * copy BASIC execute pointer (string start)
00FF0DB8  6100 0640               2772      BSR     LAB_20AE            * print " terminated string to stack
00FF0DBC  2A4A                    2773      MOVEA.l a2,a5               * restore BASIC execute pointer from temp
00FF0DBE  4E75                    2774      RTS
00FF0DC0                          2775  
00FF0DC0                          2776  * get value from line .. continued
00FF0DC0                          2777                              * wasn't any sort of number so ...
00FF0DC0                          2778  LAB_1BF3
00FF0DC0  B03C 0028               2779      CMP.b       #'(',d0         * compare with "("
00FF0DC4  6642                    2780      BNE.s       LAB_1C18            * if not "(" get (var) and return value in FAC1
00FF0DC6                          2781                              * and $ flag
00FF0DC6                          2782  
00FF0DC6                          2783  
00FF0DC6                          2784  *************************************************************************************
00FF0DC6                          2785  *
00FF0DC6                          2786  * evaluate expression within parentheses
00FF0DC6                          2787  
00FF0DC6                          2788  LAB_1BF7
00FF0DC6  6100 FEB6               2789      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00FF0DCA                          2790  
00FF0DCA                          2791  
00FF0DCA                          2792  *************************************************************************************
00FF0DCA                          2793  *
00FF0DCA                          2794  * all the 'scan for' routines return the character after the sought character
00FF0DCA                          2795  
00FF0DCA                          2796  * scan for ")", else do syntax error, then warm start
00FF0DCA                          2797  
00FF0DCA                          2798  LAB_1BFB
00FF0DCA  7029                    2799      MOVEQ       #$29,d0         * load d0 with ")"
00FF0DCC  6006                    2800      BRA.s       LAB_SCCA
00FF0DCE                          2801  
00FF0DCE                          2802  
00FF0DCE                          2803  *************************************************************************************
00FF0DCE                          2804  *
00FF0DCE                          2805  * scan for "," and get byte, else do Syntax error then warm start
00FF0DCE                          2806  
00FF0DCE                          2807  LAB_SCGB
00FF0DCE  487A 097E               2808      PEA     LAB_GTBY(pc)        * return address is to get byte parameter
00FF0DD2                          2809  
00FF0DD2                          2810  
00FF0DD2                          2811  *************************************************************************************
00FF0DD2                          2812  *
00FF0DD2                          2813  * scan for ",", else do syntax error, then warm start
00FF0DD2                          2814  
00FF0DD2                          2815  LAB_1C01
00FF0DD2  702C                    2816      MOVEQ       #$2C,d0         * load d0 with ","
00FF0DD4                          2817  
00FF0DD4                          2818  
00FF0DD4                          2819  *************************************************************************************
00FF0DD4                          2820  *
00FF0DD4                          2821  * scan for CHR$(d0) , else do syntax error, then warm start
00FF0DD4                          2822  
00FF0DD4                          2823  LAB_SCCA
00FF0DD4  B01D                    2824      CMP.b       (a5)+,d0            * check next byte is = d0
00FF0DD6  6706                    2825      BEQ.s       LAB_GBYT            * if so go get next
00FF0DD8                          2826  
00FF0DD8  6000 F3C4               2827      BRA     LAB_SNER            * else do syntax error/warm start
00FF0DDC                          2828  
00FF0DDC                          2829  
00FF0DDC                          2830  *************************************************************************************
00FF0DDC                          2831  *
00FF0DDC                          2832  * BASIC increment and scan memory routine
00FF0DDC                          2833  
00FF0DDC                          2834  LAB_IGBY
00FF0DDC  101D                    2835      MOVE.b  (a5)+,d0            * get byte & increment pointer
00FF0DDE                          2836  
00FF0DDE                          2837  * scan memory routine, exit with Cb = 1 if numeric character
00FF0DDE                          2838  * also skips any spaces encountered
00FF0DDE                          2839  
00FF0DDE                          2840  LAB_GBYT
00FF0DDE  1015                    2841      MOVE.b  (a5),d0         * get byte
00FF0DE0                          2842  
00FF0DE0  B03C 0020               2843      CMP.b       #$20,d0         * compare with " "
00FF0DE4  67F6                    2844      BEQ.s       LAB_IGBY            * if " " go do next
00FF0DE6                          2845  
00FF0DE6                          2846  * test current BASIC byte, exit with Cb = 1 if numeric character
00FF0DE6                          2847  
00FF0DE6  B03C 00B6               2848      CMP.b       #TK_ELSE,d0         * compare with the token for ELSE
00FF0DEA  640C                    2849      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
00FF0DEC                          2850  
00FF0DEC  B03C 003A               2851      CMP.b       #$3A,d0         * compare with ":"
00FF0DF0  6406                    2852      BCC.s       RTS_001         * exit if >= (not numeric, carry clear)
00FF0DF2                          2853  
00FF0DF2  7CD0                    2854      MOVEQ       #$D0,d6         * set -"0"
00FF0DF4  D006                    2855      ADD.b       d6,d0               * add -"0"
00FF0DF6  9006                    2856      SUB.b       d6,d0               * subtract -"0"
00FF0DF8                          2857  RTS_001                     * carry set if byte = "0"-"9"
00FF0DF8  4E75                    2858      RTS
00FF0DFA                          2859  
00FF0DFA                          2860  
00FF0DFA                          2861  *************************************************************************************
00FF0DFA                          2862  *
00FF0DFA                          2863  * set-up for - operator
00FF0DFA                          2864  
00FF0DFA                          2865  LAB_1C11
00FF0DFA  6100 FE6A               2866      BSR     LAB_CTNM            * check if source is numeric, else type mismatch
00FF0DFE  7228                    2867      MOVEQ   #(TK_GT-TK_PLUS)*4,d1       * set offset from base to - operator
00FF0E00                          2868  LAB_1C13
00FF0E00  4FEF 0004               2869      LEA     4(sp),sp            * dump GVAL return address
00FF0E04  6000 FF0C               2870      BRA     LAB_1B1D            * continue evaluating expression
00FF0E08                          2871  
00FF0E08                          2872  
00FF0E08                          2873  *************************************************************************************
00FF0E08                          2874  *
00FF0E08                          2875  * variable name set-up
00FF0E08                          2876  * get (var), return value in FAC_1 & data type flag
00FF0E08                          2877  
00FF0E08                          2878  LAB_1C18
00FF0E08  6100 01EA               2879      BSR     LAB_GVAR            * get variable address in a0
00FF0E0C                          2880  
00FF0E0C                          2881  * if you want a non existant variable to return a null value then set the novar
00FF0E0C                          2882  * value at the top of this file to some non zero value
00FF0E0C                          2883  
00FF0E0C                 FALSE    2884   ifne   novar
00FF0E0C                          2885   endc
00FF0E0C                          2886  
00FF0E0C                          2887  * return existing variable value
00FF0E0C                          2888  
00FF0E0C                          2889  LAB_1C19
00FF0E0C  4A2B 09B5               2890      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00FF0E10                          2891                              * $00=float
00FF0E10  6700 0FB8               2892      BEQ     LAB_UFAC            * if float unpack memory (a0) into FAC1 and
00FF0E14                          2893                              * return
00FF0E14                          2894  
00FF0E14  6A06                    2895      BPL.s       LAB_1C1A            * if integer unpack memory (a0) into FAC1
00FF0E16                          2896                              * and return
00FF0E16                          2897  
00FF0E16  2748 0990               2898      MOVE.l  a0,FAC1_m(a3)       * else save descriptor pointer in FAC1
00FF0E1A  4E75                    2899      RTS
00FF0E1C                          2900  
00FF0E1C                          2901  LAB_1C1A
00FF0E1C  2010                    2902      MOVE.l  (a0),d0         * get integer value
00FF0E1E  6000 04C4               2903      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00FF0E22                          2904  
00FF0E22                          2905  
00FF0E22                          2906  *************************************************************************************
00FF0E22                          2907  *
00FF0E22                          2908  * get value from line .. continued
00FF0E22                          2909  * do tokens
00FF0E22                          2910  
00FF0E22                          2911  LAB_1BD0
00FF0E22  B03C 00C0               2912      CMP.b       #TK_MINUS,d0        * compare with token for -
00FF0E26  67D2                    2913      BEQ.s       LAB_1C11            * branch if - token (do set-up for - operator)
00FF0E28                          2914  
00FF0E28                          2915                              * wasn't -123 so ...
00FF0E28  B03C 00BF               2916      CMP.b       #TK_PLUS,d0         * compare with token for +
00FF0E2C  6700 FF5C               2917      BEQ     LAB_GVAL            * branch if + token (+n = n so ignore leading +)
00FF0E30                          2918  
00FF0E30  B03C 00BB               2919      CMP.b       #TK_NOT,d0          * compare with token for NOT
00FF0E34  6606                    2920      BNE.s       LAB_1BE7            * branch if not token for NOT
00FF0E36                          2921  
00FF0E36                          2922                              * was NOT token
00FF0E36  323C 002C               2923      MOVE.w  #(TK_EQUAL-TK_PLUS)*4,d1    * offset to NOT function
00FF0E3A  60C4                    2924      BRA.s       LAB_1C13            * do set-up for function then execute
00FF0E3C                          2925  
00FF0E3C                          2926                              * wasn't +, - or NOT so ...
00FF0E3C                          2927  LAB_1BE7
00FF0E3C  B03C 00B8               2928      CMP.b       #TK_FN,d0           * compare with token for FN
00FF0E40  6700 051C               2929      BEQ     LAB_201E            * if FN go evaluate FNx
00FF0E44                          2930  
00FF0E44  B03C 00A6               2931      CMP.b       #TK_POINT,d0        * compare with token for POINT
00FF0E48  6700 0A9E               2932      BEQ     LAB_FPOINT          * if POINT go evaluate POINT(x,y)
00FF0E4C                          2933  
00FF0E4C                          2934                              * wasn't +, -, NOT or FN so ...
00FF0E4C  0400 00CC               2935      SUB.b       #TK_SGN,d0          * compare with token for SGN & normalise
00FF0E50  6500 F34C               2936      BCS     LAB_SNER            * if < SGN token then do syntax error
00FF0E54                          2937  
00FF0E54                          2938  * get value from line .. continued
00FF0E54                          2939  * only functions left so set up function references
00FF0E54                          2940  
00FF0E54                          2941  * new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
00FF0E54                          2942  * to process function calls. now the function vector is computed and pushed on the stack
00FF0E54                          2943  * and the preprocess offset is read. if the preprocess offset is non zero then the vector
00FF0E54                          2944  * is calculated and the routine called, if not this routine just does RTS. whichever
00FF0E54                          2945  * happens the RTS at the end of this routine, or the preprocess routine calls, the
00FF0E54                          2946  * function code
00FF0E54                          2947  
00FF0E54                          2948  * this also removes some less than elegant code that was used to bypass type checking
00FF0E54                          2949  * for functions that returned strings
00FF0E54                          2950  
00FF0E54  C07C 007F               2951      AND.w       #$7F,d0         * mask byte
00FF0E58  D040                    2952      ADD.w       d0,d0               * *2 (2 bytes per function offset)
00FF0E5A                          2953  
00FF0E5A  41FA 22E6               2954      LEA     LAB_FTBL(pc),a0     * pointer to functions vector table
00FF0E5E  3230 0000               2955      MOVE.w  (a0,d0.w),d1        * get function vector offset
00FF0E62  4870 1000               2956      PEA     (a0,d1.w)           * push function vector
00FF0E66                          2957  
00FF0E66  41FA 228A               2958      LEA     LAB_FTPP(pc),a0     * pointer to functions preprocess vector table
00FF0E6A  3030 0000               2959      MOVE.w  (a0,d0.w),d0        * get function preprocess vector offset
00FF0E6E  6712                    2960      BEQ.s       LAB_1C2A            * no preprocess vector so go do function
00FF0E70                          2961  
00FF0E70  41F0 0000               2962      LEA     (a0,d0.w),a0        * get function preprocess vector
00FF0E74  4ED0                    2963      JMP     (a0)                * go do preprocess routine then function
00FF0E76                          2964  
00FF0E76                          2965  
00FF0E76                          2966  *************************************************************************************
00FF0E76                          2967  *
00FF0E76                          2968  * process string expression in parenthesis
00FF0E76                          2969  
00FF0E76                          2970  LAB_PPFS
00FF0E76  6100 FF4E               2971      BSR     LAB_1BF7            * process expression in parenthesis
00FF0E7A  4A2B 09B5               2972      TST.b       Dtypef(a3)          * test data type
00FF0E7E  6A00 F2F2               2973      BPL     LAB_TMER            * if numeric do Type missmatch Error/warm start
00FF0E82                          2974  
00FF0E82                          2975  LAB_1C2A
00FF0E82  4E75                    2976      RTS                     * else do function
00FF0E84                          2977  
00FF0E84                          2978  
00FF0E84                          2979  *************************************************************************************
00FF0E84                          2980  *
00FF0E84                          2981  * process numeric expression in parenthesis
00FF0E84                          2982  
00FF0E84                          2983  LAB_PPFN
00FF0E84  6100 FF40               2984      BSR     LAB_1BF7            * process expression in parenthesis
00FF0E88  4A2B 09B5               2985      TST.b       Dtypef(a3)          * test data type
00FF0E8C  6B00 F2E4               2986      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00FF0E90                          2987  
00FF0E90  4E75                    2988      RTS                     * else do function
00FF0E92                          2989  
00FF0E92                          2990  
00FF0E92                          2991  *************************************************************************************
00FF0E92                          2992  *
00FF0E92                          2993  * set numeric data type and increment BASIC execute pointer
00FF0E92                          2994  
00FF0E92                          2995  LAB_PPBI
00FF0E92  177C 0000 09B5          2996      MOVE.b  #$00,Dtypef(a3)     * clear data type flag, $00=float
00FF0E98  101D                    2997      MOVE.b  (a5)+,d0            * get next BASIC byte
00FF0E9A  4E75                    2998      RTS                     * do function
00FF0E9C                          2999  
00FF0E9C                          3000  
00FF0E9C                          3001  *************************************************************************************
00FF0E9C                          3002  *
00FF0E9C                          3003  * process string for LEFT$, RIGHT$ or MID$
00FF0E9C                          3004  
00FF0E9C                          3005  LAB_LRMS
00FF0E9C  6100 FDE0               3006      BSR     LAB_EVEZ            * evaluate (should be string) expression
00FF0EA0  4A2B 09B5               3007      TST.b       Dtypef(a3)          * test data type flag
00FF0EA4  6A00 F2CC               3008      BPL     LAB_TMER            * if type is not string do type mismatch error
00FF0EA8                          3009  
00FF0EA8  141D                    3010      MOVE.b  (a5)+,d2            * get BASIC byte
00FF0EAA  B43C 002C               3011      CMP.b       #',',d2         * compare with comma
00FF0EAE  6600 F2EE               3012      BNE     LAB_SNER            * if not "," go do syntax Error/warm start
00FF0EB2                          3013  
00FF0EB2  2F2B 0990               3014      MOVE.l  FAC1_m(a3),-(sp)        * save descriptor pointer
00FF0EB6  6100 08AA               3015      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
00FF0EBA  205F                    3016      MOVEA.l (sp)+,a0            * restore descriptor pointer
00FF0EBC  4E75                    3017      RTS                     * do function
00FF0EBE                          3018  
00FF0EBE                          3019  
00FF0EBE                          3020  *************************************************************************************
00FF0EBE                          3021  *
00FF0EBE                          3022  * process numeric expression(s) for BIN$ or HEX$
00FF0EBE                          3023  
00FF0EBE                          3024  LAB_BHSS
00FF0EBE  6100 FDBE               3025      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00FF0EC2  4A2B 09B5               3026      TST.b       Dtypef(a3)          * test data type
00FF0EC6  6B00 F2AA               3027      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00FF0ECA                          3028  
00FF0ECA  6100 0FF0               3029      BSR     LAB_2831            * convert FAC1 floating to fixed
00FF0ECE                          3030                              * result in d0 and Itemp
00FF0ECE  7200                    3031      MOVEQ       #0,d1               * set default to no leading "0"s
00FF0ED0  141D                    3032      MOVE.b  (a5)+,d2            * get BASIC byte
00FF0ED2  B43C 002C               3033      CMP.b       #',',d2         * compare with comma
00FF0ED6  660C                    3034      BNE.s       LAB_BHCB            * if not "," go check close bracket
00FF0ED8                          3035  
00FF0ED8  2F00                    3036      MOVE.l  d0,-(sp)            * copy number to stack
00FF0EDA  6100 0872               3037      BSR     LAB_GTBY            * get byte value
00FF0EDE  2200                    3038      MOVE.l  d0,d1               * copy leading 0s #
00FF0EE0  201F                    3039      MOVE.l  (sp)+,d0            * restore number from stack
00FF0EE2  141D                    3040      MOVE.b  (a5)+,d2            * get BASIC byte
00FF0EE4                          3041  LAB_BHCB
00FF0EE4  B43C 0029               3042      CMP.b       #')',d2         * compare with close bracket
00FF0EE8  6600 F2B4               3043      BNE     LAB_SNER            * if not ")" do Syntax Error/warm start
00FF0EEC                          3044  
00FF0EEC  4E75                    3045      RTS                     * go do function
00FF0EEE                          3046  
00FF0EEE                          3047  
00FF0EEE                          3048  *************************************************************************************
00FF0EEE                          3049  *
00FF0EEE                          3050  * perform EOR
00FF0EEE                          3051  
00FF0EEE                          3052  LAB_EOR
00FF0EEE  6116                    3053      BSR.s       GetFirst            * get two values for OR, AND or EOR
00FF0EF0                          3054                              * first in d0, and Itemp, second in d2
00FF0EF0  B580                    3055      EOR.l       d2,d0               * EOR values
00FF0EF2  6000 03F0               3056      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00FF0EF6                          3057  
00FF0EF6                          3058  
00FF0EF6                          3059  *************************************************************************************
00FF0EF6                          3060  *
00FF0EF6                          3061  * perform OR
00FF0EF6                          3062  
00FF0EF6                          3063  LAB_OR
00FF0EF6  610E                    3064      BSR.s       GetFirst            * get two values for OR, AND or EOR
00FF0EF8                          3065                              * first in d0, and Itemp, second in d2
00FF0EF8  8082                    3066      OR.l        d2,d0               * do OR
00FF0EFA  6000 03E8               3067      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00FF0EFE                          3068  
00FF0EFE                          3069  
00FF0EFE                          3070  *************************************************************************************
00FF0EFE                          3071  *
00FF0EFE                          3072  * perform AND
00FF0EFE                          3073  
00FF0EFE                          3074  LAB_AND
00FF0EFE  6106                    3075      BSR.s       GetFirst            * get two values for OR, AND or EOR
00FF0F00                          3076                              * first in d0, and Itemp, second in d2
00FF0F00  C082                    3077      AND.l       d2,d0               * do AND
00FF0F02  6000 03E0               3078      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00FF0F06                          3079  
00FF0F06                          3080  
00FF0F06                          3081  *************************************************************************************
00FF0F06                          3082  *
00FF0F06                          3083  * get two values for OR, AND, EOR
00FF0F06                          3084  * first in d0, second in d2
00FF0F06                          3085  
00FF0F06                          3086  GetFirst
00FF0F06  6100 0228               3087      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00FF0F0A                          3088                              * result in d0 and Itemp
00FF0F0A  2400                    3089      MOVE.l  d0,d2               * copy second value
00FF0F0C  6100 0F16               3090      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
00FF0F10                          3091                              * expression
00FF0F10  6000 021E               3092      BRA     LAB_EVIR            * evaluate integer expression (no sign check)
00FF0F14                          3093                              * result in d0 and Itemp & return
00FF0F14                          3094  
00FF0F14                          3095  
00FF0F14                          3096  *************************************************************************************
00FF0F14                          3097  *
00FF0F14                          3098  * perform NOT
00FF0F14                          3099  
00FF0F14                          3100  LAB_EQUAL
00FF0F14  6100 021A               3101      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00FF0F18                          3102                              * result in d0 and Itemp
00FF0F18  4680                    3103      NOT.l       d0              * bitwise invert
00FF0F1A  6000 03C8               3104      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00FF0F1E                          3105  
00FF0F1E                          3106  
00FF0F1E                          3107  *************************************************************************************
00FF0F1E                          3108  *
00FF0F1E                          3109  * perform comparisons
00FF0F1E                          3110  * do < compare
00FF0F1E                          3111  
00FF0F1E                          3112  LAB_LTHAN
00FF0F1E  6100 FD48               3113      BSR     LAB_CKTM            * type match check, set C for string
00FF0F22  6506                    3114      BCS.s       LAB_1CAE            * branch if string
00FF0F24                          3115  
00FF0F24                          3116                              * do numeric < compare
00FF0F24  6100 0F6A               3117      BSR     LAB_27FA            * compare FAC1 with FAC2
00FF0F28                          3118                              * returns d0=+1 if FAC1 > FAC2
00FF0F28                          3119                              * returns d0= 0 if FAC1 = FAC2
00FF0F28                          3120                              * returns d0=-1 if FAC1 < FAC2
00FF0F28  6042                    3121      BRA.s       LAB_1CF2            * process result
00FF0F2A                          3122  
00FF0F2A                          3123                              * do string < compare
00FF0F2A                          3124  LAB_1CAE
00FF0F2A  177C 0000 09B5          3125      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
00FF0F30                          3126                              * $00=float
00FF0F30  6100 06BC               3127      BSR     LAB_22B6            * pop string off descriptor stack, or from top
00FF0F34                          3128                              * of string space returns d0 = length,
00FF0F34                          3129                              * a0 = pointer
00FF0F34  2248                    3130      MOVEA.l a0,a1               * copy string 2 pointer
00FF0F36  2200                    3131      MOVE.l  d0,d1               * copy string 2 length
00FF0F38  206B 0998               3132      MOVEA.l FAC2_m(a3),a0       * get string 1 descriptor pointer
00FF0F3C  6100 06B4               3133      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00FF0F40                          3134                              * d0 = length, a0 = pointer
00FF0F40  2400                    3135      MOVE.l  d0,d2               * copy length
00FF0F42  6604                    3136      BNE.s       LAB_1CB5            * branch if not null string
00FF0F44                          3137  
00FF0F44  4A81                    3138      TST.l       d1              * test if string 2 is null also
00FF0F46  6724                    3139      BEQ.s       LAB_1CF2            * if so do string 1 = string 2
00FF0F48                          3140  
00FF0F48                          3141  LAB_1CB5
00FF0F48  9481                    3142      SUB.l       d1,d2               * subtract string 2 length
00FF0F4A  670C                    3143      BEQ.s       LAB_1CD5            * branch if strings = length
00FF0F4C                          3144  
00FF0F4C  6504                    3145      BCS.s       LAB_1CD4            * branch if string 1 < string 2
00FF0F4E                          3146  
00FF0F4E  70FF                    3147      MOVEQ       #-1,d0          * set for string 1 > string 2
00FF0F50  6008                    3148      BRA.s       LAB_1CD6            * go do character comapare
00FF0F52                          3149  
00FF0F52                          3150  LAB_1CD4
00FF0F52  2200                    3151      MOVE.l  d0,d1               * string 1 length is compare length
00FF0F54  7001                    3152      MOVEQ       #1,d0               * and set for string 1 < string 2
00FF0F56  6002                    3153      BRA.s       LAB_1CD6            * go do character comapare
00FF0F58                          3154  
00FF0F58                          3155  LAB_1CD5
00FF0F58  2002                    3156      MOVE.l  d2,d0               * set for string 1 = string 2
00FF0F5A                          3157  LAB_1CD6
00FF0F5A  5381                    3158      SUBQ.l  #1,d1               * adjust length for DBcc loop
00FF0F5C                          3159  
00FF0F5C                          3160                              * d1 is length to compare, d0 is <=> for length
00FF0F5C                          3161                              * a0 is string 1 pointer, a1 is string 2 pointer
00FF0F5C                          3162  LAB_1CE6
00FF0F5C  B308                    3163      CMPM.b  (a0)+,(a1)+         * compare string bytes (1 with 2)
00FF0F5E  56C9 FFFC               3164      DBNE        d1,LAB_1CE6         * loop if same and not end yet
00FF0F62                          3165  
00FF0F62  6708                    3166      BEQ.s       LAB_1CF2            * if = to here, then go use length compare
00FF0F64                          3167  
00FF0F64  6404                    3168      BCC.s       LAB_1CDB            * else branch if string 1 > string 2
00FF0F66                          3169  
00FF0F66  70FF                    3170      MOVEQ       #-1,d0          * else set for string 1 < string 2
00FF0F68  6002                    3171      BRA.s       LAB_1CF2            * go set result
00FF0F6A                          3172  
00FF0F6A                          3173  LAB_1CDB
00FF0F6A  7001                    3174      MOVEQ       #1,d0               * and set for string 1 > string 2
00FF0F6C                          3175  
00FF0F6C                          3176  LAB_1CF2
00FF0F6C  5200                    3177      ADDQ.b  #1,d0               * make result 0, 1 or 2
00FF0F6E  1200                    3178      MOVE.b  d0,d1               * copy to d1
00FF0F70  7001                    3179      MOVEQ       #1,d0               * set d0 longword
00FF0F72  E338                    3180      ROL.b       d1,d0               * make 1, 2 or 4 (result = flag bit)
00FF0F74  C02B 09E1               3181      AND.b       Cflag(a3),d0        * AND with comparison evaluation flag
00FF0F78  6700 0EFE               3182      BEQ     LAB_27DB            * exit if not a wanted result (i.e. false)
00FF0F7C                          3183  
00FF0F7C  70FF                    3184      MOVEQ       #-1,d0          * else set -1 (true)
00FF0F7E  6000 0EF8               3185      BRA     LAB_27DB            * save d0 as integer & return
00FF0F82                          3186  
00FF0F82                          3187  
00FF0F82                          3188  LAB_1CFE
00FF0F82  6100 FE4E               3189      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00FF0F86                          3190  
00FF0F86                          3191  
00FF0F86                          3192  *************************************************************************************
00FF0F86                          3193  *
00FF0F86                          3194  * perform DIM
00FF0F86                          3195  
00FF0F86                          3196  LAB_DIM
00FF0F86  72FF                    3197      MOVEQ       #-1,d1          * set "DIM" flag
00FF0F88  6170                    3198      BSR.s       LAB_1D10            * search for variable
00FF0F8A  6100 FE52               3199      BSR     LAB_GBYT            * scan memory
00FF0F8E  66F2                    3200      BNE.s       LAB_1CFE            * loop and scan for "," if not null
00FF0F90                          3201  
00FF0F90  4E75                    3202      RTS
00FF0F92                          3203  
00FF0F92                          3204  
00FF0F92                          3205  *************************************************************************************
00FF0F92                          3206  *
00FF0F92                          3207  * perform << (left shift)
00FF0F92                          3208  
00FF0F92                          3209  LAB_LSHIFT
00FF0F92  612E                    3210      BSR.s       GetPair         * get an integer and byte pair
00FF0F94                          3211                              * byte is in d2, integer is in d0 and Itemp
00FF0F94  6708                    3212      BEQ.s       NoShift         * branch if byte zero
00FF0F96                          3213  
00FF0F96  B43C 0020               3214      CMP.b       #$20,d2         * compare bit count with 32d
00FF0F9A  6420                    3215      BCC.s       TooBig          * branch if >=
00FF0F9C                          3216  
00FF0F9C  E5A0                    3217      ASL.l       d2,d0               * shift longword
00FF0F9E                          3218  NoShift
00FF0F9E  6000 0344               3219      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00FF0FA2                          3220  
00FF0FA2                          3221  
00FF0FA2                          3222  *************************************************************************************
00FF0FA2                          3223  *
00FF0FA2                          3224  * perform >> (right shift)
00FF0FA2                          3225  
00FF0FA2                          3226  LAB_RSHIFT
00FF0FA2  611E                    3227      BSR.s       GetPair         * get an integer and byte pair
00FF0FA4                          3228                              * byte is in d2, integer is in d0 and Itemp
00FF0FA4  67F8                    3229      BEQ.s       NoShift         * branch if byte zero
00FF0FA6                          3230  
00FF0FA6  B43C 0020               3231      CMP.b       #$20,d2         * compare bit count with 32d
00FF0FAA  650A                    3232      BCS.s       Not2Big         * branch if >= (return shift)
00FF0FAC                          3233  
00FF0FAC  4A80                    3234      TST.l       d0              * test sign bit
00FF0FAE  6A0C                    3235      BPL.s       TooBig          * branch if +ve
00FF0FB0                          3236  
00FF0FB0  70FF                    3237      MOVEQ       #-1,d0          * set longword
00FF0FB2  6000 0330               3238      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00FF0FB6                          3239  
00FF0FB6                          3240  Not2Big
00FF0FB6  E4A0                    3241      ASR.l       d2,d0               * shift longword
00FF0FB8  6000 032A               3242      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00FF0FBC                          3243  
00FF0FBC                          3244  TooBig
00FF0FBC  7000                    3245      MOVEQ       #0,d0               * clear longword
00FF0FBE  6000 0324               3246      BRA     LAB_AYFC            * convert d0 to longword in FAC1 & RET
00FF0FC2                          3247  
00FF0FC2                          3248  
00FF0FC2                          3249  *************************************************************************************
00FF0FC2                          3250  *
00FF0FC2                          3251  * get an integer and byte pair
00FF0FC2                          3252  * byte is in d2, integer is in d0 and Itemp
00FF0FC2                          3253  
00FF0FC2                          3254  GetPair
00FF0FC2  6100 078E               3255      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
00FF0FC6                          3256                              * Itemp
00FF0FC6  1400                    3257      MOVE.b  d0,d2               * save it
00FF0FC8  6100 0E5A               3258      BSR     LAB_279B            * copy FAC2 to FAC1, get first value in
00FF0FCC                          3259                              * expression
00FF0FCC  6100 0162               3260      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00FF0FD0                          3261                              * result in d0 and Itemp
00FF0FD0  4A02                    3262      TST.b       d2              * test byte value
00FF0FD2  4E75                    3263      RTS
00FF0FD4                          3264  
00FF0FD4                          3265  
00FF0FD4                          3266  *************************************************************************************
00FF0FD4                          3267  *
00FF0FD4                          3268  * check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
00FF0FD4                          3269  
00FF0FD4                          3270  LAB_CASC
00FF0FD4  B03C 0061               3271      CMP.b       #$61,d0         * compare with "a"
00FF0FD8  6410                    3272      BCC.s       LAB_1D83            * if >="a" go check =<"z"
00FF0FDA                          3273  
00FF0FDA                          3274  
00FF0FDA                          3275  *************************************************************************************
00FF0FDA                          3276  *
00FF0FDA                          3277  * check alpha upper case, return C=0 if<"A" or >"Z"
00FF0FDA                          3278  
00FF0FDA                          3279  LAB_CAUC
00FF0FDA  B03C 0041               3280      CMP.b       #$41,d0         * compare with "A"
00FF0FDE  6404                    3281      BCC.s       LAB_1D8A            * if >="A" go check =<"Z"
00FF0FE0                          3282  
00FF0FE0  8040                    3283      OR      d0,d0               * make C=0
00FF0FE2  4E75                    3284      RTS
00FF0FE4                          3285  
00FF0FE4                          3286  LAB_1D8A
00FF0FE4  B03C 005B               3287      CMP.b       #$5B,d0         * compare with "Z"+1
00FF0FE8                          3288                              * carry set if byte<="Z"
00FF0FE8  4E75                    3289      RTS
00FF0FEA                          3290  
00FF0FEA                          3291  LAB_1D83
00FF0FEA  B03C 007B               3292      CMP.b       #$7B,d0         * compare with "z"+1
00FF0FEE                          3293                              * carry set if byte<="z"
00FF0FEE  4E75                    3294      RTS
00FF0FF0                          3295  
00FF0FF0                          3296  
00FF0FF0                          3297  *************************************************************************************
00FF0FF0                          3298  *
00FF0FF0                          3299  * search for or create variable. this is used to automatically create a variable if
00FF0FF0                          3300  * it is not found. any routines that need to create the variable call LAB_GVAR via
00FF0FF0                          3301  * this point and error generation is supressed and the variable will be created
00FF0FF0                          3302  *
00FF0FF0                          3303  * return pointer to variable in Cvaral and a0
00FF0FF0                          3304  * set data type to variable type
00FF0FF0                          3305  
00FF0FF0                          3306  LAB_SVAR
00FF0FF0  6102                    3307      BSR.s       LAB_GVAR            * search for variable
00FF0FF2                          3308  LAB_FVAR
00FF0FF2  4E75                    3309      RTS
00FF0FF4                          3310  
00FF0FF4                          3311  
00FF0FF4                          3312  *************************************************************************************
00FF0FF4                          3313  *
00FF0FF4                          3314  * search for variable. if this routine is called from anywhere but the above call and
00FF0FF4                          3315  * the variable searched for does not exist then an error will be returned
00FF0FF4                          3316  *
00FF0FF4                          3317  * DIM flag is in d1.b
00FF0FF4                          3318  * return pointer to variable in Cvaral and a0
00FF0FF4                          3319  * set data type to variable type
00FF0FF4                          3320  
00FF0FF4                          3321  LAB_GVAR
00FF0FF4  7200                    3322      MOVEQ       #$00,d1         * set DIM flag = $00
00FF0FF6  6100 FDE6               3323      BSR     LAB_GBYT            * scan memory (1st character)
00FF0FFA                          3324  LAB_1D10
00FF0FFA  1741 09B4               3325      MOVE.b  d1,Defdim(a3)       * save DIM flag
00FF0FFE                          3326  
00FF0FFE                          3327  * search for FN name entry point
00FF0FFE                          3328  
00FF0FFE                          3329  LAB_1D12
00FF0FFE  61D4                    3330      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
00FF1000  6400 F19C               3331      BCC     LAB_SNER            * if not syntax error, then warm start
00FF1004                          3332  
00FF1004                          3333                              * is variable name so ...
00FF1004  7200                    3334      MOVEQ       #$0,d1          * set index for name byte
00FF1006  41EB 086A               3335      LEA     Varname(a3),a0      * pointer to variable name
00FF100A  2081                    3336      MOVE.l  d1,(a0)         * clear variable name
00FF100C  1741 09B5               3337      MOVE.b  d1,Dtypef(a3)       * clear data type, $80=string, $40=integer,
00FF1010                          3338                              * $00=float
00FF1010                          3339  
00FF1010                          3340  LAB_1D2D
00FF1010  B27C 0004               3341      CMP.w       #$04,d1         * done all significant characters?
00FF1014  6406                    3342      BCC.s       LAB_1D2E            * if so go ignore any more
00FF1016                          3343  
00FF1016  1180 1000               3344      MOVE.b  d0,(a0,d1.w)        * save character
00FF101A  5241                    3345      ADDQ.w  #1,d1               * increment index
00FF101C                          3346  LAB_1D2E
00FF101C  6100 FDBE               3347      BSR     LAB_IGBY            * increment & scan memory (next character)
00FF1020  65EE                    3348      BCS.s       LAB_1D2D            * branch if character = "0"-"9" (ok)
00FF1022                          3349  
00FF1022                          3350                              * character wasn't "0" to "9" so ...
00FF1022  61B0                    3351      BSR.s       LAB_CASC            * check byte, return C=0 if<"A" or >"Z"
00FF1024  65EA                    3352      BCS.s       LAB_1D2D            * branch if = "A"-"Z" (ok)
00FF1026                          3353  
00FF1026                          3354                              * check if string variable
00FF1026  B03C 0024               3355      CMP.b       #'$',d0         * compare with "$"
00FF102A  660C                    3356      BNE.s       LAB_1D44            * branch if not string
00FF102C                          3357  
00FF102C                          3358                              * type is string
00FF102C  002B 0080 086B          3359      OR.b        #$80,Varname+1(a3)  * set top bit of 2nd character, indicate string
00FF1032  6100 FDA8               3360      BSR     LAB_IGBY            * increment & scan memory
00FF1036  6010                    3361      BRA.s       LAB_1D45            * skip integer check
00FF1038                          3362  
00FF1038                          3363                              * check if integer variable
00FF1038                          3364  LAB_1D44
00FF1038  B03C 0026               3365      CMP.b       #'&',d0         * compare with "&"
00FF103C  660A                    3366      BNE.s       LAB_1D45            * branch if not integer
00FF103E                          3367  
00FF103E                          3368                              * type is integer
00FF103E  002B 0080 086C          3369      OR.b        #$80,Varname+2(a3)  * set top bit of 3rd character, indicate integer
00FF1044  6100 FD96               3370      BSR     LAB_IGBY            * increment & scan memory
00FF1048                          3371  
00FF1048                          3372  * after we have determined the variable type we need to determine
00FF1048                          3373  * if it's an array of type
00FF1048                          3374  
00FF1048                          3375                              * gets here with character after var name in d0
00FF1048                          3376  LAB_1D45
00FF1048  4A2B 09DF               3377      TST.b       Sufnxf(a3)          * test function name flag
00FF104C  670E                    3378      BEQ.s       LAB_1D48            * branch if not FN or FN variable
00FF104E                          3379  
00FF104E  6A14                    3380      BPL.s       LAB_1D49            * branch if FN variable
00FF1050                          3381  
00FF1050                          3382                              * else was FN name
00FF1050  202B 086A               3383      MOVE.l  Varname(a3),d0      * get whole function name
00FF1054  7208                    3384      MOVEQ       #8,d1               * set step to next function size -4
00FF1056  41EB 0832               3385      LEA     Sfncl(a3),a0        * get pointer to start of functions
00FF105A  601C                    3386      BRA.s       LAB_1D4B            * go find function
00FF105C                          3387  
00FF105C                          3388  LAB_1D48
00FF105C  0400 0028               3389      SUB.b       #'(',d0         * subtract "("
00FF1060  6700 00F4               3390      BEQ     LAB_1E17            * if "(" go find, or make, array
00FF1064                          3391  
00FF1064                          3392  * either find or create var
00FF1064                          3393  * var name (1st four characters only!) is in Varname
00FF1064                          3394  
00FF1064                          3395                              * variable name wasn't var( .. so look for
00FF1064                          3396                              * plain variable
00FF1064                          3397  LAB_1D49
00FF1064  202B 086A               3398      MOVE.l  Varname(a3),d0      * get whole variable name
00FF1068                          3399  LAB_1D4A
00FF1068  7204                    3400      MOVEQ       #4,d1               * set step to next variable size -4
00FF106A  41EB 0836               3401      LEA     Svarl(a3),a0        * get pointer to start of variables
00FF106E                          3402  
00FF106E  0800 0017               3403      BTST.l  #23,d0          * test if string name
00FF1072  6704                    3404      BEQ.s       LAB_1D4B            * branch if not
00FF1074                          3405  
00FF1074  5441                    3406      ADDQ.w  #2,d1               * 6 bytes per string entry
00FF1076  5848                    3407      ADDQ.w  #(Sstrl-Svarl),a0       * move to string area
00FF1078                          3408  
00FF1078                          3409  LAB_1D4B
00FF1078  2268 0004               3410      MOVEA.l 4(a0),a1            * get end address
00FF107C  2050                    3411      MOVEA.l (a0),a0         * get start address
00FF107E  6006                    3412      BRA.s       LAB_1D5E            * enter loop at exit check
00FF1080                          3413  
00FF1080                          3414  LAB_1D5D
00FF1080  B098                    3415      CMP.l       (a0)+,d0            * compare this variable with name
00FF1082  6776                    3416      BEQ.s       LAB_1DD7            * branch if match (found var)
00FF1084                          3417  
00FF1084  D1C1                    3418      ADDA.l  d1,a0               * add offset to next variable
00FF1086                          3419  LAB_1D5E
00FF1086  B1C9                    3420      CMPA.l  a1,a0               * compare address with variable space end
00FF1088  66F6                    3421      BNE.s       LAB_1D5D            * if not end go check next
00FF108A                          3422  
00FF108A  4A2B 09DF               3423      TST.b       Sufnxf(a3)          * is it a function or function variable
00FF108E  660A                    3424      BNE.s       LAB_1D94            * if was go do DEF or function variable
00FF1090                          3425  
00FF1090                          3426                              * reached end of variable mem without match
00FF1090                          3427                              * ... so create new variable, possibly
00FF1090                          3428  
00FF1090  45FA FF60               3429      LEA     LAB_FVAR(pc),a2     * get the address of the create if doesn't
00FF1094                          3430                              * exist call to LAB_GVAR
00FF1094  B5D7                    3431      CMPA.l  (sp),a2         * compare the return address with expected
00FF1096  6600 F0C2               3432      BNE     LAB_UVER            * if not create go do error or return null
00FF109A                          3433  
00FF109A                          3434  * this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
00FF109A                          3435  
00FF109A                          3436  LAB_1D94
00FF109A  082B 0000 09DF          3437      BTST.b  #0,Sufnxf(a3)       * test function search flag
00FF10A0  6600 F0C0               3438      BNE     LAB_UFER            * if not doing DEF then go do undefined
00FF10A4                          3439                              * function error
00FF10A4                          3440  
00FF10A4                          3441                              * else create new variable/function
00FF10A4                          3442  LAB_1D98
00FF10A4  246B 0842               3443      MOVEA.l Earryl(a3),a2       * get end of block to move
00FF10A8  240A                    3444      MOVE.l  a2,d2               * copy end of block to move
00FF10AA  9489                    3445      SUB.l       a1,d2               * calculate block to move size
00FF10AC                          3446  
00FF10AC  204A                    3447      MOVEA.l a2,a0               * copy end of block to move
00FF10AE  5881                    3448      ADDQ.l  #4,d1               * space for one variable/function + name
00FF10B0  D5C1                    3449      ADDA.l  d1,a2               * add space for one variable/function
00FF10B2  274A 0842               3450      MOVE.l  a2,Earryl(a3)       * set new array mem end
00FF10B6  E28A                    3451      LSR.l       #1,d2               * /2 for word copy
00FF10B8  6712                    3452      BEQ.s       LAB_1DAF            * skip move if zero length block
00FF10BA                          3453  
00FF10BA  5382                    3454      SUBQ.l  #1,d2               * -1 for DFB loop
00FF10BC  4842                    3455      SWAP        d2              * swap high word to low word
00FF10BE                          3456  LAB_1DAC
00FF10BE  4842                    3457      SWAP        d2              * swap high word to low word
00FF10C0                          3458  LAB_1DAE
00FF10C0  3520                    3459      MOVE.w  -(a0),-(a2)         * copy word
00FF10C2  51CA FFFC               3460      DBF     d2,LAB_1DAE         * loop until done
00FF10C6                          3461  
00FF10C6  4842                    3462      SWAP        d2              * swap high word to low word
00FF10C8  51CA FFF4               3463      DBF     d2,LAB_1DAC         * decrement high count and loop until done
00FF10CC                          3464  
00FF10CC                          3465  * get here after creating either a function, variable or string
00FF10CC                          3466  * if function set variables start, string start, array start
00FF10CC                          3467  * if variable set string start, array start
00FF10CC                          3468  * if string set array start
00FF10CC                          3469  
00FF10CC                          3470  LAB_1DAF
00FF10CC  4A2B 09DF               3471      TST.b       Sufnxf(a3)          * was it function
00FF10D0  6B08                    3472      BMI.s       LAB_1DB0            * branch if was FN
00FF10D2                          3473  
00FF10D2  0800 0017               3474      BTST.l  #23,d0          * was it string
00FF10D6  660A                    3475      BNE.s       LAB_1DB2            * branch if string
00FF10D8                          3476  
00FF10D8  6004                    3477      BRA.s       LAB_1DB1            * branch if was plain variable
00FF10DA                          3478  
00FF10DA                          3479  LAB_1DB0
00FF10DA  D3AB 0836               3480      ADD.l       d1,Svarl(a3)        * set new variable memory start
00FF10DE                          3481  LAB_1DB1
00FF10DE  D3AB 083A               3482      ADD.l       d1,Sstrl(a3)        * set new start of strings
00FF10E2                          3483  LAB_1DB2
00FF10E2  D3AB 083E               3484      ADD.l       d1,Sarryl(a3)       * set new array memory start
00FF10E6  20C0                    3485      MOVE.l  d0,(a0)+            * save variable/function name
00FF10E8  20BC 00000000           3486      MOVE.l  #$00,(a0)           * initialise variable
00FF10EE  0800 0017               3487      BTST.l  #23,d0          * was it string
00FF10F2  6706                    3488      BEQ.s       LAB_1DD7            * branch if not string
00FF10F4                          3489  
00FF10F4  317C 0000 0004          3490      MOVE.w  #$00,4(a0)          * else initialise string length
00FF10FA                          3491  
00FF10FA                          3492                              * found a match for var ((Vrschl) = ptr)
00FF10FA                          3493                              * found a match for var ((Vrschl) = ptr)
00FF10FA                          3494  LAB_1DD7
00FF10FA  2200                    3495      MOVE.l  d0,d1               * ........ $....... &....... ........
00FF10FC  D281                    3496      ADD.l       d1,d1               * .......$ .......& ........ .......0
00FF10FE  4841                    3497      SWAP        d1              * ........ .......0 .......$ .......&
00FF1100  E219                    3498      ROR.b       #1,d1               * ........ .......0 .......$ &.......
00FF1102  E249                    3499      LSR.w       #1,d1               * ........ .......0 0....... $&......
00FF1104  C23C 00C0               3500      AND.b       #$C0,d1         * mask the type bits
00FF1108  1741 09B5               3501      MOVE.b  d1,Dtypef(a3)       * save the data type
00FF110C                          3502  
00FF110C  177C 0000 09DF          3503      MOVE.b  #$00,Sufnxf(a3)     * clear FN flag byte
00FF1112                          3504  
00FF1112                          3505  * if you want a non existant variable to return a null value then set the novar
00FF1112                          3506  * value at the top of this file to some non zero value
00FF1112                          3507  
00FF1112                 FALSE    3508   ifne   novar
00FF1112                          3509   endc
00FF1112                          3510  
00FF1112  4E75                    3511      RTS
00FF1114                          3512  
00FF1114                          3513  
00FF1114                          3514  *************************************************************************************
00FF1114                          3515  *
00FF1114                          3516  * set-up array pointer, d0, to first element in array
00FF1114                          3517  * set d0 to (a0)+2*(Dimcnt)+$0A
00FF1114                          3518  
00FF1114                          3519  LAB_1DE6
00FF1114  7005                    3520      MOVEQ       #5,d0               * set d0 to 5 (*2 = 10, later)
00FF1116  D02B 09DB               3521      ADD.b       Dimcnt(a3),d0       * add # of dimensions (1, 2 or 3)
00FF111A  D080                    3522      ADD.l       d0,d0               * *2 (bytes per dimension size)
00FF111C  D088                    3523      ADD.l       a0,d0               * add array start pointer
00FF111E  4E75                    3524      RTS
00FF1120                          3525  
00FF1120                          3526  
00FF1120                          3527  *************************************************************************************
00FF1120                          3528  *
00FF1120                          3529  * evaluate unsigned integer expression
00FF1120                          3530  
00FF1120                          3531  LAB_EVIN
00FF1120  6100 FCBA               3532      BSR     LAB_IGBY            * increment & scan memory
00FF1124  6100 FB3E               3533      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00FF1128                          3534                              * else do type mismatch
00FF1128                          3535  
00FF1128                          3536  
00FF1128                          3537  *************************************************************************************
00FF1128                          3538  *
00FF1128                          3539  * evaluate positive integer expression, result in d0 and Itemp
00FF1128                          3540  
00FF1128                          3541  LAB_EVPI
00FF1128  4A2B 0995               3542      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
00FF112C  6B00 F064               3543      BMI     LAB_FCER            * do function call error if -ve
00FF1130                          3544  
00FF1130                          3545  
00FF1130                          3546  *************************************************************************************
00FF1130                          3547  *
00FF1130                          3548  * evaluate integer expression, no sign check
00FF1130                          3549  * result in d0 and Itemp, exit with flags set correctly
00FF1130                          3550  
00FF1130                          3551  LAB_EVIR
00FF1130  0C2B 00A0 0994          3552      CMPI.b  #$A0,FAC1_e(a3)     * compare exponent with exponent = 2^32 (n>2^31)
00FF1136  6500 0D84               3553      BCS     LAB_2831            * convert FAC1 floating to fixed
00FF113A                          3554                              * result in d0 and Itemp
00FF113A  6600 F056               3555      BNE     LAB_FCER            * if > do function call error, then warm start
00FF113E                          3556  
00FF113E  4A2B 0995               3557      TST.b       FAC1_s(a3)          * test sign of FAC1
00FF1142  6A00 0D78               3558      BPL     LAB_2831            * if +ve then ok
00FF1146                          3559  
00FF1146  202B 0990               3560      MOVE.l  FAC1_m(a3),d0       * get mantissa
00FF114A  4480                    3561      NEG.l       d0              * do -d0
00FF114C  6800 F044               3562      BVC     LAB_FCER            * if not $80000000 do FC error, then warm start
00FF1150                          3563  
00FF1150  2740 082A               3564      MOVE.l  d0,Itemp(a3)        * else just set it
00FF1154  4E75                    3565      RTS
00FF1156                          3566  
00FF1156                          3567  
00FF1156                          3568  *************************************************************************************
00FF1156                          3569  *
00FF1156                          3570  * find or make array
00FF1156                          3571  
00FF1156                          3572  LAB_1E17
00FF1156  3F2B 09B4               3573      MOVE.w  Defdim(a3),-(sp)        * get DIM flag and data type flag (word in mem)
00FF115A  7200                    3574      MOVEQ       #0,d1               * clear dimensions count
00FF115C                          3575  
00FF115C                          3576  * now get the array dimension(s) and stack it (them) before the data type and DIM flag
00FF115C                          3577  
00FF115C                          3578  LAB_1E1F
00FF115C  3F01                    3579      MOVE.w  d1,-(sp)            * save dimensions count
00FF115E  2F2B 086A               3580      MOVE.l  Varname(a3),-(sp)       * save variable name
00FF1162  61BC                    3581      BSR.s       LAB_EVIN            * evaluate integer expression
00FF1164                          3582  
00FF1164  4840                    3583      SWAP        d0              * swap high word to low word
00FF1166  4A40                    3584      TST.w       d0              * test swapped high word
00FF1168  6600 F018               3585      BNE     LAB_ABER            * if too big do array bounds error
00FF116C                          3586  
00FF116C  275F 086A               3587      MOVE.l  (sp)+,Varname(a3)       * restore variable name
00FF1170  321F                    3588      MOVE.w  (sp)+,d1            * restore dimensions count
00FF1172  301F                    3589      MOVE.w  (sp)+,d0            * restore DIM and data type flags
00FF1174  3F2B 082C               3590      MOVE.w  Itemp+2(a3),-(sp)       * stack this dimension size
00FF1178  3F00                    3591      MOVE.w  d0,-(sp)            * save DIM and data type flags
00FF117A  5241                    3592      ADDQ.w  #1,d1               * increment dimensions count
00FF117C  6100 FC60               3593      BSR     LAB_GBYT            * scan memory
00FF1180  B03C 002C               3594      CMP.b       #$2C,d0         * compare with ","
00FF1184  67D6                    3595      BEQ.s       LAB_1E1F            * if found go do next dimension
00FF1186                          3596  
00FF1186  1741 09DB               3597      MOVE.b  d1,Dimcnt(a3)       * store dimensions count
00FF118A  6100 FC3E               3598      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00FF118E  375F 09B4               3599      MOVE.w  (sp)+,Defdim(a3)        * restore DIM and data type flags (word in mem)
00FF1192  206B 083E               3600      MOVEA.l Sarryl(a3),a0       * get array mem start
00FF1196                          3601  
00FF1196                          3602  * now check to see if we are at the end of array memory (we would be if there were
00FF1196                          3603  * no arrays).
00FF1196                          3604  
00FF1196                          3605  LAB_1E5C
00FF1196  2748 09AC               3606      MOVE.l  a0,Astrtl(a3)       * save as array start pointer
00FF119A  B1EB 0842               3607      CMPA.l  Earryl(a3),a0       * compare with array mem end
00FF119E  672E                    3608      BEQ.s       LAB_1EA1            * go build array if not found
00FF11A0                          3609  
00FF11A0                          3610                              * search for array
00FF11A0  2010                    3611      MOVE.l  (a0),d0         * get this array name
00FF11A2  B0AB 086A               3612      CMP.l       Varname(a3),d0      * compare with array name
00FF11A6  670A                    3613      BEQ.s       LAB_1E8D            * array found so branch
00FF11A8                          3614  
00FF11A8                          3615                              * no match
00FF11A8  2068 0004               3616      MOVEA.l 4(a0),a0            * get this array size
00FF11AC  D1EB 09AC               3617      ADDA.l  Astrtl(a3),a0       * add to array start pointer
00FF11B0  60E4                    3618      BRA.s       LAB_1E5C            * go check next array
00FF11B2                          3619  
00FF11B2                          3620                              * found array, are we trying to dimension it?
00FF11B2                          3621  LAB_1E8D
00FF11B2  4A2B 09B4               3622      TST.b       Defdim(a3)          * are we trying to dimension it?
00FF11B6  6600 EFC6               3623      BNE     LAB_DDER            * if so do double dimension error/warm start
00FF11BA                          3624  
00FF11BA                          3625  * found the array and we're not dimensioning it so we must find an element in it
00FF11BA                          3626  
00FF11BA  6100 FF58               3627      BSR     LAB_1DE6            * set data pointer, d0, to the first element
00FF11BE                          3628                              * in the array
00FF11BE  5048                    3629      ADDQ.w  #8,a0               * index to dimension count
00FF11C0  3018                    3630      MOVE.w  (a0)+,d0            * get no of dimensions
00FF11C2  B02B 09DB               3631      CMP.b       Dimcnt(a3),d0       * compare with dimensions count
00FF11C6  6700 0094               3632      BEQ     LAB_1F28            * found array so go get element
00FF11CA                          3633  
00FF11CA  6000 EF86               3634      BRA     LAB_WDER            * else wrong so do "Wrong dimensions" error
00FF11CE                          3635  
00FF11CE                          3636                              * array not found, so possibly build it
00FF11CE                          3637  LAB_1EA1
00FF11CE  4A2B 09B4               3638      TST.b       Defdim(a3)          * test the default DIM flag
00FF11D2  6700 EF82               3639      BEQ     LAB_UDER            * if default flag is clear then we are not
00FF11D6                          3640                              * explicitly dimensioning an array so go
00FF11D6                          3641                              * do an "Undimensioned array" error
00FF11D6                          3642  
00FF11D6  6100 FF3C               3643      BSR     LAB_1DE6            * set data pointer, d0, to the first element
00FF11DA                          3644                              * in the array
00FF11DA  202B 086A               3645      MOVE.l  Varname(a3),d0      * get array name
00FF11DE  20C0                    3646      MOVE.l  d0,(a0)+            * save array name
00FF11E0  7204                    3647      MOVEQ       #4,d1               * set 4 bytes per element
00FF11E2  0800 0017               3648      BTST.l  #23,d0          * test if string array
00FF11E6  6702                    3649      BEQ.s       LAB_1EDF            * branch if not string
00FF11E8                          3650  
00FF11E8  7206                    3651      MOVEQ       #6,d1               * else 6 bytes per element
00FF11EA                          3652  LAB_1EDF
00FF11EA  2741 09A8               3653      MOVE.l  d1,Asptl(a3)        * set array data size (bytes per element)
00FF11EE  122B 09DB               3654      MOVE.b  Dimcnt(a3),d1       * get dimensions count
00FF11F2  5848                    3655      ADDQ.w  #4,a0               * skip the array size now (don't know it yet!)
00FF11F4  30C1                    3656      MOVE.w  d1,(a0)+            * set array's dimensions count
00FF11F6                          3657  
00FF11F6                          3658  * now calculate the array data space size
00FF11F6                          3659  
00FF11F6                          3660  LAB_1EC0
00FF11F6                          3661  
00FF11F6                          3662  * If you want arrays to dimension themselves by default then comment out the test
00FF11F6                          3663  * above and uncomment the next three code lines and the label LAB_1ED0
00FF11F6                          3664  
00FF11F6                          3665  *   MOVE.w  #$0A,d1         * set default dimension value, allow 0 to 9
00FF11F6                          3666  *   TST.b       Defdim(a3)          * test default DIM flag
00FF11F6                          3667  *   BNE.s       LAB_1ED0            * branch if b6 of Defdim is clear
00FF11F6                          3668  
00FF11F6  321F                    3669      MOVE.w  (sp)+,d1            * get dimension size
00FF11F8                          3670  *LAB_1ED0
00FF11F8  30C1                    3671      MOVE.w  d1,(a0)+            * save to array header
00FF11FA  6100 00AE               3672      BSR     LAB_1F7C            * do this dimension size+1 * array size
00FF11FE                          3673                              * (d1+1)*(Asptl), result in d0
00FF11FE  2740 09A8               3674      MOVE.l  d0,Asptl(a3)        * save array data size
00FF1202  532B 09DB               3675      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
00FF1206  66EE                    3676      BNE.s       LAB_1EC0            * loop while not = 0
00FF1208                          3677  
00FF1208  D1EB 09A8               3678      ADDA.l  Asptl(a3),a0        * add size to first element address
00FF120C  6500 EF7C               3679      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00FF1210                          3680  
00FF1210  B1EB 0846               3681      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00FF1214  650C                    3682      BCS.s       LAB_1ED6            * branch if less (is ok)
00FF1216                          3683  
00FF1216  6100 028E               3684      BSR     LAB_GARB            * do garbage collection routine
00FF121A  B1EB 0846               3685      CMPA.l  Sstorl(a3),a0       * compare with bottom of string memory
00FF121E  6400 EF6A               3686      BCC     LAB_OMER            * if Sstorl <= a0 do "Out of memory"
00FF1222                          3687                              * error then warm start
00FF1222                          3688  
00FF1222                          3689  LAB_1ED6                        * ok exit, carry set
00FF1222  2748 0842               3690      MOVE.l  a0,Earryl(a3)       * save array mem end
00FF1226  7000                    3691      MOVEQ       #0,d0               * zero d0
00FF1228  222B 09A8               3692      MOVE.l  Asptl(a3),d1        * get size in bytes
00FF122C  E289                    3693      LSR.l       #1,d1               * /2 for word fill (may be odd # words)
00FF122E  5341                    3694      SUBQ.w  #1,d1               * adjust for DBF loop
00FF1230                          3695  LAB_1ED8
00FF1230  3100                    3696      MOVE.w  d0,-(a0)            * decrement pointer and clear word
00FF1232  51C9 FFFC               3697      DBF     d1,LAB_1ED8         * decrement & loop until low word done
00FF1236                          3698  
00FF1236  4841                    3699      SWAP        d1              * swap words
00FF1238  4A41                    3700      TST.w       d1              * test high word
00FF123A  6706                    3701      BEQ.s       LAB_1F07            * exit if done
00FF123C                          3702  
00FF123C  5341                    3703      SUBQ.w  #1,d1               * decrement low (high) word
00FF123E  4841                    3704      SWAP        d1              * swap back
00FF1240  60EE                    3705      BRA.s       LAB_1ED8            * go do a whole block
00FF1242                          3706  
00FF1242                          3707  * now we need to calculate the array size by doing Earryl - Astrtl
00FF1242                          3708  
00FF1242                          3709  LAB_1F07
00FF1242  206B 09AC               3710      MOVEA.l Astrtl(a3),a0       * get for calculation and as pointer
00FF1246  202B 0842               3711      MOVE.l  Earryl(a3),d0       * get array memory end
00FF124A  9088                    3712      SUB.l       a0,d0               * calculate array size
00FF124C  2140 0004               3713      MOVE.l  d0,4(a0)            * save size to array
00FF1250  4A2B 09B4               3714      TST.b       Defdim(a3)          * test default DIM flag
00FF1254  6652                    3715      BNE.s       RTS_011         * exit (RET) if this was a DIM command
00FF1256                          3716  
00FF1256                          3717                              * else, find element
00FF1256  5048                    3718      ADDQ.w  #8,a0               * index to dimension count
00FF1258  3758 09DB               3719      MOVE.w  (a0)+,Dimcnt(a3)        * get array's dimension count
00FF125C                          3720  
00FF125C                          3721  * we have found, or built, the array. now we need to find the element
00FF125C                          3722  
00FF125C                          3723  LAB_1F28
00FF125C  7000                    3724      MOVEQ       #0,d0               * clear first result
00FF125E  2740 09A8               3725      MOVE.l  d0,Asptl(a3)        * clear array data pointer
00FF1262                          3726  
00FF1262                          3727  * compare nth dimension bound (a0) with nth index (sp)+
00FF1262                          3728  * if greater do array bounds error
00FF1262                          3729  
00FF1262                          3730  LAB_1F2C
00FF1262  3218                    3731      MOVE.w  (a0)+,d1            * get nth dimension bound
00FF1264  B257                    3732      CMP.w       (sp),d1         * compare nth index with nth dimension bound
00FF1266  6500 EF1A               3733      BCS     LAB_ABER            * if d1 less or = do array bounds error
00FF126A                          3734  
00FF126A                          3735  * now do pointer = pointer * nth dimension + nth index
00FF126A                          3736  
00FF126A  4A80                    3737      TST.l       d0              * test pointer
00FF126C  6702                    3738      BEQ.s       LAB_1F5A            * skip multiply if last result = null
00FF126E                          3739  
00FF126E  613A                    3740      BSR.s       LAB_1F7C            * do this dimension size+1 * array size
00FF1270                          3741  LAB_1F5A
00FF1270  7200                    3742      MOVEQ       #0,d1               * clear longword
00FF1272  321F                    3743      MOVE.w  (sp)+,d1            * get nth dimension index
00FF1274  D081                    3744      ADD.l       d1,d0               * add index to size
00FF1276  2740 09A8               3745      MOVE.l  d0,Asptl(a3)        * save array data pointer
00FF127A                          3746  
00FF127A  532B 09DB               3747      SUBQ.b  #1,Dimcnt(a3)       * decrement dimensions count
00FF127E  66E2                    3748      BNE.s       LAB_1F2C            * loop if dimensions still to do
00FF1280                          3749  
00FF1280  177C 0000 09B5          3750      MOVE.b  #0,Dtypef(a3)       * set data type to float
00FF1286  7203                    3751      MOVEQ       #3,d1               * set for numeric array
00FF1288  4A2B 086B               3752      TST.b       Varname+1(a3)       * test if string array
00FF128C  6A0A                    3753      BPL.s       LAB_1F6A            * branch if not string
00FF128E                          3754  
00FF128E  7205                    3755      MOVEQ       #5,d1               * else set for string array
00FF1290  177C 0080 09B5          3756      MOVE.b  #$80,Dtypef(a3)     * and set data type to string
00FF1296  600C                    3757      BRA.s       LAB_1F6B            * skip integer test
00FF1298                          3758  
00FF1298                          3759  LAB_1F6A
00FF1298  4A2B 086C               3760      TST.b       Varname+2(a3)       * test if integer array
00FF129C  6A06                    3761      BPL.s       LAB_1F6B            * branch if not integer
00FF129E                          3762  
00FF129E  177C 0040 09B5          3763      MOVE.b  #$40,Dtypef(a3)     * else set data type to integer
00FF12A4                          3764  LAB_1F6B
00FF12A4  6104                    3765      BSR.s       LAB_1F7C            * do element size (d1) * array size (Asptl)
00FF12A6  D1C0                    3766      ADDA.l  d0,a0               * add array data start pointer
00FF12A8                          3767  RTS_011
00FF12A8  4E75                    3768      RTS
00FF12AA                          3769  
00FF12AA                          3770  
00FF12AA                          3771  *************************************************************************************
00FF12AA                          3772  *
00FF12AA                          3773  * do this dimension size (d1) * array data size (Asptl)
00FF12AA                          3774  
00FF12AA                          3775  * do a 16 x 32 bit multiply
00FF12AA                          3776  * d1 holds the 16 bit multiplier
00FF12AA                          3777  * Asptl holds the 32 bit multiplicand
00FF12AA                          3778  
00FF12AA                          3779  * d0    bbbb  bbbb
00FF12AA                          3780  * d1    0000  aaaa
00FF12AA                          3781  *   ----------
00FF12AA                          3782  * d0    rrrr  rrrr
00FF12AA                          3783  
00FF12AA                          3784  LAB_1F7C
00FF12AA  202B 09A8               3785      MOVE.l  Asptl(a3),d0        * get result
00FF12AE  2400                    3786      MOVE.l  d0,d2               * copy it
00FF12B0  4842                    3787      SWAP        d2              * shift high word to low word
00FF12B2  C0C1                    3788      MULU.w  d1,d0               * d1 * low word = low result
00FF12B4  C4C1                    3789      MULU.w  d1,d2               * d1 * high word = high result
00FF12B6  4842                    3790      SWAP        d2              * align words for test
00FF12B8  4A42                    3791      TST.w       d2              * must be zero
00FF12BA  6600 EECE               3792      BNE     LAB_OMER            * if overflow go do "Out of memory" error
00FF12BE                          3793  
00FF12BE  D082                    3794      ADD.l       d2,d0               * calculate result
00FF12C0  6500 EEC8               3795      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00FF12C4                          3796  
00FF12C4  D0AB 09A8               3797      ADD.l       Asptl(a3),d0        * add original
00FF12C8  6500 EEC0               3798      BCS     LAB_OMER            * if overflow go do "Out of memory" error
00FF12CC                          3799  
00FF12CC  4E75                    3800      RTS
00FF12CE                          3801  
00FF12CE                          3802  
00FF12CE                          3803  *************************************************************************************
00FF12CE                          3804  *
00FF12CE                          3805  * perform FRE()
00FF12CE                          3806  
00FF12CE                          3807  LAB_FRE
00FF12CE  4A2B 09B5               3808      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00FF12D2                          3809                              * $00=float
00FF12D2  6A04                    3810      BPL.s       LAB_1FB4            * branch if numeric
00FF12D4                          3811  
00FF12D4  6100 0318               3812      BSR     LAB_22B6            * pop string off descriptor stack, or from
00FF12D8                          3813                              * top of string space, returns d0 = length,
00FF12D8                          3814                              * a0 = pointer
00FF12D8                          3815  
00FF12D8                          3816                              * FRE(n) was numeric so do this
00FF12D8                          3817  LAB_1FB4
00FF12D8  6100 01CC               3818      BSR     LAB_GARB            * go do garbage collection
00FF12DC  202B 0846               3819      MOVE.l  Sstorl(a3),d0       * get bottom of string space
00FF12E0  90AB 0842               3820      SUB.l       Earryl(a3),d0       * subtract array mem end
00FF12E4                          3821  
00FF12E4                          3822  
00FF12E4                          3823  *************************************************************************************
00FF12E4                          3824  *
00FF12E4                          3825  * convert d0 to signed longword in FAC1
00FF12E4                          3826  
00FF12E4                          3827  LAB_AYFC
00FF12E4  177C 0000 09B5          3828      MOVE.b  #$00,Dtypef(a3)     * clear data type, $80=string, $40=integer,
00FF12EA                          3829                              * $00=float
00FF12EA  377C A000 0994          3830      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent and clear sign (b7)
00FF12F0  2740 0990               3831      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
00FF12F4  6A00 0860               3832      BPL     LAB_24D0            * convert if +ve
00FF12F8                          3833  
00FF12F8  003C 0001               3834      ORI.b       #1,CCR          * else set carry
00FF12FC  6000 0858               3835      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
00FF1300                          3836  
00FF1300                          3837  
00FF1300                          3838  *************************************************************************************
00FF1300                          3839  *
00FF1300                          3840  * remember if the line length is zero (infinite line) then POS(n) will return
00FF1300                          3841  * position MOD tabsize
00FF1300                          3842  
00FF1300                          3843  * perform POS()
00FF1300                          3844  
00FF1300                          3845  LAB_POS
00FF1300  102B 09E5               3846      MOVE.b  TPos(a3),d0         * get terminal position
00FF1304                          3847  
00FF1304                          3848  * convert d0 to unsigned byte in FAC1
00FF1304                          3849  
00FF1304                          3850  LAB_1FD0
00FF1304  C0BC 000000FF           3851      AND.l       #$FF,d0         * clear high bits
00FF130A  60D8                    3852      BRA.s       LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00FF130C                          3853  
00FF130C                          3854  * check not Direct (used by DEF and INPUT)
00FF130C                          3855  
00FF130C                          3856  LAB_CKRN
00FF130C  4A2B 0852               3857      TST.b       Clinel(a3)          * test current line #
00FF1310  6B00 EE64               3858      BMI     LAB_IDER            * if -ve go do illegal direct error then warm
00FF1314                          3859                              * start
00FF1314                          3860  
00FF1314  4E75                    3861      RTS                     * can continue so return
00FF1316                          3862  
00FF1316                          3863  
00FF1316                          3864  *************************************************************************************
00FF1316                          3865  *
00FF1316                          3866  * perform DEF
00FF1316                          3867  
00FF1316                          3868  LAB_DEF
00FF1316  70B8                    3869      MOVEQ       #TK_FN-$100,d0      * get FN token
00FF1318  6100 FABA               3870      BSR     LAB_SCCA            * scan for CHR$(d0), else syntax error and
00FF131C                          3871                              * warm start
00FF131C                          3872                              * return character after d0
00FF131C  177C 0080 09DF          3873      MOVE.b  #$80,Sufnxf(a3)     * set FN flag bit
00FF1322  6100 FCDA               3874      BSR     LAB_1D12            * get FN name
00FF1326  2748 09B0               3875      MOVE.l  a0,func_l(a3)       * save function pointer
00FF132A                          3876  
00FF132A  61E0                    3877      BSR.s       LAB_CKRN            * check not direct (back here if ok)
00FF132C  0C1D 0028               3878      CMP.b       #$28,(a5)+          * check next byte is "(" and increment
00FF1330  6600 EE6C               3879      BNE     LAB_SNER            * else do syntax error/warm start
00FF1334                          3880  
00FF1334  177C 007E 09DF          3881      MOVE.b  #$7E,Sufnxf(a3)     * set FN variable flag bits
00FF133A  6100 FCB4               3882      BSR     LAB_SVAR            * search for or create a variable
00FF133E                          3883                              * return the variable address in a0
00FF133E  6100 FA8A               3884      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00FF1342  70CA                    3885      MOVEQ       #TK_EQUAL-$100,d0       * = token
00FF1344  6100 FA8E               3886      BSR     LAB_SCCA            * scan for CHR$(A), else syntax error/warm start
00FF1348                          3887                              * return character after d0
00FF1348  2F2B 086A               3888      MOVE.l  Varname(a3),-(sp)       * push current variable name
00FF134C  2F0D                    3889      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00FF134E  6100 F412               3890      BSR     LAB_DATA            * go perform DATA, find end of DEF FN statement
00FF1352  206B 09B0               3891      MOVEA.l func_l(a3),a0       * get the function pointer
00FF1356  209F                    3892      MOVE.l  (sp)+,(a0)          * save BASIC execute pointer to function
00FF1358  215F 0004               3893      MOVE.l  (sp)+,4(a0)         * save current variable name to function
00FF135C  4E75                    3894      RTS
00FF135E                          3895  
00FF135E                          3896  
00FF135E                          3897  *************************************************************************************
00FF135E                          3898  *
00FF135E                          3899  * evaluate FNx
00FF135E                          3900  
00FF135E                          3901  LAB_201E
00FF135E  177C 0081 09DF          3902      MOVE.b  #$81,Sufnxf(a3)     * set FN flag (find not create)
00FF1364  6100 FA76               3903      BSR     LAB_IGBY            * increment & scan memory
00FF1368  6100 FC94               3904      BSR     LAB_1D12            * get FN name
00FF136C  1F2B 09B5               3905      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function type)
00FF1370  2F08                    3906      MOVE.l  a0,-(sp)            * push function pointer
00FF1372  0C15 0028               3907      CMP.b       #$28,(a5)           * check next byte is "(", no increment
00FF1376  6600 EE26               3908      BNE     LAB_SNER            * else do syntax error/warm start
00FF137A                          3909  
00FF137A  6100 FA4A               3910      BSR     LAB_1BF7            * evaluate expression within parentheses
00FF137E  205F                    3911      MOVEA.l (sp)+,a0            * pop function pointer
00FF1380  2748 09B0               3912      MOVE.l  a0,func_l(a3)       * set function pointer
00FF1384  1F2B 09B5               3913      MOVE.b  Dtypef(a3),-(sp)        * push data type flag (function expression type)
00FF1388                          3914  
00FF1388  2028 0004               3915      MOVE.l  4(a0),d0            * get function variable name
00FF138C  6100 FCDA               3916      BSR     LAB_1D4A            * go find function variable (already created)
00FF1390                          3917  
00FF1390                          3918                              * now check type match for variable
00FF1390  101F                    3919      MOVE.b  (sp)+,d0            * pop data type flag (function expression type)
00FF1392  E318                    3920      ROL.b       #1,d0               * set carry if type = string
00FF1394  6100 F8D2               3921      BSR     LAB_CKTM            * type match check, set C for string
00FF1398                          3922  
00FF1398                          3923                              * now stack the function variable value before
00FF1398                          3924                              * use
00FF1398  6712                    3925      BEQ.s       LAB_2043            * branch if not string
00FF139A                          3926  
00FF139A  43EB 0876               3927      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
00FF139E  B9C9                    3928      CMPA.l  a1,a4               * compare string stack pointer with max+1
00FF13A0  6700 EDC8               3929      BEQ     LAB_SCER            * if no space on the stack go do string too
00FF13A4                          3930                              * complex error
00FF13A4                          3931  
00FF13A4  3928 0004               3932      MOVE.w  4(a0),-(a4)         * string length on descriptor stack
00FF13A8  2910                    3933      MOVE.l  (a0),-(a4)          * string address on stack
00FF13AA  6002                    3934      BRA.s       LAB_204S            * skip var push
00FF13AC                          3935  
00FF13AC                          3936  LAB_2043
00FF13AC  2F10                    3937      MOVE.l  (a0),-(sp)          * push variable
00FF13AE                          3938  LAB_204S
00FF13AE  2F08                    3939      MOVE.l  a0,-(sp)            * push variable address
00FF13B0  1F2B 09B5               3940      MOVE.b  Dtypef(a3),-(sp)        * push variable data type
00FF13B4                          3941  
00FF13B4  6132                    3942      BSR.s       LAB_2045            * pack function expression value into (a0)
00FF13B6                          3943                              * (function variable)
00FF13B6  2F0D                    3944      MOVE.l  a5,-(sp)            * push BASIC execute pointer
00FF13B8  206B 09B0               3945      MOVEA.l func_l(a3),a0       * get function pointer
00FF13BC  2A50                    3946      MOVEA.l (a0),a5         * save function execute ptr as BASIC execute ptr
00FF13BE  6100 F8BC               3947      BSR     LAB_EVEX            * evaluate expression
00FF13C2  6100 FA1A               3948      BSR     LAB_GBYT            * scan memory
00FF13C6  6600 EDD6               3949      BNE     LAB_SNER            * if not [EOL] or [EOS] do syntax error then
00FF13CA                          3950                              * warm start
00FF13CA                          3951  
00FF13CA  2A5F                    3952      MOVE.l  (sp)+,a5            * restore BASIC execute pointer
00FF13CC                          3953  
00FF13CC                          3954  * restore variable from stack and test data type
00FF13CC                          3955  
00FF13CC  101F                    3956      MOVE.b  (sp)+,d0            * pull variable data type
00FF13CE  205F                    3957      MOVEA.l (sp)+,a0            * pull variable address
00FF13D0  4A00                    3958      TST.b       d0              * test variable data type
00FF13D2  6A08                    3959      BPL.s       LAB_204T            * branch if not string
00FF13D4                          3960  
00FF13D4  209C                    3961      MOVE.l  (a4)+,(a0)          * string address from descriptor stack
00FF13D6  315C 0004               3962      MOVE.w  (a4)+,4(a0)         * string length from descriptor stack
00FF13DA  6002                    3963      BRA.s       LAB_2044            * skip variable pull
00FF13DC                          3964  
00FF13DC                          3965  LAB_204T
00FF13DC  209F                    3966      MOVE.l  (sp)+,(a0)          * restore variable from stack
00FF13DE                          3967  LAB_2044
00FF13DE  101F                    3968      MOVE.b  (sp)+,d0            * pop data type flag (function type)
00FF13E0  E318                    3969      ROL.b       #1,d0               * set carry if type = string
00FF13E2  6100 F884               3970      BSR     LAB_CKTM            * type match check, set C for string
00FF13E6  4E75                    3971      RTS
00FF13E8                          3972  
00FF13E8                          3973  LAB_2045
00FF13E8  4A2B 09B5               3974      TST.b       Dtypef(a3)          * test data type
00FF13EC  6A00 0A10               3975      BPL     LAB_2778            * if numeric pack FAC1 into variable (a0) and
00FF13F0                          3976                              * return
00FF13F0                          3977  
00FF13F0  2448                    3978      MOVEA.l a0,a2               * copy variable pointer
00FF13F2  6000 F50C               3979      BRA     LAB_17D6            * go do string LET & return
00FF13F6                          3980  
00FF13F6                          3981  
00FF13F6                          3982  
00FF13F6                          3983  *************************************************************************************
00FF13F6                          3984  *
00FF13F6                          3985  * perform STR$()
00FF13F6                          3986  
00FF13F6                          3987  LAB_STRS
00FF13F6  6100 0B6E               3988      BSR     LAB_2970            * convert FAC1 to string
00FF13FA                          3989  
00FF13FA                          3990  * scan, set up string
00FF13FA                          3991  * print " terminated string to FAC1 stack
00FF13FA                          3992  
00FF13FA                          3993  LAB_20AE
00FF13FA  7422                    3994      MOVEQ       #$22,d2         * set Srchc character (terminator 1)
00FF13FC  3602                    3995      MOVE.w  d2,d3               * set Asrch character (terminator 2)
00FF13FE                          3996  
00FF13FE                          3997  * print d2/d3 terminated string to FAC1 stack
00FF13FE                          3998  * d2 = Srchc, d3 = Asrch, a0 is source
00FF13FE                          3999  * a6 is temp
00FF13FE                          4000  
00FF13FE                          4001  LAB_20B4
00FF13FE  7200                    4002      MOVEQ       #0,d1               * clear longword
00FF1400  5341                    4003      SUBQ.w  #1,d1               * set length to -1
00FF1402  2448                    4004      MOVEA.l a0,a2               * copy start to calculate end
00FF1404                          4005  LAB_20BE
00FF1404  5241                    4006      ADDQ.w  #1,d1               * increment length
00FF1406  1030 1000               4007      MOVE.b  (a0,d1.w),d0        * get byte from string
00FF140A  6710                    4008      BEQ.s       LAB_20D0            * exit loop if null byte [EOS]
00FF140C                          4009  
00FF140C  B002                    4010      CMP.b       d2,d0               * compare with search character (terminator 1)
00FF140E  6704                    4011      BEQ.s       LAB_20CB            * branch if terminator
00FF1410                          4012  
00FF1410  B003                    4013      CMP.b       d3,d0               * compare with terminator 2
00FF1412  66F0                    4014      BNE.s       LAB_20BE            * loop if not terminator 2 (or null string)
00FF1414                          4015  
00FF1414                          4016  LAB_20CB
00FF1414  B03C 0022               4017      CMP.b       #$22,d0         * compare with "
00FF1418  6602                    4018      BNE.s       LAB_20D0            * branch if not "
00FF141A                          4019  
00FF141A  524A                    4020      ADDQ.w  #1,a2               * else increment string start (skip " at end)
00FF141C                          4021  LAB_20D0
00FF141C  D5C1                    4022      ADDA.l  d1,a2               * add longowrd length to make string end+1
00FF141E                          4023  
00FF141E  B1CB                    4024      CMPA.l  a3,a0               * is string in ram
00FF1420  651E                    4025      BCS.s       LAB_RTST            * if not go push descriptor on stack & exit
00FF1422                          4026                              * (could be message string from ROM)
00FF1422                          4027  
00FF1422  B1EB 082E               4028      CMPA.l  Smeml(a3),a0        * is string in utility ram
00FF1426  6418                    4029      BCC.s       LAB_RTST            * if not go push descriptor on stack & exit
00FF1428                          4030                              * (is in string or program space)
00FF1428                          4031  
00FF1428                          4032                              * (else) copy string to string memory
00FF1428                          4033  LAB_20C9
00FF1428  2248                    4034      MOVEA.l a0,a1               * copy descriptor pointer
00FF142A  2001                    4035      MOVE.l  d1,d0               * copy longword length
00FF142C  6604                    4036      BNE.s       LAB_20D8            * branch if not null string
00FF142E                          4037  
00FF142E  2041                    4038      MOVEA.l d1,a0               * make null pointer
00FF1430  600E                    4039      BRA.s       LAB_RTST            * go push descriptor on stack & exit
00FF1432                          4040  
00FF1432                          4041  LAB_20D8
00FF1432  6126                    4042      BSR.s       LAB_2115            * make string space d1 bytes long
00FF1434  D1C1                    4043      ADDA.l  d1,a0               * new string end
00FF1436  D3C1                    4044      ADDA.l  d1,a1               * old string end
00FF1438  5340                    4045      SUBQ.w  #1,d0               * -1 for DBF loop
00FF143A                          4046  LAB_20E0
00FF143A  1121                    4047      MOVE.b  -(a1),-(a0)         * copy byte (source can be odd aligned)
00FF143C  51C8 FFFC               4048      DBF     d0,LAB_20E0         * loop until done
00FF1440                          4049  
00FF1440                          4050  
00FF1440                          4051  
00FF1440                          4052  *************************************************************************************
00FF1440                          4053  *
00FF1440                          4054  * check for space on descriptor stack then ...
00FF1440                          4055  * put string address and length on descriptor stack & update stack pointers
00FF1440                          4056  * start is in a0, length is in d1
00FF1440                          4057  
00FF1440                          4058  LAB_RTST
00FF1440  43EB 0876               4059      LEA     des_sk_e(a3),a1     * get string stack pointer max+1
00FF1444  B9C9                    4060      CMPA.l  a1,a4               * compare string stack pointer with max+1
00FF1446  6700 ED22               4061      BEQ     LAB_SCER            * if no space on string stack ..
00FF144A                          4062                              * .. go do 'string too complex' error
00FF144A                          4063  
00FF144A                          4064                              * push string & update pointers
00FF144A  3901                    4065      MOVE.w  d1,-(a4)            * string length on descriptor stack
00FF144C  2908                    4066      MOVE.l  a0,-(a4)            * string address on stack
00FF144E  274C 0990               4067      MOVE.l  a4,FAC1_m(a3)       * string descriptor pointer in FAC1
00FF1452  177C 0080 09B5          4068      MOVE.b  #$80,Dtypef(a3)     * save data type flag, $80=string
00FF1458  4E75                    4069      RTS
00FF145A                          4070  
00FF145A                          4071  
00FF145A                          4072  *************************************************************************************
00FF145A                          4073  *
00FF145A                          4074  * build descriptor a0/d1
00FF145A                          4075  * make space in string memory for string d1.w long
00FF145A                          4076  * return pointer in a0/Sutill
00FF145A                          4077  
00FF145A                          4078  LAB_2115
00FF145A  4A41                    4079      TST.w       d1              * test length
00FF145C  672E                    4080      BEQ.s       LAB_2128            * branch if user wants null string
00FF145E                          4081  
00FF145E                          4082                              * make space for string d1 long
00FF145E  2F00                    4083      MOVE.l  d0,-(sp)            * save d0
00FF1460  7000                    4084      MOVEQ       #0,d0               * clear longword
00FF1462  1740 09DE               4085      MOVE.b  d0,Gclctd(a3)       * clear garbage collected flag (b7)
00FF1466  7001                    4086      MOVEQ       #1,d0               * +1 to possibly round up
00FF1468  C041                    4087      AND.w       d1,d0               * mask odd bit
00FF146A  D041                    4088      ADD.w       d1,d0               * ensure d0 is even length
00FF146C  6404                    4089      BCC.s       LAB_2117            * branch if no overflow
00FF146E                          4090  
00FF146E  7001                    4091      MOVEQ       #1,d0               * set to allocate 65536 bytes
00FF1470  4840                    4092      SWAP        d0              * makes $00010000
00FF1472                          4093  LAB_2117
00FF1472  206B 0846               4094      MOVEA.l Sstorl(a3),a0       * get bottom of string space
00FF1476  91C0                    4095      SUBA.l  d0,a0               * subtract string length
00FF1478  B1EB 0842               4096      CMPA.l  Earryl(a3),a0       * compare with top of array space
00FF147C  6512                    4097      BCS.s       LAB_2137            * if less do out of memory error
00FF147E                          4098  
00FF147E  2748 0846               4099      MOVE.l  a0,Sstorl(a3)       * save bottom of string space
00FF1482  2748 084E               4100      MOVE.l  a0,Sutill(a3)       * save string utility pointer
00FF1486  201F                    4101      MOVE.l  (sp)+,d0            * restore d0
00FF1488  4A41                    4102      TST.w       d1              * set flags on length
00FF148A  4E75                    4103      RTS
00FF148C                          4104  
00FF148C                          4105  LAB_2128
00FF148C  3041                    4106      MOVEA.w d1,a0               * make null pointer
00FF148E  4E75                    4107      RTS
00FF1490                          4108  
00FF1490                          4109  LAB_2137
00FF1490  4A2B 09DE               4110      TST.b       Gclctd(a3)          * get garbage collected flag
00FF1494  6B00 ECF4               4111      BMI     LAB_OMER            * do "Out of memory" error, then warm start
00FF1498                          4112  
00FF1498  2F09                    4113      MOVE.l  a1,-(sp)            * save a1
00FF149A  610A                    4114      BSR.s       LAB_GARB            * else go do garbage collection
00FF149C  225F                    4115      MOVEA.l (sp)+,a1            * restore a1
00FF149E  177C 0080 09DE          4116      MOVE.b  #$80,Gclctd(a3)     * set garbage collected flag
00FF14A4  60CC                    4117      BRA.s       LAB_2117            * go try again
00FF14A6                          4118  
00FF14A6                          4119  
00FF14A6                          4120  *************************************************************************************
00FF14A6                          4121  *
00FF14A6                          4122  * garbage collection routine
00FF14A6                          4123  
00FF14A6                          4124  LAB_GARB
00FF14A6  48E7 E0E0               4125      MOVEM.l d0-d2/a0-a2,-(sp)       * save registers
00FF14AA  276B 084A 0846          4126      MOVE.l  Ememl(a3),Sstorl(a3)    * start with no strings
00FF14B0                          4127  
00FF14B0                          4128                              * re-run routine from last ending
00FF14B0                          4129  LAB_214B
00FF14B0  222B 0842               4130      MOVE.l  Earryl(a3),d1       * set highest uncollected string so far
00FF14B4  7000                    4131      MOVEQ       #0,d0               * clear longword
00FF14B6  2240                    4132      MOVEA.l d0,a1               * clear string to move pointer
00FF14B8  206B 083A               4133      MOVEA.l Sstrl(a3),a0        * set pointer to start of strings
00FF14BC  41E8 0004               4134      LEA     4(a0),a0            * index to string pointer
00FF14C0  246B 083E               4135      MOVEA.l Sarryl(a3),a2       * set end pointer to start of arrays, end of
00FF14C4                          4136                              * strings
00FF14C4  6008                    4137      BRA.s       LAB_2176            * branch into loop at end loop test
00FF14C6                          4138  
00FF14C6                          4139  LAB_2161
00FF14C6  6100 0084               4140      BSR     LAB_2206            * test and set if this is the highest string
00FF14CA  41E8 000A               4141      LEA     10(a0),a0           * increment to next string
00FF14CE                          4142  LAB_2176
00FF14CE  B1CA                    4143      CMPA.l  a2,a0               * compare end of area with pointer
00FF14D0  65F4                    4144      BCS.s       LAB_2161            * go do next if not at end
00FF14D2                          4145  
00FF14D2                          4146  * done strings, now do arrays.
00FF14D2                          4147  
00FF14D2  41E8 FFFC               4148      LEA     -4(a0),a0           * decrement pointer to start of arrays
00FF14D6  246B 0842               4149      MOVEA.l Earryl(a3),a2       * set end pointer to end of arrays
00FF14DA  6024                    4150      BRA.s       LAB_218F            * branch into loop at end loop test
00FF14DC                          4151  
00FF14DC                          4152  LAB_217E
00FF14DC  2428 0004               4153      MOVE.l  4(a0),d2            * get array size
00FF14E0  D488                    4154      ADD.l       a0,d2               * makes start of next array
00FF14E2                          4155  
00FF14E2  2010                    4156      MOVE.l  (a0),d0         * get array name
00FF14E4  0800 0017               4157      BTST        #23,d0          * test string flag
00FF14E8  6714                    4158      BEQ.s       LAB_218B            * branch if not string
00FF14EA                          4159  
00FF14EA  3028 0008               4160      MOVE.w  8(a0),d0            * get # of dimensions
00FF14EE  D040                    4161      ADD.w       d0,d0               * *2
00FF14F0  D0C0                    4162      ADDA.w  d0,a0               * add to skip dimension size(s)
00FF14F2  41E8 000A               4163      LEA     10(a0),a0           * increment to first element
00FF14F6                          4164  LAB_2183
00FF14F6  6154                    4165      BSR.s       LAB_2206            * test and set if this is the highest string
00FF14F8  5C48                    4166      ADDQ.w  #6,a0               * increment to next element
00FF14FA  B1C2                    4167      CMPA.l  d2,a0               * compare with start of next array
00FF14FC  66F8                    4168      BNE.s       LAB_2183            * go do next if not at end of array
00FF14FE                          4169  
00FF14FE                          4170  LAB_218B
00FF14FE  2042                    4171      MOVEA.l d2,a0               * pointer to next array
00FF1500                          4172  LAB_218F
00FF1500  B5C8                    4173      CMPA.l  a0,a2               * compare pointer with array end
00FF1502  66D8                    4174      BNE.s       LAB_217E            * go do next if not at end
00FF1504                          4175  
00FF1504                          4176  * done arrays and variables, now just the descriptor stack to do
00FF1504                          4177  
00FF1504  204C                    4178      MOVEA.l a4,a0               * get descriptor stack pointer
00FF1506  45EB 088E               4179      LEA     des_sk(a3),a2       * set end pointer to end of stack
00FF150A  6006                    4180      BRA.s       LAB_21C4            * branch into loop at end loop test
00FF150C                          4181  
00FF150C                          4182  LAB_21C2
00FF150C  613E                    4183      BSR.s       LAB_2206            * test and set if this is the highest string
00FF150E  41E8 0006               4184      LEA     6(a0),a0            * increment to next string
00FF1512                          4185  LAB_21C4
00FF1512  B5C8                    4186      CMPA.l  a0,a2               * compare pointer with stack end
00FF1514  66F6                    4187      BNE.s       LAB_21C2            * go do next if not at end
00FF1516                          4188  
00FF1516                          4189  * descriptor search complete, now either exit or set-up and move string
00FF1516                          4190  
00FF1516  2009                    4191      MOVE.l  a1,d0               * set the flags (a1 is move string)
00FF1518  672C                    4192      BEQ.s       LAB_21D1            * go tidy up and exit if no move
00FF151A                          4193  
00FF151A  2051                    4194      MOVEA.l (a1),a0         * a0 is now string start
00FF151C  7200                    4195      MOVEQ       #0,d1               * clear d1
00FF151E  3229 0004               4196      MOVE.w  4(a1),d1            * d1 is string length
00FF1522  5281                    4197      ADDQ.l  #1,d1               * +1
00FF1524  C23C 00FE               4198      AND.b       #$FE,d1         * make even length
00FF1528  D1C1                    4199      ADDA.l  d1,a0               * pointer is now to string end+1
00FF152A  246B 0846               4200      MOVEA.l Sstorl(a3),a2       * is destination end+1
00FF152E  B1CA                    4201      CMPA.l  a2,a0               * does the string need moving
00FF1530  670C                    4202      BEQ.s       LAB_2240            * branch if not
00FF1532                          4203  
00FF1532  E289                    4204      LSR.l       #1,d1               * word move so do /2
00FF1534  5341                    4205      SUBQ.w  #1,d1               * -1 for DBF loop
00FF1536                          4206  LAB_2216
00FF1536  3520                    4207      MOVE.w  -(a0),-(a2)         * copy word
00FF1538  51C9 FFFC               4208      DBF     d1,LAB_2216         * loop until done
00FF153C                          4209  
00FF153C  228A                    4210      MOVE.l  a2,(a1)         * save new string start
00FF153E                          4211  LAB_2240
00FF153E  2751 0846               4212      MOVE.l  (a1),Sstorl(a3)     * string start is new string mem start
00FF1542  6000 FF6C               4213      BRA     LAB_214B            * re-run routine from last ending
00FF1546                          4214                              * (but don't collect this string)
00FF1546                          4215  
00FF1546                          4216  LAB_21D1
00FF1546  4CDF 0707               4217      MOVEM.l (sp)+,d0-d2/a0-a2       * restore registers
00FF154A  4E75                    4218      RTS
00FF154C                          4219  
00FF154C                          4220  * test and set if this is the highest string
00FF154C                          4221  
00FF154C                          4222  LAB_2206
00FF154C  2010                    4223      MOVE.l  (a0),d0         * get this string pointer
00FF154E  6728                    4224      BEQ.s       RTS_012         * exit if null string
00FF1550                          4225  
00FF1550  B280                    4226      CMP.l       d0,d1               * compare with highest uncollected string so far
00FF1552  6424                    4227      BCC.s       RTS_012         * exit if <= with highest so far
00FF1554                          4228  
00FF1554  B0AB 0846               4229      CMP.l       Sstorl(a3),d0       * compare with bottom of string space
00FF1558  641E                    4230      BCC.s       RTS_012         * exit if >= bottom of string space
00FF155A                          4231  
00FF155A  70FF                    4232      MOVEQ       #-1,d0          * d0 = $FFFFFFFF
00FF155C  3028 0004               4233      MOVE.w  4(a0),d0            * d0 is string length
00FF1560  4440                    4234      NEG.w       d0              * make -ve
00FF1562  C03C 00FE               4235      AND.b       #$FE,d0         * make -ve even length
00FF1566  D0AB 0846               4236      ADD.l       Sstorl(a3),d0       * add string store to -ve length
00FF156A  B090                    4237      CMP.l       (a0),d0         * compare with string address
00FF156C  6706                    4238      BEQ.s       LAB_2212            * if = go move string store pointer down
00FF156E                          4239  
00FF156E  2210                    4240      MOVE.l  (a0),d1         * highest = current
00FF1570  2248                    4241      MOVEA.l a0,a1               * string to move = current
00FF1572  4E75                    4242      RTS
00FF1574                          4243  
00FF1574                          4244  LAB_2212
00FF1574  2740 0846               4245      MOVE.l  d0,Sstorl(a3)       * set new string store start
00FF1578                          4246  RTS_012
00FF1578  4E75                    4247      RTS
00FF157A                          4248  
00FF157A                          4249  
00FF157A                          4250  *************************************************************************************
00FF157A                          4251  *
00FF157A                          4252  * concatenate - add strings
00FF157A                          4253  * string descriptor 1 is in FAC1_m, string 2 is in line
00FF157A                          4254  
00FF157A                          4255  LAB_224D
00FF157A  487A F732               4256      PEA     LAB_1ADB(pc)        * continue evaluation after concatenate
00FF157E  2F2B 0990               4257      MOVE.l  FAC1_m(a3),-(sp)        * stack descriptor pointer for string 1
00FF1582                          4258  
00FF1582  6100 F806               4259      BSR     LAB_GVAL            * get value from line
00FF1586  4A2B 09B5               4260      TST.b       Dtypef(a3)          * test data type flag
00FF158A  6A00 EBE6               4261      BPL     LAB_TMER            * if type is not string do type mismatch error
00FF158E                          4262  
00FF158E  205F                    4263      MOVEA.l (sp)+,a0            * restore descriptor pointer for string 1
00FF1590                          4264  
00FF1590                          4265  *************************************************************************************
00FF1590                          4266  *
00FF1590                          4267  * concatenate
00FF1590                          4268  * string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
00FF1590                          4269  
00FF1590                          4270  LAB_224E
00FF1590  226B 0990               4271      MOVEA.l FAC1_m(a3),a1       * copy descriptor pointer 2
00FF1594  3228 0004               4272      MOVE.w  4(a0),d1            * get length 1
00FF1598  D269 0004               4273      ADD.w       4(a1),d1            * add length 2
00FF159C  6500 EBD0               4274      BCS     LAB_SLER            * if overflow go do 'string too long' error
00FF15A0                          4275  
00FF15A0  2F08                    4276      MOVE.l  a0,-(sp)            * save descriptor pointer 1
00FF15A2  6100 FEB6               4277      BSR     LAB_2115            * make space d1 bytes long
00FF15A6  2748 0998               4278      MOVE.l  a0,FAC2_m(a3)       * save new string start pointer
00FF15AA  2057                    4279      MOVEA.l (sp),a0         * copy descriptor pointer 1 from stack
00FF15AC  3028 0004               4280      MOVE.w  4(a0),d0            * get length
00FF15B0  2050                    4281      MOVEA.l (a0),a0         * get string pointer
00FF15B2  6120                    4282      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00FF15B4                          4283                              * return with a0 = pointer, d1 = length
00FF15B4                          4284  
00FF15B4  206B 0990               4285      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer for string 2
00FF15B8  6138                    4286      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00FF15BA                          4287                              * a0 = pointer, d0 = length
00FF15BA  6118                    4288      BSR.s       LAB_229E            * copy string d0 bytes long from a0 to Sutill
00FF15BC                          4289                              * return with a0 = pointer, d1 = length
00FF15BC                          4290  
00FF15BC  205F                    4291      MOVEA.l (sp)+,a0            * get descriptor pointer for string 1
00FF15BE  6132                    4292      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00FF15C0                          4293                              * d0 = length, a0 = pointer
00FF15C0                          4294  
00FF15C0  206B 0998               4295      MOVEA.l FAC2_m(a3),a0       * retreive result string pointer
00FF15C4  2208                    4296      MOVE.l  a0,d1               * copy the result string pointer
00FF15C6  6700 FE78               4297      BEQ     LAB_RTST            * if it is a null string just return it
00FF15CA                          4298                              * a0 = pointer, d1 = length
00FF15CA                          4299  
00FF15CA  4481                    4300      NEG.l       d1              * else make the start pointer negative
00FF15CC  D2AB 084E               4301      ADD.l       Sutill(a3),d1       * add the end pointert to give the length
00FF15D0  6000 FE6E               4302      BRA     LAB_RTST            * push string on descriptor stack
00FF15D4                          4303                              * a0 = pointer, d1 = length
00FF15D4                          4304  
00FF15D4                          4305  
00FF15D4                          4306  *************************************************************************************
00FF15D4                          4307  *
00FF15D4                          4308  * copy string d0 bytes long from a0 to Sutill
00FF15D4                          4309  * return with a0 = pointer, d1 = length
00FF15D4                          4310  
00FF15D4                          4311  LAB_229E
00FF15D4  3200                    4312      MOVE.w  d0,d1               * copy and check length
00FF15D6  6714                    4313      BEQ.s       RTS_013         * skip copy if null
00FF15D8                          4314  
00FF15D8  226B 084E               4315      MOVEA.l Sutill(a3),a1       * get destination pointer
00FF15DC  2F09                    4316      MOVE.l  a1,-(sp)            * save destination string pointer
00FF15DE  5340                    4317      SUBQ.w  #1,d0               * subtract for DBF loop
00FF15E0                          4318  LAB_22A0
00FF15E0  12D8                    4319      MOVE.b  (a0)+,(a1)+         * copy byte
00FF15E2  51C8 FFFC               4320      DBF     d0,LAB_22A0         * loop if not done
00FF15E6                          4321  
00FF15E6  2749 084E               4322      MOVE.l  a1,Sutill(a3)       * update Sutill to end of copied string
00FF15EA  205F                    4323      MOVEA.l (sp)+,a0            * restore destination string pointer
00FF15EC                          4324  RTS_013
00FF15EC  4E75                    4325      RTS
00FF15EE                          4326  
00FF15EE                          4327  
00FF15EE                          4328  *************************************************************************************
00FF15EE                          4329  *
00FF15EE                          4330  * pop string off descriptor stack, or from top of string space
00FF15EE                          4331  * returns with d0.l = length, a0 = pointer
00FF15EE                          4332  
00FF15EE                          4333  LAB_22B6
00FF15EE  206B 0990               4334      MOVEA.l FAC1_m(a3),a0       * get descriptor pointer
00FF15F2                          4335  
00FF15F2                          4336  
00FF15F2                          4337  *************************************************************************************
00FF15F2                          4338  *
00FF15F2                          4339  * pop (a0) descriptor off stack or from string space
00FF15F2                          4340  * returns with d0.l = length, a0 = pointer
00FF15F2                          4341  
00FF15F2                          4342  LAB_22BA
00FF15F2  48E7 4040               4343      MOVEM.l a1/d1,-(sp)         * save other regs
00FF15F6  B9C8                    4344      CMPA.l  a0,a4               * is string on the descriptor stack
00FF15F8  6602                    4345      BNE.s       LAB_22BD            * skip pop if not
00FF15FA                          4346  
00FF15FA  5C4C                    4347      ADDQ.w  #$06,a4         * else update stack pointer
00FF15FC                          4348  LAB_22BD
00FF15FC  7000                    4349      MOVEQ       #0,d0               * clear string length longword
00FF15FE  2258                    4350      MOVEA.l (a0)+,a1            * get string address
00FF1600  3018                    4351      MOVE.w  (a0)+,d0            * get string length
00FF1602                          4352  
00FF1602  B9C8                    4353      CMPA.l  a0,a4               * was it on the descriptor stack
00FF1604  6610                    4354      BNE.s       LAB_22E6            * branch if it wasn't
00FF1606                          4355  
00FF1606  B3EB 0846               4356      CMPA.l  Sstorl(a3),a1       * compare string address with bottom of string
00FF160A                          4357                              * space
00FF160A  660A                    4358      BNE.s       LAB_22E6            * branch if <>
00FF160C                          4359  
00FF160C  7201                    4360      MOVEQ       #1,d1               * mask for odd bit
00FF160E  C240                    4361      AND.w       d0,d1               * AND length
00FF1610  D280                    4362      ADD.l       d0,d1               * make it fit word aligned length
00FF1612                          4363  
00FF1612  D3AB 0846               4364      ADD.l       d1,Sstorl(a3)       * add to bottom of string space
00FF1616                          4365  LAB_22E6
00FF1616  2049                    4366      MOVEA.l a1,a0               * copy to a0
00FF1618  4CDF 0202               4367      MOVEM.l (sp)+,a1/d1         * restore other regs
00FF161C  4A80                    4368      TST.l       d0              * set flags on length
00FF161E  4E75                    4369      RTS
00FF1620                          4370  
00FF1620                          4371  
00FF1620                          4372  *************************************************************************************
00FF1620                          4373  *
00FF1620                          4374  * perform CHR$()
00FF1620                          4375  
00FF1620                          4376  LAB_CHRS
00FF1620  6100 0130               4377      BSR     LAB_EVBY            * evaluate byte expression, result in d0 and
00FF1624                          4378                              * Itemp
00FF1624  7201                    4379      MOVEQ       #1,d1               * string is single byte
00FF1626  6100 FE32               4380      BSR     LAB_2115            * make string space d1 bytes long
00FF162A                          4381                              * return a0/Sutill = pointer, others unchanged
00FF162A  1080                    4382      MOVE.b  d0,(a0)         * save byte in string (byte IS string!)
00FF162C  6000 FE12               4383      BRA     LAB_RTST            * push string on descriptor stack
00FF1630                          4384                              * a0 = pointer, d1 = length
00FF1630                          4385  
00FF1630                          4386  
00FF1630                          4387  *************************************************************************************
00FF1630                          4388  *
00FF1630                          4389  * perform LEFT$()
00FF1630                          4390  
00FF1630                          4391  * enter with a0 is descriptor, d0 & Itemp is word 1
00FF1630                          4392  
00FF1630                          4393  LAB_LEFT
00FF1630  C141                    4394      EXG     d0,d1               * word in d1
00FF1632  6100 F796               4395      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00FF1636                          4396  
00FF1636  4A81                    4397      TST.l       d1              * test returned length
00FF1638  6722                    4398      BEQ.s       LAB_231C            * branch if null return
00FF163A                          4399  
00FF163A  7000                    4400      MOVEQ       #0,d0               * clear start offset
00FF163C  B268 0004               4401      CMP.w       4(a0),d1            * compare word parameter with string length
00FF1640  651A                    4402      BCS.s       LAB_231C            * branch if string length > word parameter
00FF1642                          4403  
00FF1642  6014                    4404      BRA.s       LAB_2317            * go copy whole string
00FF1644                          4405  
00FF1644                          4406  
00FF1644                          4407  *************************************************************************************
00FF1644                          4408  *
00FF1644                          4409  * perform RIGHT$()
00FF1644                          4410  
00FF1644                          4411  * enter with a0 is descriptor, d0 & Itemp is word 1
00FF1644                          4412  
00FF1644                          4413  LAB_RIGHT
00FF1644  C141                    4414      EXG     d0,d1               * word in d1
00FF1646  6100 F782               4415      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00FF164A                          4416  
00FF164A  4A81                    4417      TST.l       d1              * test returned length
00FF164C  670E                    4418      BEQ.s       LAB_231C            * branch if null return
00FF164E                          4419  
00FF164E  3028 0004               4420      MOVE.w  4(a0),d0            * get string length
00FF1652  9081                    4421      SUB.l       d1,d0               * subtract word
00FF1654  6406                    4422      BCC.s       LAB_231C            * branch if string length > word parameter
00FF1656                          4423  
00FF1656                          4424                              * else copy whole string
00FF1656                          4425  LAB_2316
00FF1656  7000                    4426      MOVEQ       #0,d0               * clear start offset
00FF1658                          4427  LAB_2317
00FF1658  3228 0004               4428      MOVE.w  4(a0),d1            * else make parameter = length
00FF165C                          4429  
00FF165C                          4430  * get here with ...
00FF165C                          4431  *   a0 - points to descriptor
00FF165C                          4432  *   d0 - is offset from string start
00FF165C                          4433  *   d1 - is required string length
00FF165C                          4434  
00FF165C                          4435  LAB_231C
00FF165C  2248                    4436      MOVEA.l a0,a1               * save string descriptor pointer
00FF165E  6100 FDFA               4437      BSR     LAB_2115            * make string space d1 bytes long
00FF1662                          4438                              * return a0/Sutill = pointer, others unchanged
00FF1662  2049                    4439      MOVEA.l a1,a0               * restore string descriptor pointer
00FF1664  2F00                    4440      MOVE.l  d0,-(sp)            * save start offset (longword)
00FF1666  618A                    4441      BSR.s       LAB_22BA            * pop (a0) descriptor, returns with ..
00FF1668                          4442                              * d0 = length, a0 = pointer
00FF1668  D1DF                    4443      ADDA.l  (sp)+,a0            * adjust pointer to start of wanted string
00FF166A  3001                    4444      MOVE.w  d1,d0               * length to d0
00FF166C  6100 FF66               4445      BSR     LAB_229E            * store string d0 bytes long from (a0) to
00FF1670                          4446                              * (Sutill) return with a0 = pointer,
00FF1670                          4447                              * d1 = length
00FF1670  6000 FDCE               4448      BRA     LAB_RTST            * push string on descriptor stack
00FF1674                          4449                              * a0 = pointer, d1 = length
00FF1674                          4450  
00FF1674                          4451  
00FF1674                          4452  *************************************************************************************
00FF1674                          4453  *
00FF1674                          4454  * perform MID$()
00FF1674                          4455  
00FF1674                          4456  * enter with a0 is descriptor, d0 & Itemp is word 1
00FF1674                          4457  
00FF1674                          4458  LAB_MIDS
00FF1674  7E00                    4459      MOVEQ       #0,d7               * clear longword
00FF1676  5347                    4460      SUBQ.w  #1,d7               * set default length = 65535
00FF1678  2F00                    4461      MOVE.l  d0,-(sp)            * save word 1
00FF167A  6100 F762               4462      BSR     LAB_GBYT            * scan memory
00FF167E  B03C 002C               4463      CMP.b       #',',d0         * was it ","
00FF1682  660C                    4464      BNE.s       LAB_2358            * branch if not "," (skip second byte get)
00FF1684                          4465  
00FF1684  101D                    4466      MOVE.b  (a5)+,d0            * increment pointer past ","
00FF1686  2F08                    4467      MOVE.l  a0,-(sp)            * save descriptor pointer
00FF1688  6100 00D8               4468      BSR     LAB_GTWO            * get word parameter, result in d0 and Itemp
00FF168C  205F                    4469      MOVEA.l (sp)+,a0            * restore descriptor pointer
00FF168E  2E00                    4470      MOVE.l  d0,d7               * copy length
00FF1690                          4471  LAB_2358
00FF1690  6100 F738               4472      BSR     LAB_1BFB            * scan for ")", else do syntax error then warm
00FF1694                          4473                              * start
00FF1694  201F                    4474      MOVE.l  (sp)+,d0            * restore word 1
00FF1696  7200                    4475      MOVEQ       #0,d1               * null length
00FF1698  5380                    4476      SUBQ.l  #1,d0               * decrement start index (word 1)
00FF169A  6B00 EAF6               4477      BMI     LAB_FCER            * if was null do function call error then warm
00FF169E                          4478                              * start
00FF169E                          4479  
00FF169E  B068 0004               4480      CMP.w       4(a0),d0            * compare string length with start index
00FF16A2  64B8                    4481      BCC.s       LAB_231C            * if start not in string do null string (d1=0)
00FF16A4                          4482  
00FF16A4  2207                    4483      MOVE.l  d7,d1               * get length back
00FF16A6  DE40                    4484      ADD.w       d0,d7               * d7 now = MID$() end
00FF16A8  6506                    4485      BCS.s       LAB_2368            * already too long so do RIGHT$ equivalent
00FF16AA                          4486  
00FF16AA  BE68 0004               4487      CMP.w       4(a0),d7            * compare string length with start index+length
00FF16AE  65AC                    4488      BCS.s       LAB_231C            * if end in string go do string
00FF16B0                          4489  
00FF16B0                          4490  LAB_2368
00FF16B0  3228 0004               4491      MOVE.w  4(a0),d1            * get string length
00FF16B4  9240                    4492      SUB.w       d0,d1               * subtract start offset
00FF16B6  60A4                    4493      BRA.s       LAB_231C            * go do string (effectively RIGHT$)
00FF16B8                          4494  
00FF16B8                          4495  
00FF16B8                          4496  *************************************************************************************
00FF16B8                          4497  *
00FF16B8                          4498  * perform LCASE$()
00FF16B8                          4499  
00FF16B8                          4500  LAB_LCASE
00FF16B8  6100 FF34               4501      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00FF16BC                          4502                              * returns with d0 = length, a0 = pointer
00FF16BC  2200                    4503      MOVE.l  d0,d1               * copy the string length
00FF16BE  6756                    4504      BEQ.s       NoString            * if null go return a null string
00FF16C0                          4505  
00FF16C0                          4506  * else copy and change the string
00FF16C0                          4507  
00FF16C0  2248                    4508      MOVEA.l a0,a1               * copy the string address
00FF16C2  6100 FD96               4509      BSR     LAB_2115            * make a string space d1 bytes long
00FF16C6  D1C1                    4510      ADDA.l  d1,a0               * new string end
00FF16C8  D3C1                    4511      ADDA.l  d1,a1               * old string end
00FF16CA  3401                    4512      MOVE.w  d1,d2               * copy length for loop
00FF16CC  5342                    4513      SUBQ.w  #1,d2               * -1 for DBF loop
00FF16CE                          4514  LC_loop
00FF16CE  1021                    4515      MOVE.b  -(a1),d0            * get byte from string
00FF16D0                          4516  
00FF16D0  B03C 005B               4517      CMP.b       #$5B,d0         * compare with "Z"+1
00FF16D4  640A                    4518      BCC.s       NoUcase         * if > "Z" skip change
00FF16D6                          4519  
00FF16D6  B03C 0041               4520      CMP.b       #$41,d0         * compare with "A"
00FF16DA  6504                    4521      BCS.s       NoUcase         * if < "A" skip change
00FF16DC                          4522  
00FF16DC  0000 0020               4523      ORI.b       #$20,d0         * convert upper case to lower case
00FF16E0                          4524  NoUcase
00FF16E0  1100                    4525      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00FF16E2  51CA FFEA               4526      DBF     d2,LC_loop          * decrement and loop if not all done
00FF16E6                          4527  
00FF16E6  602E                    4528      BRA.s       NoString            * tidy up & exit (branch always)
00FF16E8                          4529  
00FF16E8                          4530  
00FF16E8                          4531  *************************************************************************************
00FF16E8                          4532  *
00FF16E8                          4533  * perform UCASE$()
00FF16E8                          4534  
00FF16E8                          4535  LAB_UCASE
00FF16E8  6100 FF04               4536      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00FF16EC                          4537                              * returns with d0 = length, a0 = pointer
00FF16EC  2200                    4538      MOVE.l  d0,d1               * copy the string length
00FF16EE  6726                    4539      BEQ.s       NoString            * if null go return a null string
00FF16F0                          4540  
00FF16F0                          4541  * else copy and change the string
00FF16F0                          4542  
00FF16F0  2248                    4543      MOVEA.l a0,a1               * copy the string address
00FF16F2  6100 FD66               4544      BSR     LAB_2115            * make a string space d1 bytes long
00FF16F6  D1C1                    4545      ADDA.l  d1,a0               * new string end
00FF16F8  D3C1                    4546      ADDA.l  d1,a1               * old string end
00FF16FA  3401                    4547      MOVE.w  d1,d2               * copy length for loop
00FF16FC  5342                    4548      SUBQ.w  #1,d2               * -1 for DBF loop
00FF16FE                          4549  UC_loop
00FF16FE  1021                    4550      MOVE.b  -(a1),d0            * get a byte from the string
00FF1700                          4551  
00FF1700  B03C 0061               4552      CMP.b       #$61,d0         * compare with "a"
00FF1704  650A                    4553      BCS.s       NoLcase         * if < "a" skip change
00FF1706                          4554  
00FF1706  B03C 007B               4555      CMP.b       #$7B,d0         * compare with "z"+1
00FF170A  6404                    4556      BCC.s       NoLcase         * if > "z" skip change
00FF170C                          4557  
00FF170C  0200 00DF               4558      ANDI.b  #$DF,d0         * convert lower case to upper case
00FF1710                          4559  NoLcase
00FF1710  1100                    4560      MOVE.b  d0,-(a0)            * copy upper case byte back to string
00FF1712  51CA FFEA               4561      DBF     d2,UC_loop          * decrement and loop if not all done
00FF1716                          4562  
00FF1716                          4563  NoString
00FF1716  6000 FD28               4564      BRA     LAB_RTST            * push string on descriptor stack
00FF171A                          4565                              * a0 = pointer, d1 = length
00FF171A                          4566  
00FF171A                          4567  
00FF171A                          4568  *************************************************************************************
00FF171A                          4569  *
00FF171A                          4570  * perform SADD()
00FF171A                          4571  
00FF171A                          4572  LAB_SADD
00FF171A  101D                    4573      MOVE.b  (a5)+,d0            * increment pointer
00FF171C  6100 F8D6               4574      BSR     LAB_GVAR            * get variable address in a0
00FF1720  6100 F6A8               4575      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00FF1724  4A2B 09B5               4576      TST.b       Dtypef(a3)          * test data type flag
00FF1728  6A00 EA48               4577      BPL     LAB_TMER            * if numeric do Type missmatch Error
00FF172C                          4578  
00FF172C                          4579  * if you want a non existant variable to return a null value then set the novar
00FF172C                          4580  * value at the top of this file to some non zero value
00FF172C                          4581  
00FF172C                 FALSE    4582   ifne   novar
00FF172C                          4583   endc
00FF172C                          4584  
00FF172C  2010                    4585      MOVE.l  (a0),d0         * get string address
00FF172E  6000 FBB4               4586      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00FF1732                          4587  
00FF1732                          4588  
00FF1732                          4589  *************************************************************************************
00FF1732                          4590  *
00FF1732                          4591  * perform LEN()
00FF1732                          4592  
00FF1732                          4593  LAB_LENS
00FF1732  487A FBB0               4594      PEA     LAB_AYFC(pc)        * set return address to convert d0 to signed
00FF1736                          4595                              * longword in FAC1
00FF1736  6000 FEB6               4596      BRA     LAB_22B6            * pop string off descriptor stack or from memory
00FF173A                          4597                              * returns with d0 = length, a0 = pointer
00FF173A                          4598  
00FF173A                          4599  
00FF173A                          4600  *************************************************************************************
00FF173A                          4601  *
00FF173A                          4602  * perform ASC()
00FF173A                          4603  
00FF173A                          4604  LAB_ASC
00FF173A  6100 FEB2               4605      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00FF173E                          4606                              * returns with d0 = length, a0 = pointer
00FF173E  4A40                    4607      TST.w       d0              * test length
00FF1740  6700 EA50               4608      BEQ     LAB_FCER            * if null do function call error then warm start
00FF1744                          4609  
00FF1744  1010                    4610      MOVE.b  (a0),d0         * get first character byte
00FF1746  6000 FBBC               4611      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00FF174A                          4612  
00FF174A                          4613  
00FF174A                          4614  *************************************************************************************
00FF174A                          4615  *
00FF174A                          4616  * increment and get byte, result in d0 and Itemp
00FF174A                          4617  
00FF174A                          4618  LAB_SGBY
00FF174A  6100 F690               4619      BSR     LAB_IGBY            * increment & scan memory
00FF174E                          4620  
00FF174E                          4621  
00FF174E                          4622  *************************************************************************************
00FF174E                          4623  *
00FF174E                          4624  * get byte parameter, result in d0 and Itemp
00FF174E                          4625  
00FF174E                          4626  LAB_GTBY
00FF174E  6100 F514               4627      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00FF1752                          4628                              * else do type mismatch
00FF1752                          4629  
00FF1752                          4630  
00FF1752                          4631  *************************************************************************************
00FF1752                          4632  *
00FF1752                          4633  * evaluate byte expression, result in d0 and Itemp
00FF1752                          4634  
00FF1752                          4635  LAB_EVBY
00FF1752  6100 F9D4               4636      BSR     LAB_EVPI            * evaluate positive integer expression
00FF1756                          4637                              * result in d0 and Itemp
00FF1756  7280                    4638      MOVEQ       #$80,d1         * set mask/2
00FF1758  D281                    4639      ADD.l       d1,d1               * =$FFFFFF00
00FF175A  C280                    4640      AND.l       d0,d1               * check top 24 bits
00FF175C  6600 EA34               4641      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00FF1760                          4642  
00FF1760  4E75                    4643      RTS
00FF1762                          4644  
00FF1762                          4645  
00FF1762                          4646  *************************************************************************************
00FF1762                          4647  *
00FF1762                          4648  * get word parameter, result in d0 and Itemp
00FF1762                          4649  
00FF1762                          4650  LAB_GTWO
00FF1762  6100 F500               4651      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00FF1766                          4652                              * else do type mismatch
00FF1766  6100 F9C0               4653      BSR     LAB_EVPI            * evaluate positive integer expression
00FF176A                          4654                              * result in d0 and Itemp
00FF176A  4840                    4655      SWAP        d0              * copy high word to low word
00FF176C  4A40                    4656      TST.w       d0              * set flags
00FF176E  6600 EA22               4657      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00FF1772                          4658  
00FF1772  4840                    4659      SWAP        d0              * copy high word to low word
00FF1774  4E75                    4660      RTS
00FF1776                          4661  
00FF1776                          4662  
00FF1776                          4663  *************************************************************************************
00FF1776                          4664  *
00FF1776                          4665  * perform VAL()
00FF1776                          4666  
00FF1776                          4667  LAB_VAL
00FF1776  6100 FE76               4668      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00FF177A                          4669                              * returns with d0 = length, a0 = pointer
00FF177A  6722                    4670      BEQ.s       LAB_VALZ            * string was null so set result = $00
00FF177C                          4671                              * clear FAC1 exponent & sign & return
00FF177C                          4672  
00FF177C  2C4D                    4673      MOVEA.l a5,a6               * save BASIC execute pointer
00FF177E  2A48                    4674      MOVEA.l a0,a5               * copy string pointer to execute pointer
00FF1780  D1C0                    4675      ADDA.l  d0,a0               * string end+1
00FF1782  1010                    4676      MOVE.b  (a0),d0         * get byte from string+1
00FF1784  3F00                    4677      MOVE.w  d0,-(sp)            * save it
00FF1786  2F08                    4678      MOVE.l  a0,-(sp)            * save address
00FF1788  10BC 0000               4679      MOVE.b  #0,(a0)         * null terminate string
00FF178C  6100 F650               4680      BSR     LAB_GBYT            * scan memory
00FF1790  6100 1366               4681      BSR     LAB_2887            * get FAC1 from string
00FF1794  205F                    4682      MOVEA.l (sp)+,a0            * restore pointer
00FF1796  301F                    4683      MOVE.w  (sp)+,d0            * pop byte
00FF1798  1080                    4684      MOVE.b  d0,(a0)         * restore to memory
00FF179A  2A4E                    4685      MOVEA.l a6,a5               * restore BASIC execute pointer
00FF179C  4E75                    4686      RTS
00FF179E                          4687  
00FF179E                          4688  LAB_VALZ
00FF179E  3740 0994               4689      MOVE.w  d0,FAC1_e(a3)       * clear FAC1 exponent & sign
00FF17A2  4E75                    4690      RTS
00FF17A4                          4691  
00FF17A4                          4692  
00FF17A4                          4693  *************************************************************************************
00FF17A4                          4694  *
00FF17A4                          4695  * get two parameters for POKE or WAIT, first parameter in a0, second in d0
00FF17A4                          4696  
00FF17A4                          4697  LAB_GADB
00FF17A4  6100 F4BE               4698      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00FF17A8                          4699                              * else do type mismatch
00FF17A8  6100 F986               4700      BSR     LAB_EVIR            * evaluate integer expression
00FF17AC                          4701                              * (does FC error not OF error if out of range)
00FF17AC  2F00                    4702      MOVE.l  d0,-(sp)            * copy to stack
00FF17AE  6100 F622               4703      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00FF17B2  619A                    4704      BSR.s       LAB_GTBY            * get byte parameter, result in d0 and Itemp
00FF17B4  205F                    4705      MOVEA.l (sp)+,a0            * pull address
00FF17B6  4E75                    4706      RTS
00FF17B8                          4707  
00FF17B8                          4708  
00FF17B8                          4709  *************************************************************************************
00FF17B8                          4710  *
00FF17B8                          4711  * get two parameters for DOKE or WAITW, first parameter in a0, second in d0
00FF17B8                          4712  
00FF17B8                          4713  LAB_GADW
00FF17B8  611E                    4714      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00FF17BA                          4715                              * address returned in d0 and on the stack
00FF17BA  6100 F616               4716      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00FF17BE  6100 F4A4               4717      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00FF17C2                          4718                              * else do type mismatch
00FF17C2  6100 F96C               4719      BSR     LAB_EVIR            * evaluate integer expression
00FF17C6                          4720                              * result in d0 and Itemp
00FF17C6  4840                    4721      SWAP        d0              * swap words
00FF17C8  4A40                    4722      TST.w       d0              * test high word
00FF17CA  6706                    4723      BEQ.s       LAB_XGADW           * exit if null
00FF17CC                          4724  
00FF17CC  5240                    4725      ADDQ.w  #1,d0               * increment word
00FF17CE  6600 E9C2               4726      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00FF17D2                          4727  
00FF17D2                          4728  LAB_XGADW
00FF17D2  4840                    4729      SWAP        d0              * swap words back
00FF17D4  205F                    4730      MOVEA.l (sp)+,a0            * pull address
00FF17D6  4E75                    4731      RTS
00FF17D8                          4732  
00FF17D8                          4733  
00FF17D8                          4734  *************************************************************************************
00FF17D8                          4735  *
00FF17D8                          4736  * get even address (for word or longword memory actions)
00FF17D8                          4737  * address returned in d0 and on the stack
00FF17D8                          4738  * does address error if the address is odd
00FF17D8                          4739  
00FF17D8                          4740  LAB_GEAD
00FF17D8  6100 F48A               4741      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00FF17DC                          4742                              * else do type mismatch
00FF17DC  6100 F952               4743      BSR     LAB_EVIR            * evaluate integer expression
00FF17E0                          4744                              * (does FC error not OF error if out of range)
00FF17E0  0800 0000               4745      BTST        #0,d0               * test low bit of longword
00FF17E4  6600 E968               4746      BNE     LAB_ADER            * if address is odd do address error/warm start
00FF17E8                          4747  
00FF17E8  2057                    4748      MOVEA.l (sp),a0         * copy return address
00FF17EA  2E80                    4749      MOVE.l  d0,(sp)         * even address on stack
00FF17EC  4ED0                    4750      JMP     (a0)                * effectively RTS
00FF17EE                          4751  
00FF17EE                          4752  
00FF17EE                          4753  *************************************************************************************
00FF17EE                          4754  *
00FF17EE                          4755  * perform PEEK()
00FF17EE                          4756  
00FF17EE                          4757  LAB_PEEK
00FF17EE  6100 F940               4758      BSR     LAB_EVIR            * evaluate integer expression
00FF17F2                          4759                              * (does FC error not OF error if out of range)
00FF17F2  2040                    4760      MOVEA.l d0,a0               * copy to address register
00FF17F4  1010                    4761      MOVE.b  (a0),d0         * get byte
00FF17F6  6000 FB0C               4762      BRA     LAB_1FD0            * convert d0 to unsigned byte in FAC1 & return
00FF17FA                          4763  
00FF17FA                          4764  
00FF17FA                          4765  *************************************************************************************
00FF17FA                          4766  *
00FF17FA                          4767  * perform POKE
00FF17FA                          4768  
00FF17FA                          4769  LAB_POKE
00FF17FA  61A8                    4770      BSR.s       LAB_GADB            * get two parameters for POKE or WAIT
00FF17FC                          4771                              * first parameter in a0, second in d0
00FF17FC  1080                    4772      MOVE.b  d0,(a0)         * put byte in memory
00FF17FE  4E75                    4773      RTS
00FF1800                          4774  
00FF1800                          4775  
00FF1800                          4776  *************************************************************************************
00FF1800                          4777  *
00FF1800                          4778  * perform DEEK()
00FF1800                          4779  
00FF1800                          4780  LAB_DEEK
00FF1800  6100 F92E               4781      BSR     LAB_EVIR            * evaluate integer expression
00FF1804                          4782                              * (does FC error not OF error if out of range)
00FF1804  E208                    4783      LSR.b       #1,d0               * shift bit 0 to carry
00FF1806  6500 E946               4784      BCS     LAB_ADER            * if address is odd do address error/warm start
00FF180A                          4785  
00FF180A  D000                    4786      ADD.b       d0,d0               * shift byte back
00FF180C  C188                    4787      EXG     d0,a0               * copy to address register
00FF180E  7000                    4788      MOVEQ       #0,d0               * clear top bits
00FF1810  3010                    4789      MOVE.w  (a0),d0         * get word
00FF1812  6000 FAD0               4790      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00FF1816                          4791  
00FF1816                          4792  
00FF1816                          4793  *************************************************************************************
00FF1816                          4794  *
00FF1816                          4795  * perform LEEK()
00FF1816                          4796  
00FF1816                          4797  LAB_LEEK
00FF1816  6100 F918               4798      BSR     LAB_EVIR            * evaluate integer expression
00FF181A                          4799                              * (does FC error not OF error if out of range)
00FF181A  E208                    4800      LSR.b       #1,d0               * shift bit 0 to carry
00FF181C  6500 E930               4801      BCS     LAB_ADER            * if address is odd do address error/warm start
00FF1820                          4802  
00FF1820  D000                    4803      ADD.b       d0,d0               * shift byte back
00FF1822  C188                    4804      EXG     d0,a0               * copy to address register
00FF1824  2010                    4805      MOVE.l  (a0),d0         * get longword
00FF1826  6000 FABC               4806      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00FF182A                          4807  
00FF182A                          4808  
00FF182A                          4809  *************************************************************************************
00FF182A                          4810  *
00FF182A                          4811  * perform DOKE
00FF182A                          4812  
00FF182A                          4813  LAB_DOKE
00FF182A  618C                    4814      BSR.s       LAB_GADW            * get two parameters for DOKE or WAIT
00FF182C                          4815                              * first parameter in a0, second in d0
00FF182C  3080                    4816      MOVE.w  d0,(a0)         * put word in memory
00FF182E  4E75                    4817      RTS
00FF1830                          4818  
00FF1830                          4819  
00FF1830                          4820  *************************************************************************************
00FF1830                          4821  *
00FF1830                          4822  * perform LOKE
00FF1830                          4823  
00FF1830                          4824  LAB_LOKE
00FF1830  61A6                    4825      BSR.s       LAB_GEAD            * get even address for word/long memory actions
00FF1832                          4826                              * address returned in d0 and on the stack
00FF1832  6100 F59E               4827      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00FF1836  6100 F42C               4828      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00FF183A                          4829                              * else do type mismatch
00FF183A  6100 F8F4               4830      BSR     LAB_EVIR            * evaluate integer value (no sign check)
00FF183E  205F                    4831      MOVEA.l (sp)+,a0            * pull address
00FF1840  2080                    4832      MOVE.l  d0,(a0)         * put longword in memory
00FF1842                          4833  RTS_015
00FF1842  4E75                    4834      RTS
00FF1844                          4835  
00FF1844                          4836  
00FF1844                          4837  *************************************************************************************
00FF1844                          4838  *
00FF1844                          4839  * perform SWAP
00FF1844                          4840  
00FF1844                          4841  LAB_SWAP
00FF1844  6100 F7AE               4842      BSR     LAB_GVAR            * get variable 1 address in a0
00FF1848  2F08                    4843      MOVE.l  a0,-(sp)            * save variable 1 address
00FF184A  182B 09B5               4844      MOVE.b  Dtypef(a3),d4       * copy variable 1 data type, $80=string,
00FF184E                          4845                              * $40=inetger, $00=float
00FF184E                          4846  
00FF184E  6100 F582               4847      BSR     LAB_1C01            * scan for ",", else do syntax error/warm start
00FF1852  6100 F7A0               4848      BSR     LAB_GVAR            * get variable 2 address in a0
00FF1856  245F                    4849      MOVEA.l (sp)+,a2            * restore variable 1 address
00FF1858  B82B 09B5               4850      CMP.b       Dtypef(a3),d4       * compare variable 1 data type with variable 2
00FF185C                          4851                              * data type
00FF185C  6600 E914               4852      BNE     LAB_TMER            * if not both the same type do "Type mismatch"
00FF1860                          4853                              * error then warm start
00FF1860                          4854  
00FF1860                          4855  * if you do want a non existant variable to return an error then leave the novar
00FF1860                          4856  * value at the top of this file set to zero
00FF1860                          4857  
00FF1860                 TRUE     4858   ifeq   novar
00FF1860                          4859  
00FF1860  2010                    4860      MOVE.l  (a0),d0         * get variable 2
00FF1862  20D2                    4861      MOVE.l  (a2),(a0)+          * copy variable 1 to variable 2
00FF1864  24C0                    4862      MOVE.l  d0,(a2)+            * save variable 2 to variable 1
00FF1866                          4863  
00FF1866  4A04                    4864      TST.b       d4              * check data type
00FF1868  6AD8                    4865      BPL.s       RTS_015         * exit if not string
00FF186A                          4866  
00FF186A  3010                    4867      MOVE.w  (a0),d0         * get string 2 length
00FF186C  3092                    4868      MOVE.w  (a2),(a0)           * copy string 1 length to string 2 length
00FF186E  3480                    4869      MOVE.w  d0,(a2)         * save string 2 length to string 1 length
00FF1870                          4870  
00FF1870                          4871   endc
00FF1870                          4872  
00FF1870                          4873  
00FF1870                          4874  * if you want a non existant variable to return a null value then set the novar
00FF1870                          4875  * value at the top of this file to some non zero value
00FF1870                          4876  
00FF1870                 FALSE    4877   ifne   novar
00FF1870                          4878                              * value get
00FF1870                          4879                              * value get and the new value save
00FF1870                          4880                              * new length save
00FF1870                          4881                              * new value save
00FF1870                          4882   endc
00FF1870                          4883  
00FF1870  4E75                    4884      RTS
00FF1872                          4885  
00FF1872                          4886  
00FF1872                          4887  *************************************************************************************
00FF1872                          4888  *
00FF1872                          4889  * perform USR
00FF1872                          4890  
00FF1872                          4891  LAB_USR
00FF1872  4EAB 0806               4892      JSR     Usrjmp(a3)          * do user vector
00FF1876  6000 F552               4893      BRA     LAB_1BFB            * scan for ")", else do syntax error/warm start
00FF187A                          4894  
00FF187A                          4895  
00FF187A                          4896  *************************************************************************************
00FF187A                          4897  *
00FF187A                          4898  * perform LOAD
00FF187A                          4899  
00FF187A                          4900  LAB_LOAD
00FF187A  4EEB 0818               4901      JMP     V_LOAD(a3)          * do the load vector 
00FF187E                          4902  
00FF187E                          4903  
00FF187E                          4904  *************************************************************************************
00FF187E                          4905  *
00FF187E                          4906  * perform SAVE
00FF187E                          4907  
00FF187E                          4908  LAB_SAVE
00FF187E  4EEB 081E               4909      JMP     V_SAVE(a3)          * do the save vector
00FF1882                          4910  
00FF1882                          4911  
00FF1882                          4912  *************************************************************************************
00FF1882                          4913  *
00FF1882                          4914  * perform CALL
00FF1882                          4915  
00FF1882                          4916  LAB_CALL
00FF1882  487A F55A               4917      PEA     LAB_GBYT(pc)        * put return address on stack
00FF1886  6100 FF50               4918      BSR     LAB_GEAD            * get even address for word/long memory actions
00FF188A                          4919                              * address returned in d0 and on the stack
00FF188A  4E75                    4920      RTS                     * effectively calls the routine
00FF188C                          4921  
00FF188C                          4922  * if the called routine exits correctly then it will return via the get byte routine.
00FF188C                          4923  * this will then get the next byte for the interpreter and return
00FF188C                          4924  
00FF188C                          4925  
00FF188C                          4926  *************************************************************************************
00FF188C                          4927  *
00FF188C                          4928  * perform WAIT
00FF188C                          4929  
00FF188C                          4930  LAB_WAIT
00FF188C  6100 FF16               4931      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00FF1890                          4932                              * first parameter in a0, second in d0
00FF1890  2F08                    4933      MOVE.l  a0,-(sp)            * save address
00FF1892  3F00                    4934      MOVE.w  d0,-(sp)            * save byte
00FF1894  7400                    4935      MOVEQ       #0,d2               * clear mask
00FF1896  6100 F546               4936      BSR     LAB_GBYT            * scan memory
00FF189A  6706                    4937      BEQ.s       LAB_2441            * skip if no third argument
00FF189C                          4938  
00FF189C  6100 F530               4939      BSR     LAB_SCGB            * scan for "," & get byte,
00FF18A0                          4940                              * else do syntax error/warm start
00FF18A0  2400                    4941      MOVE.l  d0,d2               * copy mask
00FF18A2                          4942  LAB_2441
00FF18A2  321F                    4943      MOVE.w  (sp)+,d1            * get byte
00FF18A4  205F                    4944      MOVEA.l (sp)+,a0            * get address
00FF18A6                          4945  LAB_2445
00FF18A6  1010                    4946      MOVE.b  (a0),d0         * read memory byte
00FF18A8  B500                    4947      EOR.b       d2,d0               * EOR with second argument (mask)
00FF18AA  C001                    4948      AND.b       d1,d0               * AND with first argument (byte)
00FF18AC  67F8                    4949      BEQ.s       LAB_2445            * loop if result is zero
00FF18AE                          4950  
00FF18AE  4E75                    4951      RTS
00FF18B0                          4952  
00FF18B0                          4953  *************************************************************************************
00FF18B0                          4954  * EASy68k extension function                                        *
00FF18B0                          4955  *************************************************************************************
00FF18B0                          4956  *
00FF18B0                          4957  * perform TI
00FF18B0                          4958  
00FF18B0                          4959  LAB_TI
00FF18B0                          4960      *MOVEQ      #8,d0               * get time
00FF18B0                          4961      *TRAP       #15             * do I/O function
00FF18B0                          4962      *MOVE.l d1,FAC1_m(a3)       * time (in 100ths seconds) into FAC1
00FF18B0                          4963      *MOVE.w #$A000,FAC1_e(a3)       * time exponent and sign
00FF18B0  6000 02B0               4964      BRA     LAB_24D5            * normalise FAC1 & return
00FF18B4                          4965  
00FF18B4                          4966  
00FF18B4                          4967  *************************************************************************************
00FF18B4                          4968  *
00FF18B4                          4969  * perform KEYS()
00FF18B4                          4970  
00FF18B4                          4971  LAB_KEYS
00FF18B4  4A2B 09B5               4972      TST.b       Dtypef(a3)          * test data type, $80=string, $40=integer,
00FF18B8                          4973                              * $00=float
00FF18B8  6B12                    4974      BMI.s       LAB_KESS            * branch if string
00FF18BA                          4975  
00FF18BA  6100 F874               4976      BSR     LAB_EVIR            * evaluate integer expression (no sign check)
00FF18BE                          4977                              * result in d0 and Itemp
00FF18BE                          4978  LAB_KEZZ
00FF18BE  2200                    4979      MOVE.l  d0,d1               * copy key value to parameter
00FF18C0                          4980  LAB_KETT
00FF18C0  103C 0013               4981      MOVE.b  #19,d0          * check for keypress
00FF18C4  4E4F                    4982      TRAP        #15
00FF18C6                          4983  
00FF18C6  2001                    4984      MOVE.l  d1,d0               * copy result
00FF18C8  6000 FA1A               4985      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00FF18CC                          4986  
00FF18CC                          4987  LAB_KESS
00FF18CC  6100 FD20               4988      BSR     LAB_22B6            * pop string off descriptor stack or from memory
00FF18D0                          4989                              * returns with d0 = length, a0 = pointer
00FF18D0  67EC                    4990      BEQ     LAB_KEZZ            * return last key if null string
00FF18D2                          4991  
00FF18D2  B07C 0005               4992      CMP.w       #5,d0               * compare length with max+1
00FF18D6  6502                    4993      BCS.s       LAB_KKSS            * branch if <= 4
00FF18D8                          4994  
00FF18D8  7004                    4995      MOVEQ       #4,d0               * else make = 4
00FF18DA                          4996  LAB_KKSS
00FF18DA  7200                    4997      MOVEQ       #0,d1               * clear parameter
00FF18DC  5340                    4998      SUBQ.w  #1,d0               * -1 for BF loop
00FF18DE                          4999  LAB_KSSS
00FF18DE  E181                    5000      ASL.l       #8,d1               * shift any previous characters along
00FF18E0  1218                    5001      MOVE.b  (a0)+,d1            * get byte from string
00FF18E2  51C8 FFFA               5002      DBF     d0,LAB_KSSS         * decrement count and loop if not done yet
00FF18E6                          5003  
00FF18E6  60D8                    5004      BRA.s       LAB_KETT            * go test the keys
00FF18E8                          5005  
00FF18E8                          5006  
00FF18E8                          5007  *************************************************************************************
00FF18E8                          5008  
00FF18E8                          5009  *************************************************************************************
00FF18E8                          5010  * EASy68k graphics extension function                               *
00FF18E8                          5011  *************************************************************************************
00FF18E8                          5012  *
00FF18E8                          5013  * perform POINT(X,Y) function
00FF18E8                          5014  
00FF18E8                          5015  LAB_FPOINT
00FF18E8  101D                    5016      MOVE.b  (a5)+,d0            * increment BASIC execute pointer
00FF18EA                          5017                              * fastest/shortest method
00FF18EA  7028                    5018      MOVEQ       #$28,d0         * load d0 with "("
00FF18EC  6100 F4E6               5019      BSR     LAB_SCCA            * scan for "(", else do syntax error/warm start
00FF18F0  611A                    5020      BSR.s       LAB_GTSW            * get X co-ordinate
00FF18F2  2F00                    5021      MOVE.l  d0,-(sp)            * save X co-ordinate
00FF18F4  6100 F4DC               5022      BSR     LAB_1C01            * scan for "," else do syntax error/warm start
00FF18F8  6112                    5023      BSR.s       LAB_GTSW            * get Y co-ordinate
00FF18FA  2F00                    5024      MOVE.l  d0,-(sp)            * save Y co-ordinate
00FF18FC  6100 F4CC               5025      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00FF1900  241F                    5026      MOVE.l  (sp)+,d2            * restore Y co-ordinate
00FF1902  221F                    5027      MOVE.l  (sp)+,d1            * restore X co-ordinate
00FF1904  7053                    5028      MOVEQ       #83,d0          * read pixel colour
00FF1906  4E4F                    5029      TRAP        #15             * do I/O function
00FF1908  6000 F9DA               5030      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & RET
00FF190C                          5031  
00FF190C                          5032  *************************************************************************************
00FF190C                          5033  * EASy68k graphics extension commands                               *
00FF190C                          5034  *************************************************************************************
00FF190C                          5035  
00FF190C                          5036  * get signed word parameter, result in d0 and Itemp
00FF190C                          5037  
00FF190C                          5038  LAB_GTSW
00FF190C  6100 F356               5039      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00FF1910                          5040                              * else do type mismatch
00FF1910  6100 F81E               5041      BSR     LAB_EVIR            * evaluate integer expression
00FF1914                          5042                              * result in d0 and Itemp
00FF1914                          5043  
00FF1914                          5044  
00FF1914                          5045  *************************************************************************************
00FF1914                          5046  *
00FF1914                          5047  * test signed word parameter in d0, must be -32769 < value < 32768
00FF1914                          5048  
00FF1914                          5049  LAB_EVSW
00FF1914  4840                    5050      SWAP        d0              * copy high word to low word
00FF1916  4A40                    5051      TST.w       d0              * set flags
00FF1918  6700 0008               5052      BEQ     LAB_ISWD            * branch if -1 < value < 32768
00FF191C                          5053  
00FF191C  5240                    5054      ADDQ.w  #1,d0               * else check $FFFF
00FF191E  6600 E872               5055      BNE     LAB_FCER            * if <> 0 do function call error/warm start
00FF1922                          5056  
00FF1922                          5057  LAB_ISWD
00FF1922  4840                    5058      SWAP        d0              * copy high word to low word
00FF1924  4E75                    5059      RTS
00FF1926                          5060  
00FF1926                          5061  
00FF1926                          5062  *************************************************************************************
00FF1926                          5063  *
00FF1926                          5064  * get graphics parameters, return count in d1.w
00FF1926                          5065  * numeric parameters are evaluated and stacked until the command end or an
00FF1926                          5066  * error is detected. the parameters are all long integers
00FF1926                          5067  
00FF1926                          5068  LAB_GGPR
00FF1926  7200                    5069      MOVEQ       #0,d1               * clear parameter count
00FF1928                          5070  LAB_GGLP
00FF1928  3F01                    5071      MOVE.w  d1,-(sp)            * save parameter count
00FF192A  6100 F338               5072      BSR     LAB_EVNM            * evaluate expression & check is numeric,
00FF192E                          5073                              * else do type mismatch
00FF192E  6100 F800               5074      BSR     LAB_EVIR            * evaluate integer expression
00FF1932                          5075                              * result in d0 and Itemp
00FF1932  321F                    5076      MOVE.w  (sp)+,d1            * get parameter count
00FF1934  2417                    5077      MOVE.l  (sp),d2         * copy return address
00FF1936  2E80                    5078      MOVE.l  d0,(sp)         * save parameter
00FF1938  2F02                    5079      MOVE.l  d2,-(sp)            * save return address
00FF193A  5241                    5080      ADDQ.w  #1,d1               * increment parameter count
00FF193C  6100 F4A0               5081      BSR     LAB_GBYT            * get BASIC byte
00FF1940  6700 0010               5082      BEQ     LAB_GGEX            * no more parameters so exit
00FF1944                          5083  
00FF1944  B03C 002C               5084      CMP.b       #',',d0         * check next byte is ","
00FF1948  6600 E854               5085      BNE     LAB_SNER            * do error if not
00FF194C                          5086  
00FF194C  6100 F48E               5087      BSR     LAB_IGBY            * increment & scan memory
00FF1950  60D6                    5088      BRA.s       LAB_GGLP            * go get next parameter
00FF1952                          5089  
00FF1952                          5090  LAB_GGEX
00FF1952  4E75                    5091      RTS
00FF1954                          5092  
00FF1954                          5093  
00FF1954                          5094  *************************************************************************************
00FF1954                          5095  *
00FF1954                          5096  * set line colour d0
00FF1954                          5097  
00FF1954                          5098  LAB_SLCO
00FF1954  3F01                    5099      MOVE.w  d1,-(sp)            * save parameter count
00FF1956  223C 00FFFFFF           5100      MOVE.l  #$FFFFFF,d1         * set mask
00FF195C  C280                    5101      AND.l       d0,d1               * and line colour
00FF195E  7050                    5102      MOVEQ       #80,d0          * set pen colour
00FF1960  4E4F                    5103      TRAP        #15             * do I/O function
00FF1962  321F                    5104      MOVE.w  (sp)+,d1            * get parameter count back
00FF1964  4E75                    5105      RTS
00FF1966                          5106  
00FF1966                          5107  
00FF1966                          5108  *************************************************************************************
00FF1966                          5109  *
00FF1966                          5110  * set fill colour d0
00FF1966                          5111  
00FF1966                          5112  LAB_SFCO
00FF1966  3F01                    5113      MOVE.w  d1,-(sp)            * save parameter count
00FF1968  223C 00FFFFFF           5114      MOVE.l  #$FFFFFF,d1         * set mask
00FF196E  C280                    5115      AND.l       d0,d1               * and line colour
00FF1970  7051                    5116      MOVEQ       #81,d0          * set pen colour
00FF1972  4E4F                    5117      TRAP        #15             * do I/O function
00FF1974  321F                    5118      MOVE.w  (sp)+,d1            * get parameter count back
00FF1976  4E75                    5119      RTS
00FF1978                          5120  
00FF1978                          5121  
00FF1978                          5122  *************************************************************************************
00FF1978                          5123  *
00FF1978                          5124  * perform LINE [[X1,Y1],X2,Y2][,][LINE_COLOUR]
00FF1978                          5125  
00FF1978                          5126  LAB_LINE
00FF1978  7055                    5127      MOVEQ       #85,d0          * default to draw line to X1,Y1
00FF197A  2F00                    5128      MOVE.l  d0,-(sp)            * set line type
00FF197C                          5129  
00FF197C  61A8                    5130      BSR     LAB_GGPR            * get graphics parameters, return count in d1.w
00FF197E  0801 0000               5131      BTST        #0,d1               * test parameter count
00FF1982  6700 000C               5132      BEQ     LAB_LNCO            * branch if no line colour parameter
00FF1986                          5133  
00FF1986  201F                    5134      MOVE.l  (sp)+,d0            * get line colour
00FF1988  61CA                    5135      BSR     LAB_SLCO            * go mask & set line colour
00FF198A  5341                    5136      SUBQ.w  #1,d1               * decrement parameter count
00FF198C  6700 00C0               5137      BEQ     LAB_SRTS            * exit if all done
00FF1990                          5138  
00FF1990                          5139                              * parameter count is always even here
00FF1990                          5140  LAB_LNCO
00FF1990  5541                    5141      SUBQ.w  #2,d1               * subtract 2 from parameter count
00FF1992  6700 00A4               5142      BEQ     LAB_S1XY            * go do line to X,Y if only two parameters left
00FF1996                          5143  
00FF1996  5541                    5144      SUBQ.w  #2,d1               * subtract 2 from parameter count
00FF1998  6600 E804               5145      BNE     LAB_SNER            * do error if there are other than two
00FF199C                          5146                              * parameters left
00FF199C                          5147  
00FF199C  7054                    5148      MOVEQ       #84,d0          * draw line from X1,Y1 to X2,Y2
00FF199E  3F40 0012               5149      MOVE.w  d0,$12(sp)          * set line type (write over line to X1,Y1 type)
00FF19A2  6000 0084               5150      BRA     LAB_S2XY            * go pop X1,Y1,X2,Y2 and do line
00FF19A6                          5151  
00FF19A6                          5152  
00FF19A6                          5153  *************************************************************************************
00FF19A6                          5154  *
00FF19A6                          5155  * perform MOVE X,Y
00FF19A6                          5156  
00FF19A6                          5157  LAB_MOVE
00FF19A6  7056                    5158      MOVEQ       #86,d0          * move to x,y
00FF19A8  2F00                    5159      MOVE.l  d0,-(sp)            * save pixel type
00FF19AA                          5160  
00FF19AA  6100 FF7A               5161      BSR     LAB_GGPR            * get graphics parameters, return count in d1.w
00FF19AE  6032                    5162      BRA.s       LAB_PNCE            * go check only two parameters and do move
00FF19B0                          5163  
00FF19B0                          5164  
00FF19B0                          5165  *************************************************************************************
00FF19B0                          5166  *
00FF19B0                          5167  * perform POINT [X,Y][,][LINE_COLOUR]
00FF19B0                          5168  
00FF19B0                          5169  LAB_POINT
00FF19B0  7052                    5170      MOVEQ       #82,d0          * set point
00FF19B2  6002                    5171      BRA.s       LAB_pixel           * go do pixel command
00FF19B4                          5172  
00FF19B4                          5173  
00FF19B4                          5174  *************************************************************************************
00FF19B4                          5175  *
00FF19B4                          5176  * perform FILL [X,Y][,][FILL_COLOUR]
00FF19B4                          5177  
00FF19B4                          5178  LAB_FILL
00FF19B4  7059                    5179      MOVEQ       #89,d0          * flood fill
00FF19B6                          5180  *   BRA.s       LAB_pixel           * go do pixel command
00FF19B6                          5181  
00FF19B6                          5182  * do POINT or FILL pixel based commands
00FF19B6                          5183  
00FF19B6                          5184  LAB_pixel
00FF19B6  2F00                    5185      MOVE.l  d0,-(sp)            * save pixel type
00FF19B8                          5186  
00FF19B8  6100 FF6C               5187      BSR     LAB_GGPR            * get graphics parameters, return count in d1.w
00FF19BC  0801 0000               5188      BTST        #0,d1               * test parameter count
00FF19C0  6700 0020               5189      BEQ     LAB_PNCE            * branch if no line colour parameter
00FF19C4                          5190  
00FF19C4  201F                    5191      MOVE.l  (sp)+,d0            * get line colour
00FF19C6  3401                    5192      MOVE.w  d1,d2               * copy count
00FF19C8  D442                    5193      ADD.w       d2,d2               * *2
00FF19CA  D442                    5194      ADD.w       d2,d2               * *4
00FF19CC  0837 0000 20FF          5195      BTST        #0,-1(sp,d2.w)      * test point or fill
00FF19D2  6704                    5196      BEQ.s       LAB_SELC            * branch if line
00FF19D4                          5197      
00FF19D4  6190                    5198      BSR     LAB_SFCO            * go mask & set fill colour
00FF19D6  6004                    5199      BRA.s       LAB_PNCO            * continue command
00FF19D8                          5200  
00FF19D8                          5201  LAB_SELC
00FF19D8  6100 FF7A               5202      BSR     LAB_SLCO            * go mask & set line colour
00FF19DC                          5203  LAB_PNCO
00FF19DC  5341                    5204      SUBQ.w  #1,d1               * decrement parameter count
00FF19DE  6700 006E               5205      BEQ     LAB_SRTS            * exit if all done
00FF19E2                          5206  
00FF19E2                          5207  LAB_PNCE
00FF19E2  5541                    5208      SUBQ.w  #2,d1               * subtract 2 from parameter count
00FF19E4  6600 E7B8               5209      BNE     LAB_SNER            * do error if there were other than two
00FF19E8                          5210                              * parameters left
00FF19E8                          5211  
00FF19E8  6000 004E               5212      BRA     LAB_S1XY            * go pop X,Y and do pixel command
00FF19EC                          5213  
00FF19EC                          5214  
00FF19EC                          5215  *************************************************************************************
00FF19EC                          5216  *
00FF19EC                          5217  * perform RECT [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
00FF19EC                          5218  
00FF19EC                          5219  LAB_RECT
00FF19EC  705A                    5220      MOVEQ       #90,d0          * draw unfilled rectangle
00FF19EE  600A                    5221      BRA.s       LAB_shape           * go do shape
00FF19F0                          5222  
00FF19F0                          5223  
00FF19F0                          5224  *************************************************************************************
00FF19F0                          5225  *
00FF19F0                          5226  * perform RECTF [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
00FF19F0                          5227  
00FF19F0                          5228  LAB_FRECT
00FF19F0  7057                    5229      MOVEQ       #87,d0          * draw filled rectangle
00FF19F2  6006                    5230      BRA.s       LAB_shape           * go do shape
00FF19F4                          5231  
00FF19F4                          5232  
00FF19F4                          5233  *************************************************************************************
00FF19F4                          5234  *
00FF19F4                          5235  * perform ELLIPSE [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
00FF19F4                          5236  
00FF19F4                          5237  LAB_ELLIPSE
00FF19F4  705B                    5238      MOVEQ       #91,d0          * draw unfilled ellipse
00FF19F6  6002                    5239      BRA.s       LAB_shape           * go do shape
00FF19F8                          5240  
00FF19F8                          5241  
00FF19F8                          5242  *************************************************************************************
00FF19F8                          5243  *
00FF19F8                          5244  * perform ELLIPSEF [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
00FF19F8                          5245  
00FF19F8                          5246  LAB_FELLIPSE
00FF19F8  7058                    5247      MOVEQ       #88,d0          * draw filled ellipse
00FF19FA                          5248  *   BRA.s       LAB_shape           * go do shape
00FF19FA                          5249  
00FF19FA                          5250  * this is the routine that does all the hard work for all the shape commands
00FF19FA                          5251  * the parameters are interpreted depending on their number. if there are four
00FF19FA                          5252  * parameters then they must be X1, Y1, X2 and Y2. if there are less or more
00FF19FA                          5253  * than four then LINE_COLOUR and/or FILL_COLOUR must be present
00FF19FA                          5254  
00FF19FA                          5255  LAB_shape
00FF19FA  2F00                    5256      MOVE.l  d0,-(sp)            * save shape type
00FF19FC                          5257  
00FF19FC  6100 FF28               5258      BSR     LAB_GGPR            * get graphics parameters, return count in d1.w
00FF1A00  5941                    5259      SUBQ.w  #4,d1               * subtract 4 from parameter count
00FF1A02  6700 0024               5260      BEQ     LAB_S2XY            * branch if there were 4 parameters
00FF1A06                          5261  
00FF1A06                          5262  * less or more than four then LINE_COLOUR and/or FILL_COLOUR must be present
00FF1A06                          5263  
00FF1A06  0801 0000               5264      BTST        #0,d1               * test parameter count
00FF1A0A  6600 000A               5265      BNE     LAB_SNFC            * branch if no fill colour parameter
00FF1A0E                          5266  
00FF1A0E                          5267  * even number so LINE_COLOUR and FILL_COLOUR must be present
00FF1A0E                          5268  
00FF1A0E  201F                    5269      MOVE.l  (sp)+,d0            * get fill colour
00FF1A10  6100 FF54               5270      BSR     LAB_SFCO            * go mask & set fill colour
00FF1A14  5341                    5271      SUBQ.w  #1,d1               * decrement parameter count
00FF1A16                          5272  LAB_SNFC
00FF1A16  201F                    5273      MOVE.l  (sp)+,d0            * get line colour
00FF1A18  6100 FF3A               5274      BSR     LAB_SLCO            * go mask & set line colour
00FF1A1C  5641                    5275      ADDQ.w  #3,d1               * decrement parameter count and add 4
00FF1A1E  6700 002E               5276      BEQ     LAB_SRTS            * exit if no more parameters
00FF1A22                          5277  
00FF1A22                          5278  * if there are any parameters left then they must be X1, Y1, X2 and Y2
00FF1A22                          5279  * if there are less or more than four then something is wrong
00FF1A22                          5280  
00FF1A22  5941                    5281      SUBQ.w  #4,d1               * subtract 4 from parameter count
00FF1A24  6600 E778               5282      BNE     LAB_SNER            * do error if wasn't 4 parameters
00FF1A28                          5283  
00FF1A28                          5284  * pull four parameters and do graphics command
00FF1A28                          5285  
00FF1A28                          5286  LAB_S2XY
00FF1A28  201F                    5287      MOVE.l  (sp)+,d0            * get Y2 off stack
00FF1A2A  6100 FEE8               5288      BSR     LAB_EVSW            * evaluate signed word in d0
00FF1A2E  2800                    5289      MOVE.l  d0,d4               * copy Y2 parameter
00FF1A30                          5290  
00FF1A30  201F                    5291      MOVE.l  (sp)+,d0            * get X2 off stack
00FF1A32  6100 FEE0               5292      BSR     LAB_EVSW            * evaluate signed word in d0
00FF1A36  2600                    5293      MOVE.l  d0,d3               * copy X2 parameter
00FF1A38                          5294  
00FF1A38                          5295  * pull two parameters and do graphics command
00FF1A38                          5296  
00FF1A38                          5297  LAB_S1XY
00FF1A38  201F                    5298      MOVE.l  (sp)+,d0            * get Y1 off stack
00FF1A3A  6100 FED8               5299      BSR     LAB_EVSW            * evaluate signed word in d0
00FF1A3E  2400                    5300      MOVE.l  d0,d2               * copy Y1 parameter
00FF1A40                          5301  
00FF1A40  201F                    5302      MOVE.l  (sp)+,d0            * get X1 off stack
00FF1A42  6100 FED0               5303      BSR     LAB_EVSW            * evaluate signed word in d0
00FF1A46  2200                    5304      MOVE.l  d0,d1               * copy X1 parameter
00FF1A48                          5305  
00FF1A48  201F                    5306      MOVE.l  (sp)+,d0            * draw line, pixel or shape
00FF1A4A  4E4F                    5307      TRAP        #15             * do I/O function
00FF1A4C  4E75                    5308      RTS
00FF1A4E                          5309  
00FF1A4E                          5310  LAB_SRTS
00FF1A4E  201F                    5311      MOVE.l  (sp)+,d0            * dump command
00FF1A50  4E75                    5312      RTS
00FF1A52                          5313  
00FF1A52                          5314  
00FF1A52                          5315  *************************************************************************************
00FF1A52                          5316  *
00FF1A52                          5317  * perform MODE m
00FF1A52                          5318  
00FF1A52                          5319  LAB_MODE
00FF1A52  6100 FCFA               5320      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00FF1A56  B03C 0012               5321      CMP.b       #$12,d0         * compare with max+1
00FF1A5A  6400 E736               5322      BCC     LAB_FCER            * if >= $10 go do function call error
00FF1A5E                          5323  
00FF1A5E  2200                    5324      MOVE.l  d0,d1               * copy it
00FF1A60  705C                    5325      MOVEQ       #92,d0          * set draw mode
00FF1A62  4E4F                    5326      TRAP        #15             * do I/O function
00FF1A64  4E75                    5327      RTS
00FF1A66                          5328  
00FF1A66                          5329  
00FF1A66                          5330  *************************************************************************************
00FF1A66                          5331  *
00FF1A66                          5332  * perform SIZE s
00FF1A66                          5333  
00FF1A66                          5334  LAB_SIZE
00FF1A66  6100 FCE6               5335      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00FF1A6A  2200                    5336      MOVE.l  d0,d1               * copy it
00FF1A6C  705D                    5337      MOVEQ       #93,d0          * set pen width
00FF1A6E  4E4F                    5338      TRAP        #15             * do I/O function
00FF1A70  4E75                    5339      RTS
00FF1A72                          5340  
00FF1A72                          5341  
00FF1A72                          5342  *************************************************************************************
00FF1A72                          5343  *
00FF1A72                          5344  * perform CURSOR X,Y
00FF1A72                          5345  
00FF1A72                          5346  LAB_CURSOR
00FF1A72  6100 FCDA               5347      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00FF1A76  B03C 0050               5348      CMP.b       #80,d0          * compare with max+1
00FF1A7A  6400 E716               5349      BCC     LAB_FCER            * if >= 80 go do function call error
00FF1A7E                          5350  
00FF1A7E  1740 09E5               5351      MOVE.b  d0,TPos(a3)         * set terminal position
00FF1A82  E140                    5352      ASL.w       #8,d0               * shift to high byte of word
00FF1A84  3F00                    5353      MOVE.w  d0,-(sp)            * save d0
00FF1A86                          5354  
00FF1A86  6100 F346               5355      BSR     LAB_SCGB            * scan for "," and get byte parameter, result
00FF1A8A                          5356                              * in d0 & Itemp
00FF1A8A                          5357  
00FF1A8A  B03C 0020               5358      CMP.b       #32,d0          * compare with max+1
00FF1A8E  6400 E702               5359      BCC     LAB_FCER            * if >= 32 go do function call error
00FF1A92                          5360  
00FF1A92  321F                    5361      MOVE.w  (sp)+,d1            * restore d1
00FF1A94  8240                    5362      OR.w        d0,d1               * OR row into low byte
00FF1A96                          5363  
00FF1A96  700B                    5364      MOVEQ       #11,d0          * cursor position
00FF1A98  4E4F                    5365      TRAP        #15             * do I/O function
00FF1A9A                          5366  
00FF1A9A  7000                    5367      MOVEQ       #0,d0               * set d0
00FF1A9C  D02B 09E5               5368      ADD.b       TPos(a3),d0         * get cursor x position
00FF1AA0  4A2B 09E6               5369      TST.b       TWidth(a3)          * test terminal width
00FF1AA4  660A                    5370      BNE.s       LAB_CRTS            * branch if not infinite line
00FF1AA6                          5371  
00FF1AA6                          5372  LAB_CDLP
00FF1AA6  902B 09E2               5373      SUB.b       TabSiz(a3),d0       * subtract tab size
00FF1AAA  64FA                    5374      BCC.s       LAB_CDLP            * loop while no borrow
00FF1AAC  D02B 09E2               5375      ADD.b       TabSiz(a3),d0       * add tab size back
00FF1AB0                          5376  LAB_CRTS
00FF1AB0  1740 09E5               5377      MOVE.b  d0,TPos(a3)         * set terminal position
00FF1AB4  4E75                    5378      RTS
00FF1AB6                          5379  
00FF1AB6                          5380  
00FF1AB6                          5381  *************************************************************************************
00FF1AB6                          5382  *
00FF1AB6                          5383  * perform BUFFER
00FF1AB6                          5384  
00FF1AB6                          5385  LAB_BUFFER
00FF1AB6  6600 E6E6               5386      BNE     LAB_SNER            * do syntax error if following byte
00FF1ABA                          5387  
00FF1ABA  705E                    5388      MOVEQ       #94,d0          * copy buffer to screen
00FF1ABC  4E4F                    5389      TRAP        #15             * do I/O function
00FF1ABE                          5390  
00FF1ABE  4E75                    5391      RTS
00FF1AC0                          5392  
00FF1AC0                          5393  
00FF1AC0                          5394  *************************************************************************************
00FF1AC0                          5395  *
00FF1AC0                          5396  * perform CLS
00FF1AC0                          5397  
00FF1AC0                          5398  LAB_CLS
00FF1AC0  6600 E6DC               5399      BNE     LAB_SNER            * do syntax error if following byte
00FF1AC4                          5400  
00FF1AC4  323C FF00               5401      MOVE.w  #$FF00,d1           * set for clear screen
00FF1AC8  1741 09E5               5402      MOVE.b  d1,TPos(a3)         * clear terminal position
00FF1ACC  700B                    5403      MOVEQ       #11,d0          * cursor position
00FF1ACE  4E4F                    5404      TRAP        #15             * do I/O function
00FF1AD0                          5405  
00FF1AD0  4E75                    5406      RTS
00FF1AD2                          5407  
00FF1AD2                          5408  
00FF1AD2                          5409  *************************************************************************************
00FF1AD2                          5410  * end of EASy68k graphics extension commands                            *
00FF1AD2                          5411  *************************************************************************************
00FF1AD2                          5412  
00FF1AD2                          5413  *************************************************************************************
00FF1AD2                          5414  *
00FF1AD2                          5415  * perform subtraction, FAC1 from FAC2
00FF1AD2                          5416  
00FF1AD2                          5417  LAB_SUBTRACT
00FF1AD2  0A2B 0080 0995          5418      EORI.b  #$80,FAC1_s(a3)     * complement FAC1 sign
00FF1AD8  176B 099D 099E          5419      MOVE.b  FAC2_s(a3),FAC_sc(a3)   * copy FAC2 sign byte
00FF1ADE                          5420  
00FF1ADE  102B 0995               5421      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign byte
00FF1AE2  B12B 099E               5422      EOR.b       d0,FAC_sc(a3)       * EOR with FAC2 sign
00FF1AE6                          5423  
00FF1AE6                          5424  
00FF1AE6                          5425  *************************************************************************************
00FF1AE6                          5426  *
00FF1AE6                          5427  * add FAC2 to FAC1
00FF1AE6                          5428  
00FF1AE6                          5429  LAB_ADD
00FF1AE6  102B 0994               5430      MOVE.b  FAC1_e(a3),d0       * get exponent
00FF1AEA  6700 0338               5431      BEQ     LAB_279B            * FAC1 was zero so copy FAC2 to FAC1 & return
00FF1AEE                          5432  
00FF1AEE                          5433                              * FAC1 is non zero
00FF1AEE  41EB 0998               5434      LEA     FAC2_m(a3),a0       * set pointer1 to FAC2 mantissa
00FF1AF2  102B 099C               5435      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00FF1AF6  6746                    5436      BEQ.s       RTS_016         * exit if zero
00FF1AF8                          5437  
00FF1AF8  902B 0994               5438      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
00FF1AFC  6722                    5439      BEQ.s       LAB_24A8            * branch if = (go add mantissa)
00FF1AFE                          5440  
00FF1AFE  650A                    5441      BCS.s       LAB_249C            * branch if FAC2 < FAC1
00FF1B00                          5442  
00FF1B00                          5443                              * FAC2 > FAC1
00FF1B00  376B 099C 0994          5444      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy sign and exponent of FAC2
00FF1B06  4400                    5445      NEG.b       d0              * negate exponent difference (make diff -ve)
00FF1B08  5148                    5446      SUBQ.w  #8,a0               * pointer1 to FAC1 
00FF1B0A                          5447  LAB_249C
00FF1B0A  4400                    5448      NEG.b       d0              * negate exponent difference (make diff +ve)
00FF1B0C  2F01                    5449      MOVE.l  d1,-(sp)            * save d1
00FF1B0E  B03C 0020               5450      CMP.b       #32,d0          * compare exponent diff with 32
00FF1B12  6D04                    5451      BLT.s       LAB_2467            * branch if range >= 32
00FF1B14                          5452  
00FF1B14  7200                    5453      MOVEQ       #0,d1               * clear d1
00FF1B16  6004                    5454      BRA.s       LAB_2468            * go clear smaller mantissa
00FF1B18                          5455  
00FF1B18                          5456  LAB_2467
00FF1B18  2210                    5457      MOVE.l  (a0),d1         * get FACx mantissa
00FF1B1A  E0A9                    5458      LSR.l       d0,d1               * shift d0 times right
00FF1B1C                          5459  LAB_2468
00FF1B1C  2081                    5460      MOVE.l  d1,(a0)         * save it back
00FF1B1E  221F                    5461      MOVE.l  (sp)+,d1            * restore d1
00FF1B20                          5462  
00FF1B20                          5463                              * exponents are equal now do mantissa add or
00FF1B20                          5464                              * subtract
00FF1B20                          5465  LAB_24A8
00FF1B20  4A2B 099E               5466      TST.b       FAC_sc(a3)          * test sign compare (FAC1 EOR FAC2)
00FF1B24  6B1A                    5467      BMI.s       LAB_24F8            * if <> go do subtract
00FF1B26                          5468  
00FF1B26  202B 0998               5469      MOVE.l  FAC2_m(a3),d0       * get FAC2 mantissa
00FF1B2A  D0AB 0990               5470      ADD.l       FAC1_m(a3),d0       * add FAC1 mantissa
00FF1B2E  640A                    5471      BCC.s       LAB_24F7            * save and exit if no carry (FAC1 is normal)
00FF1B30                          5472  
00FF1B30  E290                    5473      ROXR.l  #1,d0               * else shift carry back into mantissa
00FF1B32  522B 0994               5474      ADDQ.b  #1,FAC1_e(a3)       * increment FAC1 exponent
00FF1B36  6500 E656               5475      BCS     LAB_OFER            * if carry do overflow error & warm start
00FF1B3A                          5476  
00FF1B3A                          5477  LAB_24F7
00FF1B3A  2740 0990               5478      MOVE.l  d0,FAC1_m(a3)       * save mantissa
00FF1B3E                          5479  RTS_016
00FF1B3E  4E75                    5480      RTS
00FF1B40                          5481                              * signs are different
00FF1B40                          5482  LAB_24F8
00FF1B40  43EB 0990               5483      LEA     FAC1_m(a3),a1       * pointer 2 to FAC1
00FF1B44  B3C8                    5484      CMPA.l  a0,a1               * compare pointers
00FF1B46  6602                    5485      BNE.s       LAB_24B4            * branch if <>
00FF1B48                          5486  
00FF1B48  5049                    5487      ADDQ.w  #8,a1               * else pointer2 to FAC2
00FF1B4A                          5488  
00FF1B4A                          5489                              * take smaller from bigger (take sign of bigger)
00FF1B4A                          5490  LAB_24B4
00FF1B4A  2011                    5491      MOVE.l  (a1),d0         * get larger mantissa
00FF1B4C  2210                    5492      MOVE.l  (a0),d1         * get smaller mantissa
00FF1B4E  2740 0990               5493      MOVE.l  d0,FAC1_m(a3)       * save larger mantissa
00FF1B52  93AB 0990               5494      SUB.l       d1,FAC1_m(a3)       * subtract smaller
00FF1B56                          5495  
00FF1B56                          5496  
00FF1B56                          5497  *************************************************************************************
00FF1B56                          5498  *
00FF1B56                          5499  * do +/- (carry is sign) & normalise FAC1
00FF1B56                          5500  
00FF1B56                          5501  LAB_24D0
00FF1B56  640A                    5502      BCC.s       LAB_24D5            * branch if result is +ve
00FF1B58                          5503  
00FF1B58                          5504                              * erk! subtract is the wrong way round so
00FF1B58                          5505                              * negate everything
00FF1B58  0A2B 00FF 0995          5506      EORI.b  #$FF,FAC1_s(a3)     * complement FAC1 sign
00FF1B5E  44AB 0990               5507      NEG.l       FAC1_m(a3)          * negate FAC1 mantissa
00FF1B62                          5508  
00FF1B62                          5509  
00FF1B62                          5510  *************************************************************************************
00FF1B62                          5511  *
00FF1B62                          5512  * normalise FAC1
00FF1B62                          5513  
00FF1B62                          5514  LAB_24D5
00FF1B62  202B 0990               5515      MOVE.l  FAC1_m(a3),d0       * get mantissa
00FF1B66  6B2E                    5516      BMI.s       LAB_24DA            * mantissa is normal so just exit
00FF1B68                          5517  
00FF1B68  6606                    5518      BNE.s       LAB_24D9            * mantissa is not zero so go normalise FAC1
00FF1B6A                          5519  
00FF1B6A  3740 0994               5520      MOVE.w  d0,FAC1_e(a3)       * else make FAC1 = +zero
00FF1B6E  4E75                    5521      RTS
00FF1B70                          5522  
00FF1B70                          5523  LAB_24D9
00FF1B70  2F01                    5524      MOVE.l  d1,-(sp)            * save d1
00FF1B72  2200                    5525      MOVE.l  d0,d1               * mantissa to d1
00FF1B74  7000                    5526      MOVEQ       #0,d0               * clear d0
00FF1B76  102B 0994               5527      MOVE.b  FAC1_e(a3),d0       * get exponent byte
00FF1B7A  6714                    5528      BEQ.s       LAB_24D8            * if exponent is zero then clean up and exit
00FF1B7C                          5529  LAB_24D6
00FF1B7C  D281                    5530      ADD.l       d1,d1               * shift mantissa, ADD is quicker for a single
00FF1B7E                          5531                              * shift
00FF1B7E  5BC8 FFFC               5532      DBMI        d0,LAB_24D6         * decrement exponent and loop if mantissa and
00FF1B82                          5533                              * exponent +ve
00FF1B82                          5534  
00FF1B82  4A40                    5535      TST.w       d0              * test exponent
00FF1B84  670A                    5536      BEQ.s       LAB_24D8            * if exponent is zero make FAC1 zero
00FF1B86                          5537  
00FF1B86  6A02                    5538      BPL.s       LAB_24D7            * if exponent is >zero go save FAC1
00FF1B88                          5539  
00FF1B88  7001                    5540      MOVEQ       #1,d0               * else set for zero after correction
00FF1B8A                          5541  LAB_24D7
00FF1B8A  5300                    5542      SUBQ.b  #1,d0               * adjust exponent for loop
00FF1B8C  2741 0990               5543      MOVE.l  d1,FAC1_m(a3)       * save normalised mantissa
00FF1B90                          5544  LAB_24D8
00FF1B90  221F                    5545      MOVE.l  (sp)+,d1            * restore d1
00FF1B92  1740 0994               5546      MOVE.b  d0,FAC1_e(a3)       * save corrected exponent
00FF1B96                          5547  LAB_24DA
00FF1B96  4E75                    5548      RTS
00FF1B98                          5549  
00FF1B98                          5550  
00FF1B98                          5551  *************************************************************************************
00FF1B98                          5552  *
00FF1B98                          5553  * perform LOG()
00FF1B98                          5554  
00FF1B98                          5555  LAB_LOG
00FF1B98  4A2B 0995               5556      TST.b       FAC1_s(a3)          * test sign
00FF1B9C  6B00 E5F4               5557      BMI     LAB_FCER            * if -ve do function call error/warm start
00FF1BA0                          5558  
00FF1BA0  7E00                    5559      MOVEQ       #0,d7               * clear d7
00FF1BA2  1747 099E               5560      MOVE.b  d7,FAC_sc(a3)       * clear sign compare
00FF1BA6  1E2B 0994               5561      MOVE.b  FAC1_e(a3),d7       * get exponent
00FF1BAA  6700 E5E6               5562      BEQ     LAB_FCER            * if 0 do function call error/warm start
00FF1BAE                          5563  
00FF1BAE  0487 00000081           5564      SUB.l       #$81,d7         * normalise exponent
00FF1BB4  177C 0081 0994          5565      MOVE.b  #$81,FAC1_e(a3)     * force a value between 1 and 2
00FF1BBA  2C2B 0990               5566      MOVE.l  FAC1_m(a3),d6       * copy mantissa
00FF1BBE                          5567  
00FF1BBE  277C 80000000 0998      5568      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
00FF1BC6  377C 8100 099C          5569      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
00FF1BCC  6100 FF18               5570      BSR     LAB_ADD         * find arg+1
00FF1BD0  7000                    5571      MOVEQ       #0,d0               * setup for calc skip
00FF1BD2  3740 099C               5572      MOVE.w  d0,FAC2_e(a3)       * set FAC1 for zero result
00FF1BD6  DC86                    5573      ADD.l       d6,d6               * shift 1 bit out
00FF1BD8  2746 0998               5574      MOVE.l  d6,FAC2_m(a3)       * put back FAC2
00FF1BDC  6758                    5575      BEQ.s       LAB_LONN            * if 0 skip calculation
00FF1BDE                          5576  
00FF1BDE  377C 8000 099C          5577      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for .5
00FF1BE4  6100 0130               5578      BSR     LAB_DIVIDE          * do (arg-1)/(arg+1)
00FF1BE8  4A2B 0994               5579      TST.b       FAC1_e(a3)          * test exponent
00FF1BEC  6748                    5580      BEQ.s       LAB_LONN            * if 0 skip calculation
00FF1BEE                          5581  
00FF1BEE  122B 0994               5582      MOVE.b  FAC1_e(a3),d1       * get exponent
00FF1BF2  0401 0082               5583      SUB.b       #$82,d1         * normalise and two integer bits
00FF1BF6  4401                    5584      NEG.b       d1              * negate for shift
00FF1BF8                          5585  **  CMP.b       #$1F,d1         * will mantissa vanish?
00FF1BF8                          5586  **  BGT.s       LAB_dunno           * if so do ???
00FF1BF8                          5587  
00FF1BF8  202B 0990               5588      MOVE.l  FAC1_m(a3),d0       * get mantissa
00FF1BFC  E2A8                    5589      LSR.l       d1,d0               * shift in two integer bits
00FF1BFE                          5590  
00FF1BFE                          5591  * d0 = arg
00FF1BFE                          5592  * d0 = x, d1 = y
00FF1BFE                          5593  * d2 = x1, d3 = y1
00FF1BFE                          5594  * d4 = shift count
00FF1BFE                          5595  * d5 = loop count
00FF1BFE                          5596  * d6 = z
00FF1BFE                          5597  * a0 = table pointer
00FF1BFE                          5598  
00FF1BFE  7C00                    5599      MOVEQ       #0,d6               * z = 0
00FF1C00  223C 40000000           5600      MOVE.l  #1<<30,d1           * y = 1
00FF1C06  41FA 1400               5601      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic tangent table
00FF1C0A  7A1E                    5602      MOVEQ       #30,d5          * loop 31 times
00FF1C0C  7801                    5603      MOVEQ       #1,d4               * set shift count
00FF1C0E  6006                    5604      BRA.s       LAB_LOCC            * entry point for loop
00FF1C10                          5605  
00FF1C10                          5606  LAB_LAAD
00FF1C10  E8A2                    5607      ASR.l       d4,d2               * x1 >> i
00FF1C12  9282                    5608      SUB.l       d2,d1               * y = y - x1
00FF1C14  DC90                    5609      ADD.l       (a0),d6         * z = z + tanh(i)
00FF1C16                          5610  LAB_LOCC
00FF1C16  2400                    5611      MOVE.l  d0,d2               * x1 = x
00FF1C18  2601                    5612      MOVE.l  d1,d3               * y1 = Y
00FF1C1A  E8A3                    5613      ASR.l       d4,d3               * y1 >> i
00FF1C1C  6402                    5614      BCC.s       LAB_LOLP
00FF1C1E                          5615  
00FF1C1E  5283                    5616      ADDQ.l  #1,d3
00FF1C20                          5617  LAB_LOLP
00FF1C20  9083                    5618      SUB.l       d3,d0               * x = x - y1
00FF1C22  6AEC                    5619      BPL.s       LAB_LAAD            * branch if > 0
00FF1C24                          5620  
00FF1C24  2002                    5621      MOVE.l  d2,d0               * get x back
00FF1C26  5848                    5622      ADDQ.w  #4,a0               * next entry
00FF1C28  5284                    5623      ADDQ.l  #1,d4               * next i
00FF1C2A  E28B                    5624      LSR.l       #1,d3               * /2
00FF1C2C  6704                    5625      BEQ.s       LAB_LOCX            * branch y1 = 0
00FF1C2E                          5626  
00FF1C2E  51CD FFF0               5627      DBF     d5,LAB_LOLP         * decrement and loop if not done
00FF1C32                          5628  
00FF1C32                          5629                              * now sort out the result
00FF1C32                          5630  LAB_LOCX
00FF1C32  DC86                    5631      ADD.l       d6,d6               * *2
00FF1C34  2006                    5632      MOVE.l  d6,d0               * setup for d7 = 0
00FF1C36                          5633  LAB_LONN
00FF1C36  2800                    5634      MOVE.l  d0,d4               * save cordic result
00FF1C38  7A00                    5635      MOVEQ       #0,d5               * set default exponent sign
00FF1C3A  4A87                    5636      TST.l       d7              * check original exponent sign
00FF1C3C  6716                    5637      BEQ.s       LAB_LOXO            * branch if original was 0
00FF1C3E                          5638  
00FF1C3E  6A04                    5639      BPL.s       LAB_LOXP            * branch if was +ve
00FF1C40                          5640  
00FF1C40  4487                    5641      NEG.l       d7              * make original exponent +ve
00FF1C42  7A80                    5642      MOVEQ       #$80-$100,d5        * make sign -ve
00FF1C44                          5643  LAB_LOXP
00FF1C44  1745 0995               5644      MOVE.b  d5,FAC1_s(a3)       * save original exponent sign
00FF1C48  4847                    5645      SWAP        d7              * 16 bit shift
00FF1C4A  E18F                    5646      LSL.l       #8,d7               * easy first part
00FF1C4C  7A88                    5647      MOVEQ       #$88-$100,d5        * start with byte
00FF1C4E                          5648  LAB_LONE
00FF1C4E  5385                    5649      SUBQ.l  #1,d5               * decrement exponent
00FF1C50  DE87                    5650      ADD.l       d7,d7               * shift mantissa
00FF1C52  6AFA                    5651      BPL.s       LAB_LONE            * loop if not normal
00FF1C54                          5652  
00FF1C54                          5653  LAB_LOXO
00FF1C54  2747 0990               5654      MOVE.l  d7,FAC1_m(a3)       * save original exponent as mantissa
00FF1C58  1745 0994               5655      MOVE.b  d5,FAC1_e(a3)       * save exponent for this
00FF1C5C  277C B17217F8 0998      5656      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
00FF1C64  377C 8000 099C          5657      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
00FF1C6A  176B 0995 099E          5658      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make sign compare = FAC1 sign
00FF1C70  6118                    5659      BSR.s       LAB_MULTIPLY        * do multiply
00FF1C72  2744 0998               5660      MOVE.l  d4,FAC2_m(a3)       * save cordic result
00FF1C76  6710                    5661      BEQ.s       LAB_LOWZ            * branch if zero
00FF1C78                          5662  
00FF1C78  377C 8200 099C          5663      MOVE.w  #$8200,FAC2_e(a3)       * set exponent & sign
00FF1C7E  176B 0995 099E          5664      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * clear sign compare
00FF1C84  6100 FE60               5665      BSR     LAB_ADD         * and add for final result
00FF1C88                          5666  
00FF1C88                          5667  LAB_LOWZ
00FF1C88  4E75                    5668      RTS
00FF1C8A                          5669  
00FF1C8A                          5670  
00FF1C8A                          5671  *************************************************************************************
00FF1C8A                          5672  *
00FF1C8A                          5673  * multiply FAC1 by FAC2
00FF1C8A                          5674  
00FF1C8A                          5675  LAB_MULTIPLY
00FF1C8A  48E7 F800               5676      MOVEM.l d0-d4,-(sp)         * save registers
00FF1C8E  4A2B 0994               5677      TST.b       FAC1_e(a3)          * test FAC1 exponent
00FF1C92  6776                    5678      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
00FF1C94                          5679  
00FF1C94  102B 099C               5680      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00FF1C98  6770                    5681      BEQ.s       LAB_MUUF            * if exponent zero go make result zero
00FF1C9A                          5682  
00FF1C9A  176B 099E 0995          5683      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare becomes sign
00FF1CA0                          5684  
00FF1CA0  D02B 0994               5685      ADD.b       FAC1_e(a3),d0       * multiply exponents by adding
00FF1CA4  640A                    5686      BCC.s       LAB_MNOC            * branch if no carry
00FF1CA6                          5687  
00FF1CA6  0400 0080               5688      SUB.b       #$80,d0         * normalise result
00FF1CAA  6400 E4E2               5689      BCC     LAB_OFER            * if no carry do overflow
00FF1CAE                          5690  
00FF1CAE  6006                    5691      BRA.s       LAB_MADD            * branch
00FF1CB0                          5692  
00FF1CB0                          5693                              * no carry for exponent add
00FF1CB0                          5694  LAB_MNOC
00FF1CB0  0400 0080               5695      SUB.b       #$80,d0         * normalise result
00FF1CB4  6554                    5696      BCS.s       LAB_MUUF            * return zero if underflow
00FF1CB6                          5697  
00FF1CB6                          5698  LAB_MADD
00FF1CB6  1740 0994               5699      MOVE.b  d0,FAC1_e(a3)       * save exponent
00FF1CBA                          5700  
00FF1CBA                          5701                              * d1 (FAC1) x d2 (FAC2)
00FF1CBA  222B 0990               5702      MOVE.l  FAC1_m(a3),d1       * get FAC1 mantissa
00FF1CBE  242B 0998               5703      MOVE.l  FAC2_m(a3),d2       * get FAC2 mantissa
00FF1CC2                          5704  
00FF1CC2  3801                    5705      MOVE.w  d1,d4               * copy low word FAC1
00FF1CC4  2001                    5706      MOVE.l  d1,d0               * copy long word FAC1
00FF1CC6  4840                    5707      SWAP        d0              * high word FAC1 to low word FAC1
00FF1CC8  3600                    5708      MOVE.w  d0,d3               * copy high word FAC1
00FF1CCA                          5709  
00FF1CCA  C2C2                    5710      MULU        d2,d1               * low word FAC2 x low word FAC1
00FF1CCC  C0C2                    5711      MULU        d2,d0               * low word FAC2 x high word FAC1
00FF1CCE  4842                    5712      SWAP        d2              * high word FAC2 to low word FAC2
00FF1CD0  C8C2                    5713      MULU        d2,d4               * high word FAC2 x low word FAC1
00FF1CD2  C6C2                    5714      MULU        d2,d3               * high word FAC2 x high word FAC1
00FF1CD4                          5715  
00FF1CD4                          5716  * done multiply, now add partial products
00FF1CD4                          5717  
00FF1CD4                          5718  *           d1 =                    aaaa  ----  FAC2_L x FAC1_L
00FF1CD4                          5719  *           d0 =                bbbb  aaaa      FAC2_L x FAC1_H
00FF1CD4                          5720  *           d4 =                bbbb  aaaa      FAC2_H x FAC1_L
00FF1CD4                          5721  *           d3 =            cccc  bbbb          FAC2_H x FAC1_H
00FF1CD4                          5722  *           product =       mmmm  mmmm
00FF1CD4                          5723  
00FF1CD4  0681 00008000           5724      ADD.L       #$8000,d1           * round up lowest word
00FF1CDA  4241                    5725      CLR.w       d1              * clear low word, don't need it
00FF1CDC  4841                    5726      SWAP        d1              * align high word
00FF1CDE  D280                    5727      ADD.l       d0,d1               * add FAC2_L x FAC1_H (can't be carry)
00FF1CE0                          5728  LAB_MUF1
00FF1CE0  D284                    5729      ADD.l       d4,d1               * now add intermediate (FAC2_H x FAC1_L)
00FF1CE2  6406                    5730      BCC.s       LAB_MUF2            * branch if no carry
00FF1CE4                          5731  
00FF1CE4  0683 00010000           5732      ADD.l       #$10000,d3          * else correct result
00FF1CEA                          5733  LAB_MUF2
00FF1CEA  0681 00008000           5734      ADD.l       #$8000,d1           * round up low word
00FF1CF0  4241                    5735      CLR.w       d1              * clear low word
00FF1CF2  4841                    5736      SWAP        d1              * align for final add
00FF1CF4  D283                    5737      ADD.l       d3,d1               * add FAC2_H x FAC1_H, result
00FF1CF6  6B08                    5738      BMI.s       LAB_MUF3            * branch if normalisation not needed
00FF1CF8                          5739  
00FF1CF8  D281                    5740      ADD.l       d1,d1               * shift mantissa
00FF1CFA  532B 0994               5741      SUBQ.b  #1,FAC1_e(a3)       * adjust exponent
00FF1CFE  670A                    5742      BEQ.s       LAB_MUUF            * branch if underflow
00FF1D00                          5743  
00FF1D00                          5744  LAB_MUF3
00FF1D00  2741 0990               5745      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00FF1D04                          5746  LAB_MUEX
00FF1D04  4CDF 001F               5747      MOVEM.l (sp)+,d0-d4         * restore registers
00FF1D08  4E75                    5748      RTS
00FF1D0A                          5749                              * either zero or underflow result
00FF1D0A                          5750  LAB_MUUF
00FF1D0A  7000                    5751      MOVEQ       #0,d0               * quick clear
00FF1D0C  2740 0990               5752      MOVE.l  d0,FAC1_m(a3)       * clear mantissa
00FF1D10  3740 0994               5753      MOVE.w  d0,FAC1_e(a3)       * clear sign and exponent
00FF1D14  60EE                    5754      BRA.s       LAB_MUEX            * restore regs & exit
00FF1D16                          5755  
00FF1D16                          5756  
00FF1D16                          5757  *************************************************************************************
00FF1D16                          5758  *
00FF1D16                          5759  * do FAC2/FAC1, result in FAC1
00FF1D16                          5760  * fast hardware divide version
00FF1D16                          5761  
00FF1D16                          5762  LAB_DIVIDE
00FF1D16  2F07                    5763      MOVE.l  d7,-(sp)            * save d7
00FF1D18  7000                    5764      MOVEQ       #0,d0               * clear FAC2 exponent
00FF1D1A  2400                    5765      MOVE.l  d0,d2               * clear FAC1 exponent
00FF1D1C                          5766  
00FF1D1C  142B 0994               5767      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
00FF1D20  6700 E458               5768      BEQ     LAB_DZER            * if zero go do /0 error
00FF1D24                          5769  
00FF1D24  102B 099C               5770      MOVE.b  FAC2_e(a3),d0       * get FAC2 exponent
00FF1D28  6766                    5771      BEQ.s       LAB_DIV0            * if zero return zero
00FF1D2A                          5772  
00FF1D2A  9042                    5773      SUB.w       d2,d0               * get result exponent by subtracting
00FF1D2C  0640 0080               5774      ADD.w       #$80,d0         * correct 16 bit exponent result
00FF1D30                          5775  
00FF1D30  176B 099E 0995          5776      MOVE.b  FAC_sc(a3),FAC1_s(a3)   * sign compare is result sign
00FF1D36                          5777  
00FF1D36                          5778  * now to do 32/32 bit mantissa divide
00FF1D36                          5779  
00FF1D36  422B 099F               5780      CLR.b       flag(a3)            * clear 'flag' byte
00FF1D3A  262B 0990               5781      MOVE.l  FAC1_m(a3),d3       * get FAC1 mantissa
00FF1D3E  282B 0998               5782      MOVE.l  FAC2_m(a3),d4       * get FAC2 mantissa
00FF1D42  B883                    5783      CMP.l       d3,d4               * compare FAC2 with FAC1 mantissa
00FF1D44  6744                    5784      BEQ.s       LAB_MAN1            * set mantissa result = 1 if equal
00FF1D46                          5785  
00FF1D46  6506                    5786      BCS.s       AC1gtAC2            * branch if FAC1 > FAC2
00FF1D48                          5787  
00FF1D48  9883                    5788      SUB.l       d3,d4               * subtract FAC1 from FAC2, result now must be <1
00FF1D4A  562B 099F               5789      ADDQ.b  #3,flag(a3)         * FAC2>FAC1 so set 'flag' byte
00FF1D4E                          5790  AC1gtAC2
00FF1D4E  6146                    5791      BSR.s       LAB_32_16           * do 32/16 divide
00FF1D50  4841                    5792      SWAP        d1              * move 16 bit result to high word
00FF1D52  2802                    5793      MOVE.l  d2,d4               * copy remainder longword
00FF1D54  6142                    5794      BSR.s       LAB_3216            * do 32/16 divide again (skip copy d4 to d2)
00FF1D56  84C5                    5795      DIVU.w  d5,d2               * now divide remainder to make guard word
00FF1D58  1E2B 099F               5796      MOVE.b  flag(a3),d7         * now normalise, get flag byte back
00FF1D5C  6708                    5797      BEQ.s       LAB_DIVX            * skip add if null
00FF1D5E                          5798  
00FF1D5E                          5799  * else result was >1 so we need to add 1 to result mantissa and adjust exponent
00FF1D5E                          5800  
00FF1D5E  E20F                    5801      LSR.b       #1,d7               * shift 1 into eXtend
00FF1D60  E291                    5802      ROXR.l  #1,d1               * shift extend result >>
00FF1D62  E252                    5803      ROXR.w  #1,d2               * shift extend guard word >>
00FF1D64  5200                    5804      ADDQ.b  #1,d0               * adjust exponent
00FF1D66                          5805  
00FF1D66                          5806  * now round result to 32 bits
00FF1D66                          5807  
00FF1D66                          5808  LAB_DIVX
00FF1D66  D442                    5809      ADD.w       d2,d2               * guard bit into eXtend bit
00FF1D68  6408                    5810      BCC.s       L_DIVRND            * branch if guard=0
00FF1D6A                          5811  
00FF1D6A  5281                    5812      ADDQ.l  #1,d1               * add guard to mantissa
00FF1D6C  6404                    5813      BCC.s       L_DIVRND            * branch if no overflow
00FF1D6E                          5814  
00FF1D6E                          5815  LAB_SET1
00FF1D6E  E291                    5816      ROXR.l  #1,d1               * shift extend result >>
00FF1D70  5240                    5817      ADDQ.w  #1,d0               * adjust exponent
00FF1D72                          5818  
00FF1D72                          5819                              * test for over/under flow
00FF1D72                          5820  L_DIVRND
00FF1D72  3600                    5821      MOVE.w  d0,d3               * copy exponent
00FF1D74  6B1A                    5822      BMI.s       LAB_DIV0            * if -ve return zero
00FF1D76                          5823  
00FF1D76  0243 FF00               5824      ANDI.w  #$FF00,d3           * mask word high byte
00FF1D7A  6600 E412               5825      BNE     LAB_OFER            * branch if overflow
00FF1D7E                          5826  
00FF1D7E                          5827                              * move result into FAC1
00FF1D7E                          5828  LAB_XDIV
00FF1D7E  2E1F                    5829      MOVE.l  (sp)+,d7            * restore d7
00FF1D80  1740 0994               5830      MOVE.b  d0,FAC1_e(a3)       * save result exponent
00FF1D84  2741 0990               5831      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
00FF1D88  4E75                    5832      RTS
00FF1D8A                          5833  
00FF1D8A                          5834  * FAC1 mantissa = FAC2 mantissa so set result mantissa
00FF1D8A                          5835  
00FF1D8A                          5836  LAB_MAN1
00FF1D8A  7201                    5837      MOVEQ       #1,d1               * set bit
00FF1D8C  E2A9                    5838      LSR.l       d1,d1               * bit into eXtend
00FF1D8E  60DE                    5839      BRA.s       LAB_SET1            * set mantissa, adjust exponent and exit
00FF1D90                          5840  
00FF1D90                          5841  * result is zero
00FF1D90                          5842  
00FF1D90                          5843  LAB_DIV0
00FF1D90  7000                    5844      MOVEQ       #0,d0               * zero exponent & sign
00FF1D92  2200                    5845      MOVE.l  d0,d1               * zero mantissa
00FF1D94  60E8                    5846      BRA     LAB_XDIV            * exit divide
00FF1D96                          5847  
00FF1D96                          5848  * divide 16 bits into 32, AB/Ex
00FF1D96                          5849  *
00FF1D96                          5850  * d4            AAAA    BBBB            * 32 bit numerator
00FF1D96                          5851  * d3            EEEE    xxxx            * 16 bit denominator
00FF1D96                          5852  *
00FF1D96                          5853  * returns -
00FF1D96                          5854  *
00FF1D96                          5855  * d1            xxxx    DDDD            * 16 bit result
00FF1D96                          5856  * d2                HHHH    IIII        * 32 bit remainder
00FF1D96                          5857  
00FF1D96                          5858  LAB_32_16
00FF1D96  2404                    5859      MOVE.l  d4,d2               * copy FAC2 mantissa        (AB)
00FF1D98                          5860  LAB_3216
00FF1D98  2A03                    5861      MOVE.l  d3,d5               * copy FAC1 mantissa        (EF)
00FF1D9A  4245                    5862      CLR.w       d5              * clear low word d1     (Ex)
00FF1D9C  4845                    5863      SWAP        d5              * swap high word to low word    (xE)
00FF1D9E                          5864  
00FF1D9E                          5865  * d3            EEEE    FFFF            * denominator copy
00FF1D9E                          5866  * d5        0000    EEEE                * denominator high word
00FF1D9E                          5867  * d2            AAAA    BBBB            * numerator copy
00FF1D9E                          5868  * d4            AAAA    BBBB            * numerator
00FF1D9E                          5869  
00FF1D9E  88C5                    5870      DIVU.w  d5,d4               * do FAC2/FAC1 high word    (AB/E)
00FF1DA0  6802                    5871      BVC.s       LAB_LT_1            * if no overflow DIV was ok
00FF1DA2                          5872  
00FF1DA2  78FF                    5873      MOVEQ       #-1,d4          * else set default value
00FF1DA4                          5874  
00FF1DA4                          5875  ; done the divide, now check the result, we have ...
00FF1DA4                          5876  
00FF1DA4                          5877  * d3            EEEE    FFFF            * denominator copy
00FF1DA4                          5878  * d5        0000    EEEE                * denominator high word
00FF1DA4                          5879  * d2            AAAA    BBBB            * numerator copy
00FF1DA4                          5880  * d4            MMMM    DDDD            * result MOD and DIV
00FF1DA4                          5881  
00FF1DA4                          5882  LAB_LT_1
00FF1DA4  3C04                    5883      MOVE.w  d4,d6               * copy 16 bit result
00FF1DA6  3204                    5884      MOVE.w  d4,d1               * copy 16 bit result again
00FF1DA8                          5885  
00FF1DA8                          5886  * we now have ..
00FF1DA8                          5887  * d3            EEEE    FFFF            * denominator copy
00FF1DA8                          5888  * d5        0000    EEEE                * denominator high word
00FF1DA8                          5889  * d6            xxxx  DDDD          * result DIV copy
00FF1DA8                          5890  * d1            xxxx  DDDD          * result DIV copy
00FF1DA8                          5891  * d2            AAAA    BBBB            * numerator copy
00FF1DA8                          5892  * d4            MMMM    DDDD            * result MOD and DIV
00FF1DA8                          5893  
00FF1DA8                          5894  * now multiply out 32 bit denominator by 16 bit result
00FF1DA8                          5895  * QRS = AB*D
00FF1DA8                          5896  
00FF1DA8  CCC3                    5897      MULU.w  d3,d6               * FFFF * DDDD =       rrrr  SSSS
00FF1DAA  C8C5                    5898      MULU.w  d5,d4               * EEEE * DDDD = QQQQ  rrrr
00FF1DAC                          5899  
00FF1DAC                          5900  * we now have ..
00FF1DAC                          5901  * d3            EEEE    FFFF            * denominator copy
00FF1DAC                          5902  * d5        0000    EEEE                * denominator high word
00FF1DAC                          5903  * d6                rrrr  SSSS      * 48 bit result partial low
00FF1DAC                          5904  * d1            xxxx  DDDD          * result DIV copy
00FF1DAC                          5905  * d2            AAAA    BBBB            * numerator copy
00FF1DAC                          5906  * d4            QQQQ    rrrr            * 48 bit result partial
00FF1DAC                          5907  
00FF1DAC  3E06                    5908      MOVE.w  d6,d7               * copy low word of low multiply
00FF1DAE                          5909  
00FF1DAE                          5910  * d7                xxxx    SSSS        * 48 bit result partial low
00FF1DAE                          5911  
00FF1DAE  4246                    5912      CLR.w       d6              * clear low word of low multiply
00FF1DB0  4846                    5913      SWAP        d6              * high word of low multiply to low word
00FF1DB2                          5914  
00FF1DB2                          5915  * d6            0000    rrrr            * high word of 48 bit result partial low
00FF1DB2                          5916  
00FF1DB2  D886                    5917      ADD.l       d6,d4
00FF1DB4                          5918  
00FF1DB4                          5919  * d4            QQQQ    RRRR            * 48 bit result partial high longword
00FF1DB4                          5920  
00FF1DB4  7C00                    5921      MOVEQ       #0,d6               * clear to extend numerator to 48 bits
00FF1DB6                          5922  
00FF1DB6                          5923  * now do GHI = AB0 - QRS (which is the remainder)
00FF1DB6                          5924  
00FF1DB6  9C47                    5925      SUB.w       d7,d6               * low word subtract
00FF1DB8                          5926  
00FF1DB8                          5927  * d6                xxxx    IIII        * remainder low word
00FF1DB8                          5928  
00FF1DB8  9584                    5929      SUBX.l  d4,d2               * high longword subtract
00FF1DBA                          5930  
00FF1DBA                          5931  * d2            GGGG    HHHH            * remainder high longword
00FF1DBA                          5932  
00FF1DBA                          5933  * now if we got the divide correct then the remainder high longword will be +ve
00FF1DBA                          5934  
00FF1DBA  6A08                    5935      BPL.s       L_DDIV          * branch if result is ok (<needed)
00FF1DBC                          5936  
00FF1DBC                          5937  * remainder was -ve so DDDD is too big
00FF1DBC                          5938  
00FF1DBC                          5939  LAB_REMM
00FF1DBC  5341                    5940      SUBQ.w  #1,d1               * adjust DDDD
00FF1DBE                          5941  
00FF1DBE                          5942  * d3                xxxx    FFFF        * denominator copy
00FF1DBE                          5943  * d6                xxxx    IIII        * remainder low word
00FF1DBE                          5944  
00FF1DBE  DC43                    5945      ADD.w       d3,d6               * add EF*1 low remainder low word
00FF1DC0                          5946  
00FF1DC0                          5947  * d5            0000    EEEE            * denominator high word
00FF1DC0                          5948  * d2            GGGG    HHHH            * remainder high longword
00FF1DC0                          5949  
00FF1DC0  D585                    5950      ADDX.l  d5,d2               * add extend EF*1 to remainder high longword
00FF1DC2  6BF8                    5951      BMI.s       LAB_REMM            * loop if result still too big
00FF1DC4                          5952  
00FF1DC4                          5953  * all done and result correct or <
00FF1DC4                          5954  
00FF1DC4                          5955  L_DDIV
00FF1DC4  4842                    5956      SWAP        d2              * remainder mid word to high word
00FF1DC6                          5957  
00FF1DC6                          5958  * d2            HHHH    GGGG            * (high word /should/ be $0000)
00FF1DC6                          5959  
00FF1DC6  3406                    5960      MOVE.w  d6,d2               * remainder in high word
00FF1DC8                          5961  
00FF1DC8                          5962  * d2                HHHH    IIII        * now is 32 bit remainder
00FF1DC8                          5963  * d1            xxxx    DDDD            * 16 bit result
00FF1DC8                          5964  
00FF1DC8  4E75                    5965      RTS
00FF1DCA                          5966  
00FF1DCA                          5967  
00FF1DCA                          5968  *************************************************************************************
00FF1DCA                          5969  *
00FF1DCA                          5970  * unpack memory (a0) into FAC1
00FF1DCA                          5971  
00FF1DCA                          5972  LAB_UFAC
00FF1DCA  2010                    5973      MOVE.l  (a0),d0         * get packed value
00FF1DCC  4840                    5974      SWAP        d0              * exponent and sign into least significant word
00FF1DCE  3740 0994               5975      MOVE.w  d0,FAC1_e(a3)       * save exponent and sign
00FF1DD2  6708                    5976      BEQ.s       LAB_NB1T            * branch if exponent (and the rest) zero
00FF1DD4                          5977  
00FF1DD4  807C 0080               5978      OR.w        #$80,d0         * set MSb
00FF1DD8  4840                    5979      SWAP        d0              * word order back to normal
00FF1DDA  E180                    5980      ASL.l       #8,d0               * shift exponent & clear guard byte
00FF1DDC                          5981  LAB_NB1T
00FF1DDC  2740 0990               5982      MOVE.l  d0,FAC1_m(a3)       * move into FAC1
00FF1DE0                          5983  
00FF1DE0  102B 0994               5984      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00FF1DE4  4E75                    5985      RTS
00FF1DE6                          5986  
00FF1DE6                          5987  
00FF1DE6                          5988  *************************************************************************************
00FF1DE6                          5989  *
00FF1DE6                          5990  * set numeric variable, pack FAC1 into Lvarpl
00FF1DE6                          5991  
00FF1DE6                          5992  LAB_PFAC
00FF1DE6  2F08                    5993      MOVE.l  a0,-(sp)            * save pointer
00FF1DE8  206B 0872               5994      MOVEA.l Lvarpl(a3),a0       * get destination pointer
00FF1DEC  082B 0006 09B5          5995      BTST        #6,Dtypef(a3)       * test data type
00FF1DF2  670C                    5996      BEQ.s       LAB_277C            * branch if floating
00FF1DF4                          5997  
00FF1DF4  6100 00C6               5998      BSR     LAB_2831            * convert FAC1 floating to fixed
00FF1DF8                          5999                              * result in d0 and Itemp
00FF1DF8  2080                    6000      MOVE.l  d0,(a0)         * save in var
00FF1DFA  205F                    6001      MOVE.l  (sp)+,a0            * restore pointer
00FF1DFC  4E75                    6002      RTS
00FF1DFE                          6003  
00FF1DFE                          6004  
00FF1DFE                          6005  *************************************************************************************
00FF1DFE                          6006  *
00FF1DFE                          6007  * normalise round and pack FAC1 into (a0)
00FF1DFE                          6008  
00FF1DFE                          6009  LAB_2778
00FF1DFE  2F08                    6010      MOVE.l  a0,-(sp)            * save pointer
00FF1E00                          6011  LAB_277C
00FF1E00  6100 FD60               6012      BSR     LAB_24D5            * normalise FAC1
00FF1E04  612C                    6013      BSR.s       LAB_27BA            * round FAC1
00FF1E06  202B 0990               6014      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
00FF1E0A  E098                    6015      ROR.l       #8,d0               * align 24/32 bit mantissa
00FF1E0C  4840                    6016      SWAP        d0              * exponent/sign into 0-15
00FF1E0E  C07C 007F               6017      AND.w       #$7F,d0         * clear exponent and sign bit
00FF1E12  022B 0080 0995          6018      ANDI.b  #$80,FAC1_s(a3)     * clear non sign bits in sign
00FF1E18  806B 0994               6019      OR.w        FAC1_e(a3),d0       * OR in exponent and sign
00FF1E1C  4840                    6020      SWAP        d0              * move exponent and sign back to 16-31
00FF1E1E  2080                    6021      MOVE.l  d0,(a0)         * store in destination
00FF1E20  205F                    6022      MOVE.l  (sp)+,a0            * restore pointer
00FF1E22  4E75                    6023      RTS
00FF1E24                          6024  
00FF1E24                          6025  
00FF1E24                          6026  *************************************************************************************
00FF1E24                          6027  *
00FF1E24                          6028  * copy FAC2 to FAC1
00FF1E24                          6029  
00FF1E24                          6030  LAB_279B
00FF1E24  376B 099C 0994          6031      MOVE.w  FAC2_e(a3),FAC1_e(a3)   * copy exponent & sign
00FF1E2A  276B 0998 0990          6032      MOVE.l  FAC2_m(a3),FAC1_m(a3)   * copy mantissa
00FF1E30  4E75                    6033      RTS
00FF1E32                          6034  
00FF1E32                          6035  
00FF1E32                          6036  *************************************************************************************
00FF1E32                          6037  *
00FF1E32                          6038  * round FAC1
00FF1E32                          6039  
00FF1E32                          6040  LAB_27BA
00FF1E32  102B 0994               6041      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00FF1E36  6720                    6042      BEQ.s       LAB_27C4            * branch if zero
00FF1E38                          6043  
00FF1E38  202B 0990               6044      MOVE.l  FAC1_m(a3),d0       * get FAC1
00FF1E3C  0680 00000080           6045      ADD.l       #$80,d0         * round to 24 bit
00FF1E42  640A                    6046      BCC.s       LAB_27C3            * branch if no overflow
00FF1E44                          6047  
00FF1E44  E290                    6048      ROXR.l  #1,d0               * shift FAC1 mantissa
00FF1E46  522B 0994               6049      ADDQ.b  #1,FAC1_e(a3)       * correct exponent
00FF1E4A  6500 E342               6050      BCS     LAB_OFER            * if carry do overflow error & warm start
00FF1E4E                          6051  
00FF1E4E                          6052  LAB_27C3
00FF1E4E  C03C 0000               6053      AND.b       #$00,d0         * clear guard byte
00FF1E52  2740 0990               6054      MOVE.l  d0,FAC1_m(a3)       * save back to FAC1
00FF1E56  4E75                    6055      RTS
00FF1E58                          6056  
00FF1E58                          6057  LAB_27C4
00FF1E58  1740 0995               6058      MOVE.b  d0,FAC1_s(a3)       * make zero always +ve
00FF1E5C                          6059  RTS_017
00FF1E5C  4E75                    6060      RTS
00FF1E5E                          6061  
00FF1E5E                          6062  
00FF1E5E                          6063  *************************************************************************************
00FF1E5E                          6064  *
00FF1E5E                          6065  * get FAC1 sign
00FF1E5E                          6066  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00FF1E5E                          6067  
00FF1E5E                          6068  LAB_27CA
00FF1E5E  7000                    6069      MOVEQ       #0,d0               * clear d0
00FF1E60  102B 0994               6070      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00FF1E64  67F6                    6071      BEQ.s       RTS_017         * exit if zero (already correct SGN(0)=0)
00FF1E66                          6072  
00FF1E66                          6073  
00FF1E66                          6074  *************************************************************************************
00FF1E66                          6075  *
00FF1E66                          6076  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00FF1E66                          6077  * no = 0 check
00FF1E66                          6078  
00FF1E66                          6079  LAB_27CE
00FF1E66  102B 0995               6080      MOVE.b  FAC1_s(a3),d0       * else get FAC1 sign (b7)
00FF1E6A                          6081  
00FF1E6A                          6082  
00FF1E6A                          6083  *************************************************************************************
00FF1E6A                          6084  *
00FF1E6A                          6085  * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00FF1E6A                          6086  * no = 0 check, sign in d0
00FF1E6A                          6087  
00FF1E6A                          6088  LAB_27D0
00FF1E6A  4880                    6089      EXT.w       d0              * make word
00FF1E6C  48C0                    6090      EXT.l       d0              * make longword
00FF1E6E  E080                    6091      ASR.l       #8,d0               * move sign bit through byte to carry
00FF1E70  65EA                    6092      BCS.s       RTS_017         * exit if carry set
00FF1E72                          6093  
00FF1E72  7001                    6094      MOVEQ       #1,d0               * set result for +ve sign
00FF1E74  4E75                    6095      RTS
00FF1E76                          6096  
00FF1E76                          6097  
00FF1E76                          6098  *************************************************************************************
00FF1E76                          6099  *
00FF1E76                          6100  * perform SGN()
00FF1E76                          6101  
00FF1E76                          6102  LAB_SGN
00FF1E76  61E6                    6103      BSR.s       LAB_27CA            * get FAC1 sign
00FF1E78                          6104                              * return d0=-1/-ve d0=+1/+ve
00FF1E78                          6105  
00FF1E78                          6106  
00FF1E78                          6107  *************************************************************************************
00FF1E78                          6108  *
00FF1E78                          6109  * save d0 as integer longword
00FF1E78                          6110  
00FF1E78                          6111  LAB_27DB
00FF1E78  2740 0990               6112      MOVE.l  d0,FAC1_m(a3)       * save FAC1 mantissa
00FF1E7C  377C A000 0994          6113      MOVE.w  #$A000,FAC1_e(a3)       * set FAC1 exponent & sign
00FF1E82  D080                    6114      ADD.l       d0,d0               * top bit into carry
00FF1E84  6000 FCD0               6115      BRA     LAB_24D0            * do +/- (carry is sign) & normalise FAC1
00FF1E88                          6116  
00FF1E88                          6117  
00FF1E88                          6118  *************************************************************************************
00FF1E88                          6119  *
00FF1E88                          6120  * perform ABS()
00FF1E88                          6121  
00FF1E88                          6122  LAB_ABS
00FF1E88  177C 0000 0995          6123      MOVE.b  #0,FAC1_s(a3)       * clear FAC1 sign
00FF1E8E  4E75                    6124      RTS
00FF1E90                          6125  
00FF1E90                          6126  
00FF1E90                          6127  *************************************************************************************
00FF1E90                          6128  *
00FF1E90                          6129  * compare FAC1 with FAC2
00FF1E90                          6130  * returns d0=+1 Cb=0 if FAC1 > FAC2
00FF1E90                          6131  * returns d0= 0 Cb=0 if FAC1 = FAC2
00FF1E90                          6132  * returns d0=-1 Cb=1 if FAC1 < FAC2
00FF1E90                          6133  
00FF1E90                          6134  LAB_27FA
00FF1E90  122B 099C               6135      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
00FF1E94  67C8                    6136      BEQ.s       LAB_27CA            * branch if FAC2 exponent=0 & get FAC1 sign
00FF1E96                          6137                              * d0=-1,C=1/-ve d0=+1,C=0/+ve
00FF1E96                          6138  
00FF1E96  102B 099E               6139      MOVE.b  FAC_sc(a3),d0       * get FAC sign compare
00FF1E9A  6BCA                    6140      BMI.s       LAB_27CE            * if signs <> do return d0=-1,C=1/-ve
00FF1E9C                          6141                              * d0=+1,C=0/+ve & return
00FF1E9C                          6142  
00FF1E9C  102B 0995               6143      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00FF1EA0  B22B 0994               6144      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
00FF1EA4  660A                    6145      BNE.s       LAB_2828            * branch if different
00FF1EA6                          6146  
00FF1EA6  222B 0998               6147      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
00FF1EAA  B2AB 0990               6148      CMP.l       FAC1_m(a3),d1       * compare mantissas
00FF1EAE  6708                    6149      BEQ.s       LAB_282F            * exit if mantissas equal
00FF1EB0                          6150  
00FF1EB0                          6151  * gets here if number <> FAC1
00FF1EB0                          6152  
00FF1EB0                          6153  LAB_2828
00FF1EB0  65B8                    6154      BCS.s       LAB_27D0            * if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
00FF1EB2                          6155                              * C=0/+ve
00FF1EB2                          6156  
00FF1EB2  0A00 0080               6157      EORI.b  #$80,d0         * else toggle FAC1 sign
00FF1EB6                          6158  LAB_282E
00FF1EB6  60B2                    6159      BRA.s       LAB_27D0            * return d0=-1,C=1/-ve d0=+1,C=0/+ve
00FF1EB8                          6160  
00FF1EB8                          6161  LAB_282F
00FF1EB8  7000                    6162      MOVEQ       #0,d0               * clear result
00FF1EBA  4E75                    6163      RTS
00FF1EBC                          6164  
00FF1EBC                          6165  
00FF1EBC                          6166  *************************************************************************************
00FF1EBC                          6167  *
00FF1EBC                          6168  * convert FAC1 floating to fixed
00FF1EBC                          6169  * result in d0 and Itemp, sets flags correctly
00FF1EBC                          6170  
00FF1EBC                          6171  LAB_2831
00FF1EBC  202B 0990               6172      MOVE.l  FAC1_m(a3),d0       * copy mantissa
00FF1EC0  6732                    6173      BEQ.s       LAB_284J            * branch if mantissa = 0
00FF1EC2                          6174  
00FF1EC2  2F01                    6175      MOVE.l  d1,-(sp)            * save d1
00FF1EC4  72A0                    6176      MOVEQ       #$A0,d1         * set for no floating bits
00FF1EC6  922B 0994               6177      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent
00FF1ECA  6500 E2C2               6178      BCS     LAB_OFER            * do overflow if too big
00FF1ECE                          6179  
00FF1ECE  660E                    6180      BNE.s       LAB_284G            * branch if exponent was not $A0
00FF1ED0                          6181  
00FF1ED0  4A2B 0995               6182      TST.b       FAC1_s(a3)          * test FAC1 sign
00FF1ED4  6A1C                    6183      BPL.s       LAB_284H            * branch if FAC1 +ve
00FF1ED6                          6184  
00FF1ED6  4480                    6185      NEG.l       d0
00FF1ED8  6918                    6186      BVS.s       LAB_284H            * branch if was $80000000
00FF1EDA                          6187  
00FF1EDA  6000 E2B2               6188      BRA     LAB_OFER            * do overflow if too big
00FF1EDE                          6189  
00FF1EDE                          6190  LAB_284G
00FF1EDE  B23C 0020               6191      CMP.b       #$20,d1         * compare with minimum result for integer
00FF1EE2  6500 0004               6192      BCS     LAB_284L            * if < minimum just do shift
00FF1EE6                          6193  
00FF1EE6  7000                    6194      MOVEQ       #0,d0               * else return zero
00FF1EE8                          6195  LAB_284L
00FF1EE8  E2A8                    6196      LSR.l       d1,d0               * shift integer
00FF1EEA                          6197  
00FF1EEA  4A2B 0995               6198      TST.b       FAC1_s(a3)          * test FAC1 sign (b7)
00FF1EEE  6A02                    6199      BPL.s       LAB_284H            * branch if FAC1 +ve
00FF1EF0                          6200  
00FF1EF0  4480                    6201      NEG.l       d0              * negate integer value
00FF1EF2                          6202  LAB_284H
00FF1EF2  221F                    6203      MOVE.l  (sp)+,d1            * restore d1
00FF1EF4                          6204  LAB_284J
00FF1EF4  2740 082A               6205      MOVE.l  d0,Itemp(a3)        * save the result
00FF1EF8  4E75                    6206      RTS
00FF1EFA                          6207  
00FF1EFA                          6208  
00FF1EFA                          6209  *************************************************************************************
00FF1EFA                          6210  *
00FF1EFA                          6211  * perform INT()
00FF1EFA                          6212  
00FF1EFA                          6213  LAB_INT
00FF1EFA  70A0                    6214      MOVEQ       #$A0,d0         * set for no floating bits
00FF1EFC  902B 0994               6215      SUB.b       FAC1_e(a3),d0       * subtract FAC1 exponent
00FF1F00  6310                    6216      BLS.s       LAB_IRTS            * exit if exponent >= $A0
00FF1F02                          6217                              * (too big for fraction part!)
00FF1F02                          6218  
00FF1F02  B03C 0020               6219      CMP.b       #$20,d0         * compare with minimum result for integer
00FF1F06  6400 025E               6220      BCC     LAB_POZE            * if >= minimum go return 0
00FF1F0A                          6221                              * (too small for integer part!)
00FF1F0A                          6222  
00FF1F0A  72FF                    6223      MOVEQ       #-1,d1          * set integer mask
00FF1F0C  E1A1                    6224      ASL.l       d0,d1               * shift mask [8+2*d0]
00FF1F0E  C3AB 0990               6225      AND.l       d1,FAC1_m(a3)       * mask mantissa
00FF1F12                          6226  LAB_IRTS
00FF1F12  4E75                    6227      RTS
00FF1F14                          6228  
00FF1F14                          6229  
00FF1F14                          6230  *************************************************************************************
00FF1F14                          6231  *
00FF1F14                          6232  * print " in line [LINE #]"
00FF1F14                          6233  
00FF1F14                          6234  LAB_2953
00FF1F14  41FA 188E               6235      LEA     LAB_LMSG(pc),a0     * point to " in line " message
00FF1F18  6100 EAF8               6236      BSR     LAB_18C3            * print null terminated string
00FF1F1C                          6237  
00FF1F1C                          6238                              * Print Basic line #
00FF1F1C  202B 0852               6239      MOVE.l  Clinel(a3),d0       * get current line
00FF1F20                          6240  
00FF1F20                          6241  
00FF1F20                          6242  *************************************************************************************
00FF1F20                          6243  *
00FF1F20                          6244  * print d0 as unsigned integer
00FF1F20                          6245  
00FF1F20                          6246  LAB_295E
00FF1F20  43FA 0DE8               6247      LEA     Bin2dec(pc),a1      * get table address
00FF1F24  7200                    6248      MOVEQ       #0,d1               * table index
00FF1F26  41EB 09CC               6249      LEA     Usdss(a3),a0        * output string start
00FF1F2A  2401                    6250      MOVE.l  d1,d2               * output string index
00FF1F2C                          6251  LAB_2967
00FF1F2C  2631 1000               6252      MOVE.l  (a1,d1.w),d3        * get table value
00FF1F30  6714                    6253      BEQ.s       LAB_2969            * exit if end marker
00FF1F32                          6254  
00FF1F32  782F                    6255      MOVEQ       #'0'-1,d4           * set character to "0"-1
00FF1F34                          6256  LAB_2968
00FF1F34  5244                    6257      ADDQ.w  #1,d4               * next numeric character
00FF1F36  9083                    6258      SUB.l       d3,d0               * subtract table value
00FF1F38  6AFA                    6259      BPL.s       LAB_2968            * not overdone so loop
00FF1F3A                          6260  
00FF1F3A  D083                    6261      ADD.l       d3,d0               * correct value
00FF1F3C  1184 2000               6262      MOVE.b  d4,(a0,d2.w)        * character out to string
00FF1F40  5841                    6263      ADDQ.w  #4,d1               * increment table pointer
00FF1F42  5242                    6264      ADDQ.w  #1,d2               * increment output string pointer
00FF1F44  60E6                    6265      BRA.s       LAB_2967            * loop
00FF1F46                          6266  
00FF1F46                          6267  LAB_2969
00FF1F46  0600 0030               6268      ADD.b       #'0',d0         * make last character
00FF1F4A  1180 2000               6269      MOVE.b  d0,(a0,d2.w)        * character out to string
00FF1F4E  5348                    6270      SUBQ.w  #1,a0               * decrement a0 (allow simple loop)
00FF1F50                          6271  
00FF1F50                          6272                              * now find non zero start of string
00FF1F50                          6273  LAB_296A
00FF1F50  5248                    6274      ADDQ.w  #1,a0               * increment a0 (this will never carry to b16)
00FF1F52  43EB 09D5               6275      LEA     BHsend-1(a3),a1     * get string end
00FF1F56  B1C9                    6276      CMPA.l  a1,a0               * are we at end
00FF1F58  6700 EAB8               6277      BEQ     LAB_18C3            * if so print null terminated string and RETURN
00FF1F5C                          6278  
00FF1F5C  0C10 0030               6279      CMPI.b  #'0',(a0)           * is character "0" ?
00FF1F60  67EE                    6280      BEQ.s       LAB_296A            * loop if so
00FF1F62                          6281  
00FF1F62  6000 EAAE               6282      BRA     LAB_18C3            * print null terminated string from memory & RET
00FF1F66                          6283  
00FF1F66                          6284  
00FF1F66                          6285  *************************************************************************************
00FF1F66                          6286  *
00FF1F66                          6287  * convert FAC1 to ASCII string result in (a0)
00FF1F66                          6288  * STR$() function enters here
00FF1F66                          6289  
00FF1F66                          6290  * now outputs 7 significant digits
00FF1F66                          6291  
00FF1F66                          6292  * d0 is character out
00FF1F66                          6293  * d1 is save index
00FF1F66                          6294  * d2 is gash
00FF1F66                          6295  
00FF1F66                          6296  * a0 is output string pointer
00FF1F66                          6297  
00FF1F66                          6298  LAB_2970
00FF1F66  43EB 09C6               6299      LEA     Decss(a3),a1        * set output string start
00FF1F6A                          6300  
00FF1F6A  7420                    6301      MOVEQ       #' ',d2         * character = " ", assume +ve
00FF1F6C  08AB 0007 0995          6302      BCLR.b  #7,FAC1_s(a3)       * test and clear FAC1 sign (b7)
00FF1F72  6702                    6303      BEQ.s       LAB_2978            * branch if +ve
00FF1F74                          6304  
00FF1F74  742D                    6305      MOVEQ       #'-',d2         * else character = "-"
00FF1F76                          6306  LAB_2978
00FF1F76  1282                    6307      MOVE.b  d2,(a1)         * save the sign character
00FF1F78  142B 0994               6308      MOVE.b  FAC1_e(a3),d2       * get FAC1 exponent
00FF1F7C  6608                    6309      BNE.s       LAB_2989            * branch if FAC1<>0
00FF1F7E                          6310  
00FF1F7E                          6311                              * exponent was $00 so FAC1 is 0
00FF1F7E  7030                    6312      MOVEQ       #'0',d0         * set character = "0"
00FF1F80  7201                    6313      MOVEQ       #1,d1               * set output string index
00FF1F82  6000 01A4               6314      BRA     LAB_2A89            * save last character, [EOT] & exit
00FF1F86                          6315  
00FF1F86                          6316                              * FAC1 is some non zero value
00FF1F86                          6317  LAB_2989
00FF1F86  177C 0000 09AC          6318      MOVE.b  #0,numexp(a3)       * clear number exponent count
00FF1F8C  B43C 0081               6319      CMP.b       #$81,d2         * compare FAC1 exponent with $81 (>1.00000)
00FF1F90                          6320  
00FF1F90  6448                    6321      BCC.s       LAB_299C            * branch if FAC1=>1
00FF1F92                          6322  
00FF1F92                          6323                              * else FAC1 < 1
00FF1F92  277C 98968000 0998      6324      MOVE.l  #$98968000,FAC2_m(a3)   * 10000000 mantissa
00FF1F9A  377C 9800 099C          6325      MOVE.w  #$9800,FAC2_e(a3)       * 10000000 exponent & sign
00FF1FA0  176B 0995 099E          6326      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * make FAC1 sign sign compare
00FF1FA6  6100 FCE2               6327      BSR     LAB_MULTIPLY        * do FAC2*FAC1
00FF1FAA                          6328  
00FF1FAA  177C 00F9 09AC          6329      MOVE.b  #$F9,numexp(a3)     * set number exponent count (-7)
00FF1FB0  6028                    6330      BRA.s       LAB_299C            * go test for fit
00FF1FB2                          6331  
00FF1FB2                          6332  LAB_29B9
00FF1FB2  376B 0994 099C          6333      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
00FF1FB8  276B 0990 0998          6334      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
00FF1FBE  176B 0995 099E          6335      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * save FAC1_s as sign compare
00FF1FC4                          6336  
00FF1FC4  277C CCCCCCCD 0990      6337      MOVE.l  #$CCCCCCCD,FAC1_m(a3)   * 1/10 mantissa
00FF1FCC  377C 7D00 0994          6338      MOVE.w  #$7D00,FAC1_e(a3)       * 1/10 exponent & sign
00FF1FD2  6100 FCB6               6339      BSR     LAB_MULTIPLY        * do FAC2*FAC1, effectively divide by 10 but
00FF1FD6                          6340                              * faster
00FF1FD6                          6341  
00FF1FD6  522B 09AC               6342      ADDQ.b  #1,numexp(a3)       * increment number exponent count
00FF1FDA                          6343  LAB_299C
00FF1FDA  277C 98967F70 0998      6344      MOVE.l  #$98967F70,FAC2_m(a3)   * 9999999.4375 mantissa
00FF1FE2  377C 9800 099C          6345      MOVE.w  #$9800,FAC2_e(a3)       * 9999999.4375 exponent & sign
00FF1FE8                          6346                              * (max before scientific notation)
00FF1FE8  6100 014C               6347      BSR     LAB_27F0            * fast compare FAC1 with FAC2
00FF1FEC                          6348                              * returns d0=+1 C=0 if FAC1 > FAC2
00FF1FEC                          6349                              * returns d0= 0 C=0 if FAC1 = FAC2
00FF1FEC                          6350                              * returns d0=-1 C=1 if FAC1 < FAC2
00FF1FEC  62C4                    6351      BHI.s       LAB_29B9            * go do /10 if FAC1 > 9999999.4375
00FF1FEE                          6352  
00FF1FEE  6750                    6353      BEQ.s       LAB_29C3            * branch if FAC1 = 9999999.4375
00FF1FF0                          6354  
00FF1FF0                          6355                              * FAC1 < 9999999.4375
00FF1FF0  277C F423F800 0998      6356      MOVE.l  #$F423F800,FAC2_m(a3)   * set mantissa for 999999.5
00FF1FF8  377C 9400 099C          6357      MOVE.w  #$9400,FAC2_e(a3)       * set exponent for 999999.5
00FF1FFE  41EB 0990               6358      LEA     FAC1_m(a3),a0       * set pointer for x10
00FF2002                          6359  LAB_29A7
00FF2002  6100 0132               6360      BSR     LAB_27F0            * fast compare FAC1 with FAC2
00FF2006                          6361                              * returns d0=+1 C=0 if FAC1 > FAC2
00FF2006                          6362                              * returns d0= 0 C=0 if FAC1 = FAC2
00FF2006                          6363                              * returns d0=-1 C=1 if FAC1 < FAC2
00FF2006  6220                    6364      BHI.s       LAB_29C0            * branch if FAC1 > 99999.9375,no decimal places
00FF2008                          6365  
00FF2008                          6366                              * FAC1 <= 999999.5 so do x 10
00FF2008  2010                    6367      MOVE.l  (a0),d0         * get FAC1 mantissa
00FF200A  1228 0004               6368      MOVE.b  4(a0),d1            * get FAC1 exponent
00FF200E  2400                    6369      MOVE.l  d0,d2               * copy it
00FF2010  E488                    6370      LSR.l       #2,d0               * /4
00FF2012  D082                    6371      ADD.l       d2,d0               * add FAC1 (x1.125)
00FF2014  6404                    6372      BCC.s       LAB_29B7            * branch if no carry
00FF2016                          6373  
00FF2016  E290                    6374      ROXR.l  #1,d0               * shift carry back in
00FF2018  5201                    6375      ADDQ.b  #1,d1               * increment exponent (never overflows)
00FF201A                          6376  LAB_29B7
00FF201A  5601                    6377      ADDQ.b  #3,d1               * correct exponent ( 8 x 1.125 = 10 )
00FF201C                          6378                              * (never overflows)
00FF201C  2080                    6379      MOVE.l  d0,(a0)         * save new mantissa
00FF201E  1141 0004               6380      MOVE.b  d1,4(a0)            * save new exponent
00FF2022  532B 09AC               6381      SUBQ.b  #1,numexp(a3)       * decrement number exponent count
00FF2026  60DA                    6382      BRA.s       LAB_29A7            * go test again
00FF2028                          6383  
00FF2028                          6384                              * now we have just the digits to do
00FF2028                          6385  LAB_29C0
00FF2028  277C 80000000 0998      6386      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 0.5
00FF2030  377C 8000 099C          6387      MOVE.w  #$8000,FAC2_e(a3)       * set exponent for 0.5
00FF2036  176B 0995 099E          6388      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
00FF203C  6100 FAA8               6389      BSR     LAB_ADD         * add the 0.5 to FAC1 (round FAC1)
00FF2040                          6390  
00FF2040                          6391  LAB_29C3
00FF2040  6100 FE7A               6392      BSR     LAB_2831            * convert FAC1 floating to fixed
00FF2044                          6393                              * result in d0 and Itemp
00FF2044  7401                    6394      MOVEQ       #$01,d2         * set default digits before dp = 1
00FF2046  102B 09AC               6395      MOVE.b  numexp(a3),d0       * get number exponent count
00FF204A  5000                    6396      ADD.b       #8,d0               * allow 7 digits before point
00FF204C  6B0C                    6397      BMI.s       LAB_29D9            * if -ve then 1 digit before dp
00FF204E                          6398  
00FF204E  B03C 0009               6399      CMP.b       #$09,d0         * d0>=9 if n>=1E7
00FF2052  6406                    6400      BCC.s       LAB_29D9            * branch if >= $09
00FF2054                          6401  
00FF2054                          6402                              * < $08
00FF2054  5300                    6403      SUBQ.b  #1,d0               * take 1 from digit count
00FF2056  1400                    6404      MOVE.b  d0,d2               * copy byte
00FF2058  7002                    6405      MOVEQ       #$02,d0         * set exponent adjust
00FF205A                          6406  LAB_29D9
00FF205A  7200                    6407      MOVEQ       #0,d1               * set output string index
00FF205C  5500                    6408      SUBQ.b  #2,d0               * -2
00FF205E  1740 09AD               6409      MOVE.b  d0,expcnt(a3)       * save exponent adjust
00FF2062  1742 09AC               6410      MOVE.b  d2,numexp(a3)       * save digits before dp count
00FF2066  1002                    6411      MOVE.b  d2,d0               * copy digits before dp count
00FF2068  6702                    6412      BEQ.s       LAB_29E4            * branch if no digits before dp
00FF206A                          6413  
00FF206A  6A14                    6414      BPL.s       LAB_29F7            * branch if digits before dp
00FF206C                          6415  
00FF206C                          6416  LAB_29E4
00FF206C  5281                    6417      ADDQ.l  #1,d1               * increment index
00FF206E  13BC 002E 1000          6418      MOVE.b  #'.',(a1,d1.w)      * save to output string
00FF2074                          6419  
00FF2074  4A02                    6420      TST.b       d2              * test digits before dp count
00FF2076  6708                    6421      BEQ.s       LAB_29F7            * branch if no digits before dp
00FF2078                          6422  
00FF2078  5281                    6423      ADDQ.l  #1,d1               * increment index
00FF207A  13BC 0030 1000          6424      MOVE.b  #'0',(a1,d1.w)      * save to output string
00FF2080                          6425  LAB_29F7
00FF2080  7400                    6426      MOVEQ       #0,d2               * clear index (point to 1,000,000)
00FF2082  7080                    6427      MOVEQ       #$80-$100,d0        * set output character
00FF2084                          6428  LAB_29FB
00FF2084  41FA 1140               6429      LEA     LAB_2A9A(pc),a0     * get base of table
00FF2088  2630 2000               6430      MOVE.l  (a0,d2.w),d3        * get table value
00FF208C                          6431  LAB_29FD
00FF208C  5200                    6432      ADDQ.b  #1,d0               * increment output character
00FF208E  D7AB 082A               6433      ADD.l       d3,Itemp(a3)        * add to (now fixed) mantissa
00FF2092  0800 0007               6434      BTST        #7,d0               * set test sense (z flag only)
00FF2096  6504                    6435      BCS.s       LAB_2A18            * did carry so has wrapped past zero
00FF2098                          6436  
00FF2098  67F2                    6437      BEQ.s       LAB_29FD            * no wrap and +ve test so try again
00FF209A                          6438  
00FF209A  6002                    6439      BRA.s       LAB_2A1A            * found this digit
00FF209C                          6440  
00FF209C                          6441  LAB_2A18
00FF209C  66EE                    6442      BNE.s       LAB_29FD            * wrap and -ve test so try again
00FF209E                          6443  
00FF209E                          6444  LAB_2A1A
00FF209E  6406                    6445      BCC.s       LAB_2A21            * branch if +ve test result
00FF20A0                          6446  
00FF20A0  4400                    6447      NEG.b       d0              * negate the digit number
00FF20A2  0600 000B               6448      ADD.b       #$0B,d0         * and subtract from 11 decimal
00FF20A6                          6449  LAB_2A21
00FF20A6  0600 002F               6450      ADD.b       #$2F,d0         * add "0"-1 to result
00FF20AA  5842                    6451      ADDQ.w  #4,d2               * increment index to next less power of ten
00FF20AC  5241                    6452      ADDQ.w  #1,d1               * increment output string index
00FF20AE  1600                    6453      MOVE.b  d0,d3               * copy character to d3
00FF20B0  C63C 007F               6454      AND.b       #$7F,d3         * mask out top bit
00FF20B4  1383 1000               6455      MOVE.b  d3,(a1,d1.w)        * save to output string
00FF20B8  532B 09AC               6456      SUB.b       #1,numexp(a3)       * decrement # of characters before the dp
00FF20BC  6608                    6457      BNE.s       LAB_2A3B            * branch if still characters to do
00FF20BE                          6458  
00FF20BE                          6459                              * else output the point
00FF20BE  5281                    6460      ADDQ.l  #1,d1               * increment index
00FF20C0  13BC 002E 1000          6461      MOVE.b  #'.',(a1,d1.w)      * save to output string
00FF20C6                          6462  LAB_2A3B
00FF20C6  C03C 0080               6463      AND.b       #$80,d0         * mask test sense bit
00FF20CA  0A00 0080               6464      EORI.b  #$80,d0         * invert it
00FF20CE  B43C 001C               6465      CMP.b       #LAB_2A9B-LAB_2A9A,d2   * compare table index with max+4
00FF20D2  66B0                    6466      BNE.s       LAB_29FB            * loop if not max
00FF20D4                          6467  
00FF20D4                          6468                              * now remove trailing zeroes
00FF20D4                          6469  LAB_2A4B
00FF20D4  1031 1000               6470      MOVE.b  (a1,d1.w),d0        * get character from output string
00FF20D8  5381                    6471      SUBQ.l  #1,d1               * decrement output string index
00FF20DA  B03C 0030               6472      CMP.b       #'0',d0         * compare with "0"
00FF20DE  67F4                    6473      BEQ.s       LAB_2A4B            * loop until non "0" character found
00FF20E0                          6474  
00FF20E0  B03C 002E               6475      CMP.b       #'.',d0         * compare with "."
00FF20E4  6702                    6476      BEQ.s       LAB_2A58            * branch if was dp
00FF20E6                          6477  
00FF20E6                          6478                              * else restore last character
00FF20E6  5281                    6479      ADDQ.l  #1,d1               * increment output string index
00FF20E8                          6480  LAB_2A58
00FF20E8  13BC 002B 1002          6481      MOVE.b  #'+',2(a1,d1.w)     * save character "+" to output string
00FF20EE  4A2B 09AD               6482      TST.b       expcnt(a3)          * test exponent count
00FF20F2  6738                    6483      BEQ.s       LAB_2A8C            * if zero go set null terminator & exit
00FF20F4                          6484  
00FF20F4                          6485                              * exponent isn't zero so write exponent
00FF20F4  6A0A                    6486      BPL.s       LAB_2A68            * branch if exponent count +ve
00FF20F6                          6487  
00FF20F6  13BC 002D 1002          6488      MOVE.b  #'-',2(a1,d1.w)     * save character "-" to output string
00FF20FC  442B 09AD               6489      NEG.b       expcnt(a3)          * convert -ve to +ve
00FF2100                          6490  LAB_2A68
00FF2100  13BC 0045 1001          6491      MOVE.b  #'E',1(a1,d1.w)     * save character "E" to output string
00FF2106  142B 09AD               6492      MOVE.b  expcnt(a3),d2       * get exponent count
00FF210A  702F                    6493      MOVEQ       #$2F,d0         * one less than "0" character
00FF210C                          6494  LAB_2A74
00FF210C  5200                    6495      ADDQ.b  #1,d0               * increment 10's character
00FF210E  0402 000A               6496      SUB.b       #$0A,d2         * subtract 10 from exponent count
00FF2112  64F8                    6497      BCC.s       LAB_2A74            * loop while still >= 0
00FF2114                          6498  
00FF2114  0602 003A               6499      ADD.b       #$3A,d2         * add character ":", $30+$0A, result is 10-value
00FF2118  1380 1003               6500      MOVE.b  d0,3(a1,d1.w)       * save 10's character to output string
00FF211C  1382 1004               6501      MOVE.b  d2,4(a1,d1.w)       * save 1's character to output string
00FF2120  13BC 0000 1005          6502      MOVE.b  #0,5(a1,d1.w)       * save null terminator after last character
00FF2126  600A                    6503      BRA.s       LAB_2A91            * go set string pointer (a0) and exit
00FF2128                          6504  
00FF2128                          6505  LAB_2A89
00FF2128  1380 1000               6506      MOVE.b  d0,(a1,d1.w)        * save last character to output string
00FF212C                          6507  LAB_2A8C
00FF212C  13BC 0000 1001          6508      MOVE.b  #0,1(a1,d1.w)       * save null terminator after last character
00FF2132                          6509  LAB_2A91
00FF2132  2049                    6510      MOVEA.l a1,a0               * set result string pointer (a0)
00FF2134  4E75                    6511      RTS
00FF2136                          6512  
00FF2136                          6513  
00FF2136                          6514  *************************************************************************************
00FF2136                          6515  *
00FF2136                          6516  * fast compare FAC1 with FAC2
00FF2136                          6517  * assumes both are +ve and FAC2>0
00FF2136                          6518  * returns d0=+1 C=0 if FAC1 > FAC2
00FF2136                          6519  * returns d0= 0 C=0 if FAC1 = FAC2
00FF2136                          6520  * returns d0=-1 C=1 if FAC1 < FAC2
00FF2136                          6521  
00FF2136                          6522  LAB_27F0
00FF2136  7000                    6523      MOVEQ       #0,d0               * set for FAC1 = FAC2
00FF2138  122B 099C               6524      MOVE.b  FAC2_e(a3),d1       * get FAC2 exponent
00FF213C  B22B 0994               6525      CMP.b       FAC1_e(a3),d1       * compare FAC1 exponent with FAC2 exponent
00FF2140  660A                    6526      BNE.s       LAB_27F1            * branch if different
00FF2142                          6527  
00FF2142  222B 0998               6528      MOVE.l  FAC2_m(a3),d1       * get FAC2 mantissa
00FF2146  B2AB 0990               6529      CMP.l       FAC1_m(a3),d1       * compare mantissas
00FF214A  6708                    6530      BEQ.s       LAB_27F3            * exit if mantissas equal
00FF214C                          6531  
00FF214C                          6532  LAB_27F1
00FF214C  6504                    6533      BCS.s       LAB_27F2            * if FAC1 > FAC2 return d0=+1,C=0
00FF214E                          6534  
00FF214E  5380                    6535      SUBQ.l  #1,d0               * else FAC1 < FAC2 return d0=-1,C=1
00FF2150  4E75                    6536      RTS
00FF2152                          6537  
00FF2152                          6538  LAB_27F2
00FF2152  5280                    6539      ADDQ.l  #1,d0
00FF2154                          6540  LAB_27F3
00FF2154  4E75                    6541      RTS
00FF2156                          6542  
00FF2156                          6543  
00FF2156                          6544  *************************************************************************************
00FF2156                          6545  *
00FF2156                          6546  * make FAC1 = 1
00FF2156                          6547  
00FF2156                          6548  LAB_POON
00FF2156  277C 80000000 0990      6549      MOVE.l  #$80000000,FAC1_m(a3)   * 1 mantissa
00FF215E  377C 8100 0994          6550      MOVE.w  #$8100,FAC1_e(a3)       * 1 exonent & sign
00FF2164  4E75                    6551      RTS
00FF2166                          6552  
00FF2166                          6553  
00FF2166                          6554  *************************************************************************************
00FF2166                          6555  *
00FF2166                          6556  * make FAC1 = 0
00FF2166                          6557  
00FF2166                          6558  LAB_POZE
00FF2166  7000                    6559      MOVEQ       #0,d0               * clear longword
00FF2168  2740 0990               6560      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
00FF216C  3740 0994               6561      MOVE.w  d0,FAC1_e(a3)       * 0 exonent & sign
00FF2170  4E75                    6562      RTS
00FF2172                          6563  
00FF2172                          6564  
00FF2172                          6565  *************************************************************************************
00FF2172                          6566  *
00FF2172                          6567  * Perform power function
00FF2172                          6568  * The number is in FAC2, the power is in FAC1
00FF2172                          6569  * no longer trashes Itemp
00FF2172                          6570  
00FF2172                          6571  LAB_POWER
00FF2172  4A2B 0994               6572      TST.b       FAC1_e(a3)          * test power
00FF2176  67DE                    6573      BEQ.s       LAB_POON            * if zero go return 1
00FF2178                          6574  
00FF2178  4A2B 099C               6575      TST.b       FAC2_e(a3)          * test number
00FF217C  67E8                    6576      BEQ.s       LAB_POZE            * if zero go return 0
00FF217E                          6577  
00FF217E  1F2B 099D               6578      MOVE.b  FAC2_s(a3),-(sp)        * save number sign
00FF2182  6A20                    6579      BPL.s       LAB_POWP            * power of positive number
00FF2184                          6580  
00FF2184  7200                    6581      MOVEQ       #0,d1               * clear d1
00FF2186  1741 099D               6582      MOVE.b  d1,FAC2_s(a3)       * make sign +ve
00FF218A                          6583  
00FF218A                          6584                              * number sign was -ve and can only be raised to
00FF218A                          6585                              * an integer power which gives an x +j0 result,
00FF218A                          6586                              * else do 'function call' error
00FF218A  122B 0994               6587      MOVE.b  FAC1_e(a3),d1       * get power exponent
00FF218E  0441 0080               6588      SUB.w       #$80,d1         * normalise to .5
00FF2192  6300 DFFE               6589      BLS     LAB_FCER            * if 0<power<1 then do 'function call' error
00FF2196                          6590  
00FF2196                          6591                              * now shift all the integer bits out
00FF2196  202B 0990               6592      MOVE.l  FAC1_m(a3),d0       * get power mantissa
00FF219A  E3A0                    6593      ASL.l       d1,d0               * shift mantissa
00FF219C  6600 DFF4               6594      BNE     LAB_FCER            * if power<>INT(power) then do 'function call'
00FF21A0                          6595                              * error
00FF21A0                          6596  
00FF21A0  6502                    6597      BCS.s       LAB_POWP            * if integer value odd then leave result -ve
00FF21A2                          6598  
00FF21A2  1E80                    6599      MOVE.b  d0,(sp)         * save result sign +ve
00FF21A4                          6600  LAB_POWP
00FF21A4  2F2B 0990               6601      MOVE.l  FAC1_m(a3),-(sp)        * save power mantissa
00FF21A8  3F2B 0994               6602      MOVE.w  FAC1_e(a3),-(sp)        * save power sign & exponent
00FF21AC                          6603  
00FF21AC  6100 FC76               6604      BSR     LAB_279B            * copy number to FAC1
00FF21B0  6100 F9E6               6605      BSR     LAB_LOG         * find log of number
00FF21B4                          6606  
00FF21B4  301F                    6607      MOVE.w  (sp)+,d0            * get power sign & exponent
00FF21B6  275F 0998               6608      MOVE.l  (sp)+,FAC2_m(a3)        * get power mantissa
00FF21BA  3740 099C               6609      MOVE.w  d0,FAC2_e(a3)       * save sign & exponent to FAC2
00FF21BE  1740 099E               6610      MOVE.b  d0,FAC_sc(a3)       * save sign as sign compare
00FF21C2  102B 0995               6611      MOVE.b  FAC1_s(a3),d0       * get FAC1 sign
00FF21C6  B12B 099E               6612      EOR.b       d0,FAC_sc(a3)       * make sign compare (FAC1_s EOR FAC2_s)
00FF21CA                          6613  
00FF21CA  6100 FABE               6614      BSR     LAB_MULTIPLY        * multiply by power
00FF21CE  6158                    6615      BSR.s       LAB_EXP         * find exponential
00FF21D0  175F 0995               6616      MOVE.b  (sp)+,FAC1_s(a3)        * restore number sign
00FF21D4  4E75                    6617      RTS
00FF21D6                          6618  
00FF21D6                          6619  
00FF21D6                          6620  *************************************************************************************
00FF21D6                          6621  *
00FF21D6                          6622  * do - FAC1
00FF21D6                          6623  
00FF21D6                          6624  LAB_GTHAN
00FF21D6  4A2B 0994               6625      TST.b       FAC1_e(a3)          * test for non zero FAC1
00FF21DA  6706                    6626      BEQ.s       RTS_020         * branch if null
00FF21DC                          6627  
00FF21DC  0A2B 0080 0995          6628      EORI.b  #$80,FAC1_s(a3)     * (else) toggle FAC1 sign bit
00FF21E2                          6629  RTS_020
00FF21E2  4E75                    6630      RTS
00FF21E4                          6631  
00FF21E4                          6632  
00FF21E4                          6633  *************************************************************************************
00FF21E4                          6634  *
00FF21E4                          6635                              * return +1
00FF21E4                          6636  LAB_EX1
00FF21E4  277C 80000000 0990      6637      MOVE.l  #$80000000,FAC1_m(a3)   * +1 mantissa
00FF21EC  377C 8100 0994          6638      MOVE.w  #$8100,FAC1_e(a3)       * +1 sign & exponent
00FF21F2  4E75                    6639      RTS
00FF21F4                          6640                              * do over/under flow
00FF21F4                          6641  LAB_EXOU
00FF21F4  4A2B 0995               6642      TST.b       FAC1_s(a3)          * test sign
00FF21F8  6A00 DF94               6643      BPL     LAB_OFER            * was +ve so do overflow error
00FF21FC                          6644  
00FF21FC                          6645                              * else underflow so return zero
00FF21FC  7000                    6646      MOVEQ       #0,d0               * clear longword
00FF21FE  2740 0990               6647      MOVE.l  d0,FAC1_m(a3)       * 0 mantissa
00FF2202  3740 0994               6648      MOVE.w  d0,FAC1_e(a3)       * 0 sign & exponent
00FF2206  4E75                    6649      RTS
00FF2208                          6650                              * fraction was zero so do 2^n
00FF2208                          6651  LAB_EXOF
00FF2208  277C 80000000 0990      6652      MOVE.l  #$80000000,FAC1_m(a3)   * +n mantissa
00FF2210  177C 0000 0995          6653      MOVE.b  #0,FAC1_s(a3)       * clear sign
00FF2216  4A2B 09B4               6654      TST.b       cosout(a3)          * test sign flag
00FF221A  6A02                    6655      BPL.s       LAB_EXOL            * branch if +ve
00FF221C                          6656  
00FF221C  4481                    6657      NEG.l       d1              * else do 1/2^n
00FF221E                          6658  LAB_EXOL
00FF221E  0601 0081               6659      ADD.b       #$81,d1         * adjust exponent
00FF2222  1741 0994               6660      MOVE.b  d1,FAC1_e(a3)       * save exponent
00FF2226  4E75                    6661      RTS
00FF2228                          6662  
00FF2228                          6663  * perform EXP() (x^e)
00FF2228                          6664  * valid input range is -88 to +88
00FF2228                          6665  
00FF2228                          6666  LAB_EXP
00FF2228  102B 0994               6667      MOVE.b  FAC1_e(a3),d0       * get exponent
00FF222C  67B6                    6668      BEQ.s       LAB_EX1         * return 1 for zero in
00FF222E                          6669  
00FF222E  B03C 0064               6670      CMP.b       #$64,d0         * compare exponent with min
00FF2232  65B0                    6671      BCS.s       LAB_EX1         * if smaller just return 1
00FF2234                          6672  
00FF2234                          6673  **  MOVEM.l d1-d6/a0,-(sp)      * save the registers
00FF2234  177C 0000 09B4          6674      MOVE.b  #0,cosout(a3)       * flag +ve number
00FF223A  222B 0990               6675      MOVE.l  FAC1_m(a3),d1       * get mantissa
00FF223E  B03C 0087               6676      CMP.b       #$87,d0         * compare exponent with max
00FF2242  62B0                    6677      BHI.s       LAB_EXOU            * go do over/under flow if greater
00FF2244                          6678  
00FF2244  6608                    6679      BNE.s       LAB_EXCM            * branch if less
00FF2246                          6680  
00FF2246                          6681                              * else is 2^7
00FF2246  B2BC B00F33C7           6682      CMP.l       #$B00F33C7,d1       * compare mantissa with n*2^7 max
00FF224C  64A6                    6683      BCC.s       LAB_EXOU            * if => go over/underflow
00FF224E                          6684  
00FF224E                          6685  LAB_EXCM
00FF224E  4A2B 0995               6686      TST.b       FAC1_s(a3)          * test sign
00FF2252  6A0C                    6687      BPL.s       LAB_EXPS            * branch if arg +ve
00FF2254                          6688  
00FF2254  177C 00FF 09B4          6689      MOVE.b  #$FF,cosout(a3)     * flag -ve number
00FF225A  177C 0000 0995          6690      MOVE.b  #0,FAC1_s(a3)       * take absolute value
00FF2260                          6691  LAB_EXPS
00FF2260                          6692                              * now do n/LOG(2)
00FF2260  277C B8AA3B29 0998      6693      MOVE.l  #$B8AA3B29,FAC2_m(a3)   * 1/LOG(2) mantissa
00FF2268  377C 8100 099C          6694      MOVE.w  #$8100,FAC2_e(a3)       * 1/LOG(2) exponent & sign
00FF226E  177C 0000 099E          6695      MOVE.b  #0,FAC_sc(a3)       * we know they're both +ve
00FF2274  6100 FA14               6696      BSR     LAB_MULTIPLY        * effectively divide by log(2)
00FF2278                          6697  
00FF2278                          6698                              * max here is +/- 127
00FF2278                          6699                              * now separate integer and fraction
00FF2278  177C 0000 09D9          6700      MOVE.b  #0,tpower(a3)       * clear exponent add byte
00FF227E  1A2B 0994               6701      MOVE.b  FAC1_e(a3),d5       * get exponent
00FF2282  0405 0080               6702      SUB.b       #$80,d5         * normalise
00FF2286  6324                    6703      BLS.s       LAB_ESML            * branch if < 1 (d5 is 0 or -ve)
00FF2288                          6704  
00FF2288                          6705                              * result is > 1
00FF2288  202B 0990               6706      MOVE.l  FAC1_m(a3),d0       * get mantissa
00FF228C  2200                    6707      MOVE.l  d0,d1               * copy it
00FF228E  2C05                    6708      MOVE.l  d5,d6               * copy normalised exponent
00FF2290                          6709  
00FF2290  4446                    6710      NEG.w       d6              * make -ve
00FF2292  0646 0020               6711      ADD.w       #32,d6          * is now 32-d6
00FF2296  ECA9                    6712      LSR.l       d6,d1               * just integer bits
00FF2298  1741 09D9               6713      MOVE.b  d1,tpower(a3)       * set exponent add byte
00FF229C                          6714  
00FF229C  EBA8                    6715      LSL.l       d5,d0               * shift out integer bits
00FF229E  6700 FF68               6716      BEQ     LAB_EXOF            * fraction is zero so do 2^n
00FF22A2                          6717  
00FF22A2  2740 0990               6718      MOVE.l  d0,FAC1_m(a3)       * fraction to FAC1
00FF22A6  377C 8000 0994          6719      MOVE.w  #$8000,FAC1_e(a3)       * set exponent & sign
00FF22AC                          6720  
00FF22AC                          6721                              * multiple was < 1
00FF22AC                          6722  LAB_ESML
00FF22AC  277C B17217F8 0998      6723      MOVE.l  #$B17217F8,FAC2_m(a3)   * LOG(2) mantissa
00FF22B4  377C 8000 099C          6724      MOVE.w  #$8000,FAC2_e(a3)       * LOG(2) exponent & sign
00FF22BA  177C 0000 099E          6725      MOVE.b  #0,FAC_sc(a3)       * clear sign compare
00FF22C0  6100 F9C8               6726      BSR     LAB_MULTIPLY        * multiply by log(2)
00FF22C4                          6727  
00FF22C4  202B 0990               6728      MOVE.l  FAC1_m(a3),d0       * get mantissa
00FF22C8  1A2B 0994               6729      MOVE.b  FAC1_e(a3),d5       * get exponent
00FF22CC  0445 0082               6730      SUB.w       #$82,d5         * normalise and -2 (result is -1 to -30)
00FF22D0  4445                    6731      NEG.w       d5              * make +ve
00FF22D2  EAA8                    6732      LSR.l       d5,d0               * shift for 2 integer bits
00FF22D4                          6733  
00FF22D4                          6734  * d0 = arg
00FF22D4                          6735  * d6 = x, d1 = y
00FF22D4                          6736  * d2 = x1, d3 = y1
00FF22D4                          6737  * d4 = shift count
00FF22D4                          6738  * d5 = loop count
00FF22D4                          6739                              * now do cordic set-up
00FF22D4  7200                    6740      MOVEQ       #0,d1               * y = 0
00FF22D6  2C3C 26A3D110           6741      MOVE.l  #KFCTSEED,d6        * x = 1 with jkh inverse factored out
00FF22DC  41FA 0D2A               6742      LEA     TAB_HTHET(pc),a0        * get pointer to hyperbolic arctan table
00FF22E0  7800                    6743      MOVEQ       #0,d4               * clear shift count
00FF22E2                          6744   
00FF22E2                          6745                              * cordic loop, shifts 4 and 13 (and 39
00FF22E2                          6746                              * if it went that far) need to be repeated
00FF22E2  7A03                    6747      MOVEQ       #3,d5               * 4 loops
00FF22E4  6136                    6748      BSR.s       LAB_EXCC            * do loops 1 through 4
00FF22E6  5948                    6749      SUBQ.w  #4,a0               * do table entry again
00FF22E8  5384                    6750      SUBQ.l  #1,d4               * do shift count again
00FF22EA  7A09                    6751      MOVEQ       #9,d5               * 10 loops
00FF22EC  612E                    6752      BSR.s       LAB_EXCC            * do loops 4 (again) through 13
00FF22EE  5948                    6753      SUBQ.w  #4,a0               * do table entry again
00FF22F0  5384                    6754      SUBQ.l  #1,d4               * do shift count again
00FF22F2  7A12                    6755      MOVEQ       #18,d5          * 19 loops
00FF22F4  6126                    6756      BSR.s       LAB_EXCC            * do loops 13 (again) through 31
00FF22F6                          6757   
00FF22F6                          6758                              * now get the result
00FF22F6  4A2B 09B4               6759      TST.b       cosout(a3)          * test sign flag
00FF22FA  6A06                    6760      BPL.s       LAB_EXPL            * branch if +ve
00FF22FC                          6761  
00FF22FC  4481                    6762      NEG.l       d1              * do -y
00FF22FE  442B 09D9               6763      NEG.b       tpower(a3)          * do -exp
00FF2302                          6764  LAB_EXPL
00FF2302  7083                    6765      MOVEQ       #$83-$100,d0        * set exponent
00FF2304  DC81                    6766      ADD.l       d1,d6               * y = y +/- x
00FF2306  6B06                    6767      BMI.s       LAB_EXRN            * branch if result normal
00FF2308                          6768  
00FF2308                          6769  LAB_EXNN
00FF2308  5380                    6770      SUBQ.l  #1,d0               * decrement exponent
00FF230A  DC86                    6771      ADD.l       d6,d6               * shift mantissa
00FF230C  6AFA                    6772      BPL.s       LAB_EXNN            * loop if not normal
00FF230E                          6773  
00FF230E                          6774  LAB_EXRN
00FF230E  2746 0990               6775      MOVE.l  d6,FAC1_m(a3)       * save exponent result
00FF2312  D02B 09D9               6776      ADD.b       tpower(a3),d0       * add integer part
00FF2316  1740 0994               6777      MOVE.b  d0,FAC1_e(a3)       * save exponent
00FF231A                          6778  **  MOVEM.l (sp)+,d1-d6/a0      * restore registers
00FF231A  4E75                    6779      RTS
00FF231C                          6780   
00FF231C                          6781                              * cordic loop
00FF231C                          6782  LAB_EXCC
00FF231C  5284                    6783      ADDQ.l  #1,d4               * increment shift count
00FF231E  2406                    6784      MOVE.l  d6,d2               * x1 = x
00FF2320  E8A2                    6785      ASR.l       d4,d2               * x1 >> n
00FF2322  2601                    6786      MOVE.l  d1,d3               * y1 = y
00FF2324  E8A3                    6787      ASR.l       d4,d3               * y1 >> n
00FF2326  4A80                    6788      TST.l       d0              * test arg
00FF2328  6B0C                    6789      BMI.s       LAB_EXAD            * branch if -ve
00FF232A                          6790  
00FF232A  D282                    6791      ADD.l       d2,d1               * y = y + x1
00FF232C  DC83                    6792      ADD.l       d3,d6               * x = x + y1
00FF232E  9098                    6793      SUB.l       (a0)+,d0            * arg = arg - atnh(a0)
00FF2330  51CD FFEA               6794      DBF     d5,LAB_EXCC         * decrement and loop if not done
00FF2334                          6795  
00FF2334  4E75                    6796      RTS
00FF2336                          6797  
00FF2336                          6798  LAB_EXAD
00FF2336  9282                    6799      SUB.l       d2,d1               * y = y - x1
00FF2338  9C83                    6800      SUB.l       d3,d6               * x = x + y1
00FF233A  D098                    6801      ADD.l       (a0)+,d0            * arg = arg + atnh(a0)
00FF233C  51CD FFDE               6802      DBF     d5,LAB_EXCC         * decrement and loop if not done
00FF2340                          6803  
00FF2340  4E75                    6804      RTS
00FF2342                          6805  
00FF2342                          6806  
00FF2342                          6807  *************************************************************************************
00FF2342                          6808  *
00FF2342                          6809  * RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
00FF2342                          6810  * to get 19th next number in sequence after seed n. This version of the PRNG uses
00FF2342                          6811  * the Galois method and a sample of 65536 bytes produced gives the following values.
00FF2342                          6812  
00FF2342                          6813  * Entropy = 7.997442 bits per byte
00FF2342                          6814  * Optimum compression would reduce these 65536 bytes by 0 percent
00FF2342                          6815  
00FF2342                          6816  * Chi square distribution for 65536 samples is 232.01, and
00FF2342                          6817  * randomly would exceed this value 75.00 percent of the time
00FF2342                          6818  
00FF2342                          6819  * Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
00FF2342                          6820  * Monte Carlo value for Pi is 3.122871269, error 0.60 percent
00FF2342                          6821  * Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
00FF2342                          6822  
00FF2342                          6823  LAB_RND
00FF2342  4A2B 0994               6824      TST.b       FAC1_e(a3)          * get FAC1 exponent
00FF2346  6708                    6825      BEQ.s       NextPRN         * do next random number if zero
00FF2348                          6826  
00FF2348                          6827                              * else get seed into random number store
00FF2348  41EB 09A0               6828      LEA     PRNlword(a3),a0     * set PRNG pointer
00FF234C  6100 FAB0               6829      BSR     LAB_2778            * pack FAC1 into (a0)
00FF2350                          6830  NextPRN
00FF2350  72AF                    6831      MOVEQ       #$AF-$100,d1        * set EOR value
00FF2352  7412                    6832      MOVEQ       #18,d2          * do this 19 times
00FF2354  202B 09A0               6833      MOVE.l  PRNlword(a3),d0     * get current
00FF2358                          6834  Ninc0
00FF2358  D080                    6835      ADD.l       d0,d0               * shift left 1 bit
00FF235A  6402                    6836      BCC.s       Ninc1               * branch if bit 32 not set
00FF235C                          6837  
00FF235C  B300                    6838      EOR.b       d1,d0               * do Galois LFSR feedback
00FF235E                          6839  Ninc1
00FF235E  51CA FFF8               6840      DBF     d2,Ninc0            * loop
00FF2362                          6841  
00FF2362  2740 09A0               6842      MOVE.l  d0,PRNlword(a3)     * save back to seed word
00FF2366  2740 0990               6843      MOVE.l  d0,FAC1_m(a3)       * copy to FAC1 mantissa
00FF236A  377C 8000 0994          6844      MOVE.w  #$8000,FAC1_e(a3)       * set the exponent and clear the sign
00FF2370  6000 F7F0               6845      BRA     LAB_24D5            * normalise FAC1 & return
00FF2374                          6846  
00FF2374                          6847  
00FF2374                          6848  *************************************************************************************
00FF2374                          6849  *
00FF2374                          6850  * cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
00FF2374                          6851  * x = angle in radians
00FF2374                          6852  
00FF2374                          6853  LAB_TAN
00FF2374  6138                    6854      BSR.s       LAB_SIN         * go do SIN/COS cordic compute
00FF2376  376B 0994 099C          6855      MOVE.w  FAC1_e(a3),FAC2_e(a3)   * copy exponent & sign from FAC1 to FAC2
00FF237C  276B 0990 0998          6856      MOVE.l  FAC1_m(a3),FAC2_m(a3)   * copy FAC1 mantissa to FAC2 mantissa
00FF2382  2741 0990               6857      MOVE.l  d1,FAC1_m(a3)       * get COS(x) mantissa
00FF2386  1743 0994               6858      MOVE.b  d3,FAC1_e(a3)       * get COS(x) exponent
00FF238A  6700 DE02               6859      BEQ     LAB_OFER            * do overflow if COS = 0
00FF238E                          6860  
00FF238E  6100 F7D2               6861      BSR     LAB_24D5            * normalise FAC1
00FF2392  6000 F982               6862      BRA     LAB_DIVIDE          * do FAC2/FAC1 and return, FAC_sc set by SIN
00FF2396                          6863                              * COS calculation
00FF2396                          6864  
00FF2396                          6865  
00FF2396                          6866  *************************************************************************************
00FF2396                          6867  *
00FF2396                          6868  * cordic SIN(x), COS(x) routine
00FF2396                          6869  * x = angle in radians
00FF2396                          6870  
00FF2396                          6871  LAB_COS
00FF2396  277C C90FDAA3 0998      6872      MOVE.l  #$C90FDAA3,FAC2_m(a3)   * pi/2 mantissa (LSB is rounded up so
00FF239E                          6873                              * COS(PI/2)=0)
00FF239E  377C 8100 099C          6874      MOVE.w  #$8100,FAC2_e(a3)       * pi/2 exponent and sign
00FF23A4  176B 0995 099E          6875      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
00FF23AA  6100 F73A               6876      BSR     LAB_ADD         * add FAC2 to FAC1, adjust for COS(x)
00FF23AE                          6877  
00FF23AE                          6878  
00FF23AE                          6879  *************************************************************************************
00FF23AE                          6880  *
00FF23AE                          6881  * SIN/COS cordic calculator
00FF23AE                          6882  
00FF23AE                          6883  LAB_SIN
00FF23AE  177C 0000 09B4          6884      MOVE.b  #0,cosout(a3)       * set needed result
00FF23B4                          6885  
00FF23B4  277C A2F9836F 0998      6886      MOVE.l  #$A2F9836F,FAC2_m(a3)   * 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
00FF23BC  377C 7F00 099C          6887      MOVE.w  #$7F00,FAC2_e(a3)       * 1/pi exponent & sign
00FF23C2  176B 0995 099E          6888      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign = FAC1 sign (b7)
00FF23C8  6100 F8C0               6889      BSR     LAB_MULTIPLY        * multiply by 1/pi
00FF23CC                          6890  
00FF23CC  102B 0994               6891      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00FF23D0  671C                    6892      BEQ.s       LAB_SCZE            * branch if zero
00FF23D2                          6893  
00FF23D2  41FA 0B34               6894      LEA     TAB_SNCO(pc),a0     * get pointer to constants table
00FF23D6  2C2B 0990               6895      MOVE.l  FAC1_m(a3),d6       * get FAC1 mantissa
00FF23DA  5300                    6896      SUBQ.b  #1,d0               * 2 radians in 360 degrees so /2
00FF23DC  6710                    6897      BEQ.s       LAB_SCZE            * branch if zero
00FF23DE                          6898  
00FF23DE  0400 0080               6899      SUB.b       #$80,d0         * normalise exponent
00FF23E2  6B18                    6900      BMI.s       LAB_SCL0            * branch if < 1
00FF23E4                          6901  
00FF23E4                          6902                              * X is > 1
00FF23E4  B03C 0020               6903      CMP.b       #$20,d0         * is it >= 2^32
00FF23E8  6404                    6904      BCC.s       LAB_SCZE            * may as well do zero
00FF23EA                          6905  
00FF23EA  E1AE                    6906      LSL.l       d0,d6               * shift out integer part bits
00FF23EC  6618                    6907      BNE.s       LAB_CORD            * if fraction go test quadrant and adjust
00FF23EE                          6908  
00FF23EE                          6909                              * else no fraction so do zero
00FF23EE                          6910  LAB_SCZE
00FF23EE  7481                    6911      MOVEQ       #$81-$100,d2        * set exponent for 1.0
00FF23F0  7600                    6912      MOVEQ       #0,d3               * set exponent for 0.0
00FF23F2  203C 80000000           6913      MOVE.l  #$80000000,d0       * mantissa for 1.0
00FF23F8  2203                    6914      MOVE.l  d3,d1               * mantissa for 0.0
00FF23FA  6062                    6915      BRA.s       outloop         * go output it
00FF23FC                          6916  
00FF23FC                          6917                              * x is < 1
00FF23FC                          6918  LAB_SCL0
00FF23FC  4400                    6919      NEG.b       d0              * make +ve
00FF23FE  B03C 001E               6920      CMP.b       #$1E,d0         * is it <= 2^-30
00FF2402  64EA                    6921      BCC.s       LAB_SCZE            * may as well do zero
00FF2404                          6922  
00FF2404  E0AE                    6923      LSR.l       d0,d6               * shift out <= 2^-32 bits
00FF2406                          6924  
00FF2406                          6925  * cordic calculator, argument in d6
00FF2406                          6926  * table pointer in a0, returns in d0-d3
00FF2406                          6927  
00FF2406                          6928  LAB_CORD
00FF2406  176B 0995 099E          6929      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * copy as sign compare for TAN
00FF240C  DC86                    6930      ADD.l       d6,d6               * shift 0.5 bit into carry
00FF240E  6406                    6931      BCC.s       LAB_LTPF            * branch if less than 0.5
00FF2410                          6932  
00FF2410  0A2B 00FF 0995          6933      EORI.b  #$FF,FAC1_s(a3)     * toggle result sign
00FF2416                          6934  LAB_LTPF
00FF2416  DC86                    6935      ADD.l       d6,d6               * shift 0.25 bit into carry
00FF2418  640C                    6936      BCC.s       LAB_LTPT            * branch if less than 0.25
00FF241A                          6937  
00FF241A  0A2B 00FF 09B4          6938      EORI.b  #$FF,cosout(a3)     * toggle needed result
00FF2420  0A2B 00FF 099E          6939      EORI.b  #$FF,FAC_sc(a3)     * toggle sign compare for TAN
00FF2426                          6940  
00FF2426                          6941  LAB_LTPT
00FF2426  E48E                    6942      LSR.l       #2,d6               * shift the bits back (clear integer bits)
00FF2428  67C4                    6943      BEQ.s       LAB_SCZE            * no fraction so go do zero
00FF242A                          6944  
00FF242A                          6945                              * set start values
00FF242A  7A01                    6946      MOVEQ       #1,d5               * set bit count
00FF242C  2028 FFFC               6947      MOVE.l  -4(a0),d0           * get multiply constant (1st itteration d0)
00FF2430  2200                    6948      MOVE.l  d0,d1               * 1st itteration d1
00FF2432  9C98                    6949      SUB.l       (a0)+,d6            * 1st always +ve so do 1st step
00FF2434  6008                    6950      BRA.s       mainloop            * jump into routine
00FF2436                          6951  
00FF2436                          6952  subloop
00FF2436  9C98                    6953      SUB.l       (a0)+,d6            * z = z - arctan(i)/2pi
00FF2438  9083                    6954      SUB.l       d3,d0               * x = x - y1
00FF243A  D282                    6955      ADD.l       d2,d1               * y = y + x1
00FF243C  6012                    6956      BRA.s       nexta               * back to main loop
00FF243E                          6957  
00FF243E                          6958  mainloop
00FF243E  2400                    6959      MOVE.l  d0,d2               * x1 = x
00FF2440  EAA2                    6960      ASR.l       d5,d2               * / (2 ^ i)
00FF2442  2601                    6961      MOVE.l  d1,d3               * y1 = y
00FF2444  EAA3                    6962      ASR.l       d5,d3               * / (2 ^ i)
00FF2446  4A86                    6963      TST.l       d6              * test sign (is 2^0 bit)
00FF2448  6AEC                    6964      BPL.s       subloop         * go do subtract if > 1
00FF244A                          6965  
00FF244A  DC98                    6966      ADD.l       (a0)+,d6            * z = z + arctan(i)/2pi
00FF244C  D083                    6967      ADD.l       d3,d0               * x = x + y1
00FF244E  9282                    6968      SUB.l       d2,d1               * y = y + x1
00FF2450                          6969  nexta
00FF2450  5285                    6970      ADDQ.l  #1,d5               * i = i + 1
00FF2452  BABC 0000001E           6971      CMP.l       #$1E,d5         * check end condition
00FF2458  66E4                    6972      BNE.s       mainloop            * loop if not all done
00FF245A                          6973  
00FF245A                          6974                              * now untangle output value
00FF245A  7481                    6975      MOVEQ       #$81-$100,d2        * set exponent for 0 to .99 rec.
00FF245C  2602                    6976      MOVE.l  d2,d3               * copy it for cos output
00FF245E                          6977  outloop
00FF245E  4A2B 09B4               6978      TST.b       cosout(a3)          * did we want cos output?
00FF2462  6B04                    6979      BMI.s       subexit         * if so skip
00FF2464                          6980  
00FF2464  C141                    6981      EXG     d0,d1               * swap SIN and COS mantissas
00FF2466  C543                    6982      EXG     d2,d3               * swap SIN and COS exponents
00FF2468                          6983  subexit
00FF2468  2740 0990               6984      MOVE.l  d0,FAC1_m(a3)       * set result mantissa
00FF246C  1742 0994               6985      MOVE.b  d2,FAC1_e(a3)       * set result exponent
00FF2470  6000 F6F0               6986      BRA     LAB_24D5            * normalise FAC1 & return
00FF2474                          6987  
00FF2474                          6988  
00FF2474                          6989  
00FF2474                          6990  *************************************************************************************
00FF2474                          6991  *
00FF2474                          6992  * perform ATN()
00FF2474                          6993  
00FF2474                          6994  LAB_ATN
00FF2474  102B 0994               6995      MOVE.b  FAC1_e(a3),d0       * get FAC1 exponent
00FF2478  6700 00AA               6996      BEQ     RTS_021         * ATN(0) = 0 so skip calculation
00FF247C                          6997  
00FF247C  177C 0000 09B4          6998      MOVE.b  #0,cosout(a3)       * set result needed
00FF2482  B03C 0081               6999      CMP.b       #$81,d0         * compare exponent with 1
00FF2486  6528                    7000      BCS.s       LAB_ATLE            * branch if n<1
00FF2488                          7001  
00FF2488  6608                    7002      BNE.s       LAB_ATGO            * branch if n>1
00FF248A                          7003  
00FF248A  202B 0990               7004      MOVE.l  FAC1_m(a3),d0       * get mantissa
00FF248E  D080                    7005      ADD.l       d0,d0               * shift left
00FF2490  671E                    7006      BEQ.s       LAB_ATLE            * branch if n=1
00FF2492                          7007  
00FF2492                          7008  LAB_ATGO
00FF2492  277C 80000000 0998      7009      MOVE.l  #$80000000,FAC2_m(a3)   * set mantissa for 1
00FF249A  377C 8100 099C          7010      MOVE.w  #$8100,FAC2_e(a3)       * set exponent for 1
00FF24A0  176B 0995 099E          7011      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * sign compare = sign
00FF24A6  6100 F86E               7012      BSR     LAB_DIVIDE          * do 1/n
00FF24AA  177C 00FF 09B4          7013      MOVE.b  #$FF,cosout(a3)     * set inverse result needed
00FF24B0                          7014  LAB_ATLE
00FF24B0  202B 0990               7015      MOVE.l  FAC1_m(a3),d0       * get FAC1 mantissa
00FF24B4  7282                    7016      MOVEQ       #$82,d1         * set to correct exponent
00FF24B6  922B 0994               7017      SUB.b       FAC1_e(a3),d1       * subtract FAC1 exponent (always <= 1)
00FF24BA  E2A8                    7018      LSR.l       d1,d0               * shift in two integer part bits
00FF24BC  41FA 0ACA               7019      LEA     TAB_ATNC(pc),a0     * get pointer to arctan table
00FF24C0  7C00                    7020      MOVEQ       #0,d6               * Z = 0
00FF24C2  223C 40000000           7021      MOVE.l  #1<<30,d1           * y = 1
00FF24C8  7A1D                    7022      MOVEQ       #29,d5          * loop 30 times
00FF24CA  7801                    7023      MOVEQ       #1,d4               * shift counter
00FF24CC  6006                    7024      BRA.s       LAB_ATCD            * enter loop
00FF24CE                          7025  
00FF24CE                          7026  LAB_ATNP
00FF24CE  E8A2                    7027      ASR.l       d4,d2               * x1 / 2^i
00FF24D0  D282                    7028      ADD.l       d2,d1               * y = y + x1
00FF24D2  DC90                    7029      ADD.l       (a0),d6         * z = z + atn(i)
00FF24D4                          7030  LAB_ATCD
00FF24D4  2400                    7031      MOVE.l  d0,d2               * x1 = x
00FF24D6  2601                    7032      MOVE.l  d1,d3               * y1 = y
00FF24D8  E8A3                    7033      ASR.l       d4,d3               * y1 / 2^i
00FF24DA                          7034  LAB_CATN
00FF24DA  9083                    7035      SUB.l       d3,d0               * x = x - y1
00FF24DC  6AF0                    7036      BPL.s       LAB_ATNP            * branch if x >= 0
00FF24DE                          7037  
00FF24DE  2002                    7038      MOVE.l  d2,d0               * else get x back
00FF24E0  5848                    7039      ADDQ.w  #4,a0               * increment pointer
00FF24E2  5284                    7040      ADDQ.l  #1,d4               * increment i
00FF24E4  E283                    7041      ASR.l       #1,d3               * y1 / 2^i
00FF24E6  51CD FFF2               7042      DBF     d5,LAB_CATN         * decrement and loop if not done
00FF24EA                          7043  
00FF24EA  177C 0082 0994          7044      MOVE.b  #$82,FAC1_e(a3)     * set new exponent
00FF24F0  2746 0990               7045      MOVE.l  d6,FAC1_m(a3)       * save mantissa
00FF24F4  6100 F66C               7046      BSR     LAB_24D5            * normalise FAC1
00FF24F8                          7047  
00FF24F8  4A2B 09B4               7048      TST.b       cosout(a3)          * was it > 1 ?
00FF24FC  6A26                    7049      BPL.s       RTS_021         * branch if not
00FF24FE                          7050  
00FF24FE  1E2B 0995               7051      MOVE.b  FAC1_s(a3),d7       * get sign
00FF2502  177C 0000 0995          7052      MOVE.b  #0,FAC1_s(a3)       * clear sign
00FF2508  277C C90FDAA2 0998      7053      MOVE.l  #$C90FDAA2,FAC2_m(a3)   * set -(pi/2)
00FF2510  377C 8180 099C          7054      MOVE.w  #$8180,FAC2_e(a3)       * set exponent and sign
00FF2516  177C 00FF 099E          7055      MOVE.b  #$FF,FAC_sc(a3)     * set sign compare
00FF251C  6100 F5C8               7056      BSR     LAB_ADD         * perform addition, FAC2 to FAC1
00FF2520  1747 0995               7057      MOVE.b  d7,FAC1_s(a3)       * restore sign
00FF2524                          7058  RTS_021
00FF2524  4E75                    7059      RTS
00FF2526                          7060  
00FF2526                          7061  
00FF2526                          7062  *************************************************************************************
00FF2526                          7063  *
00FF2526                          7064  * perform BITSET
00FF2526                          7065  
00FF2526                          7066  LAB_BITSET
00FF2526  6100 F27C               7067      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00FF252A                          7068                              * first parameter in a0, second in d0
00FF252A  B03C 0008               7069      CMP.b       #$08,d0         * only 0 to 7 are allowed
00FF252E  6400 DC62               7070      BCC     LAB_FCER            * branch if > 7
00FF2532                          7071  
00FF2532  01D0                    7072      BSET        d0,(a0)         * set bit
00FF2534  4E75                    7073      RTS
00FF2536                          7074  
00FF2536                          7075  
00FF2536                          7076  *************************************************************************************
00FF2536                          7077  *
00FF2536                          7078  * perform BITCLR
00FF2536                          7079  
00FF2536                          7080  LAB_BITCLR
00FF2536  6100 F26C               7081      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00FF253A                          7082                              * first parameter in a0, second in d0
00FF253A  B03C 0008               7083      CMP.b       #$08,d0         * only 0 to 7 are allowed
00FF253E  6400 DC52               7084      BCC     LAB_FCER            * branch if > 7
00FF2542                          7085  
00FF2542  0190                    7086      BCLR        d0,(a0)         * clear bit
00FF2544  4E75                    7087      RTS
00FF2546                          7088  
00FF2546                          7089  
00FF2546                          7090  *************************************************************************************
00FF2546                          7091  *
00FF2546                          7092  * perform BITTST()
00FF2546                          7093  
00FF2546                          7094  LAB_BTST
00FF2546  101D                    7095      MOVE.b  (a5)+,d0            * increment BASIC pointer
00FF2548  6100 F25A               7096      BSR     LAB_GADB            * get two parameters for POKE or WAIT
00FF254C                          7097                              * first parameter in a0, second in d0
00FF254C  B03C 0008               7098      CMP.b       #$08,d0         * only 0 to 7 are allowed
00FF2550  6400 DC40               7099      BCC     LAB_FCER            * branch if > 7
00FF2554                          7100  
00FF2554  2200                    7101      MOVE.l  d0,d1               * copy bit # to test
00FF2556  6100 E886               7102      BSR     LAB_GBYT            * get next BASIC byte
00FF255A  B03C 0029               7103      CMP.b       #')',d0         * is next character ")"
00FF255E  6600 DC3E               7104      BNE     LAB_SNER            * if not ")" go do syntax error, then warm start
00FF2562                          7105  
00FF2562  6100 E878               7106      BSR     LAB_IGBY            * update execute pointer (to character past ")")
00FF2566  7000                    7107      MOVEQ       #0,d0               * set the result as zero
00FF2568  0310                    7108      BTST        d1,(a0)         * test bit
00FF256A  6700 F90C               7109      BEQ     LAB_27DB            * branch if zero (already correct)
00FF256E                          7110  
00FF256E  70FF                    7111      MOVEQ       #-1,d0          * set for -1 result
00FF2570  6000 F906               7112      BRA     LAB_27DB            * go do SGN tail
00FF2574                          7113  
00FF2574                          7114  
00FF2574                          7115  *************************************************************************************
00FF2574                          7116  *
00FF2574                          7117  * perform USING$()
00FF2574                          7118  
00FF2574  =00000000               7119  fsd EQU  0                  *   (sp) format string descriptor pointer
00FF2574  =00000004               7120  fsti    EQU  4                  *  4(sp) format string this index
00FF2574  =00000006               7121  fsli    EQU  6                  *  6(sp) format string last index
00FF2574  =00000008               7122  fsdpi   EQU  8                  *  8(sp) format string decimal point index
00FF2574  =0000000A               7123  fsdc    EQU 10                  * 10(sp) format string decimal characters
00FF2574  =00000008               7124  fend    EQU 12-4                    *  x(sp) end-4, fsd is popped by itself
00FF2574                          7125  
00FF2574  =00000023               7126  ofchr   EQU '#'                 * the overflow character
00FF2574                          7127  
00FF2574                          7128  LAB_USINGS
00FF2574  4A2B 09B5               7129      TST.b       Dtypef(a3)          * test data type, $80=string
00FF2578  6A00 DBD0               7130      BPL     LAB_FOER            * if not string type go do format error
00FF257C                          7131  
00FF257C  246B 0990               7132      MOVEA.l FAC1_m(a3),a2       * get the format string descriptor pointer
00FF2580  3E2A 0004               7133      MOVE.w  4(a2),d7            * get the format string length
00FF2584  6700 DBC4               7134      BEQ     LAB_FOER            * if null string go do format error
00FF2588                          7135  
00FF2588                          7136  * clear the format string values
00FF2588                          7137  
00FF2588  7000                    7138      MOVEQ       #0,d0               * clear d0
00FF258A  3F00                    7139      MOVE.w  d0,-(sp)            * clear the format string decimal characters
00FF258C  3F00                    7140      MOVE.w  d0,-(sp)            * clear the format string decimal point index
00FF258E  3F00                    7141      MOVE.w  d0,-(sp)            * clear the format string last index
00FF2590  3F00                    7142      MOVE.w  d0,-(sp)            * clear the format string this index
00FF2592  2F0A                    7143      MOVE.l  a2,-(sp)            * save the format string descriptor pointer
00FF2594                          7144  
00FF2594                          7145  * make a null return string for the first string add
00FF2594                          7146  
00FF2594  7200                    7147      MOVEQ       #0,d1               * make a null string
00FF2596  2041                    7148      MOVEA.l d1,a0               * with a null pointer
00FF2598  6100 EEA6               7149      BSR     LAB_RTST            * push a string on the descriptor stack
00FF259C                          7150                              * a0 = pointer, d1 = length
00FF259C                          7151  
00FF259C                          7152  * do the USING$() function next value
00FF259C                          7153  
00FF259C  101D                    7154      MOVE.b  (a5)+,d0            * get the next BASIC byte
00FF259E                          7155  LAB_U002
00FF259E  B03C 002C               7156      CMP.b       #',',d0         * compare with comma
00FF25A2  6600 DBFA               7157      BNE     LAB_SNER            * if not "," go do syntax error
00FF25A6                          7158  
00FF25A6  6100 028E               7159      BSR     LAB_ProcFo          * process the format string
00FF25AA  4A02                    7160      TST.b       d2              * test the special characters flag
00FF25AC  6700 DB9C               7161      BEQ     LAB_FOER            * if no special characters go do format error
00FF25B0                          7162  
00FF25B0  6100 E6CA               7163      BSR     LAB_EVEX            * evaluate the expression
00FF25B4  4A2B 09B5               7164      TST.b       Dtypef(a3)          * test the data type
00FF25B8  6B00 DBB8               7165      BMI     LAB_TMER            * if string type go do type missmatch error
00FF25BC                          7166  
00FF25BC  4A2B 0994               7167      TST.b       FAC1_e(a3)          * test FAC1 exponent
00FF25C0  6732                    7168      BEQ.s       LAB_U004            * if FAC1 = 0 skip the rounding
00FF25C2                          7169  
00FF25C2  322F 000A               7170      MOVE.w  fsdc(sp),d1         * get the format string decimal character count
00FF25C6  B27C 0008               7171      CMP.w       #8,d1               * compare the fraction digit count with 8
00FF25CA  6428                    7172      BCC.s       LAB_U004            * if >= 8 skip the rounding
00FF25CC                          7173  
00FF25CC  3001                    7174      MOVE.w  d1,d0               * else copy the fraction digit count
00FF25CE  D241                    7175      ADD.w       d1,d1               * * 2
00FF25D0  D240                    7176      ADD.w       d0,d1               * * 3
00FF25D2  D241                    7177      ADD.w       d1,d1               * * 6
00FF25D4  41FA 0844               7178      LEA     LAB_P_10(pc),a0     * get the rounding table base
00FF25D8  2770 1002 0998          7179      MOVE.l  2(a0,d1.w),FAC2_m(a3)   * get the rounding mantissa
00FF25DE  3030 1000               7180      MOVE.w  (a0,d1.w),d0        * get the rounding exponent
00FF25E2  0440 0100               7181      SUB.w       #$100,d0            * effectively divide the mantissa by 2
00FF25E6  3740 099C               7182      MOVE.w  d0,FAC2_e(a3)       * save the rounding exponent
00FF25EA  177C 0000 099E          7183      MOVE.b  #$00,FAC_sc(a3)     * clear the sign compare
00FF25F0  6100 F4F4               7184      BSR     LAB_ADD         * round the value to n places
00FF25F4                          7185  LAB_U004
00FF25F4  6100 F970               7186      BSR     LAB_2970            * convert FAC1 to string - not on stack
00FF25F8                          7187  
00FF25F8  6100 01FE               7188      BSR     LAB_DupFmt          * duplicate the processed format string section
00FF25FC                          7189                              * returns length in d1, pointer in a0
00FF25FC                          7190  
00FF25FC                          7191  * process the number string, length in d6, decimal point index in d2
00FF25FC                          7192  
00FF25FC  45EB 09C6               7193      LEA     Decss(a3),a2        * set the number string start
00FF2600  7C00                    7194      MOVEQ       #0,d6               * clear the number string index
00FF2602  782E                    7195      MOVEQ       #'.',d4         * set the decimal point character
00FF2604                          7196  LAB_U005
00FF2604  3406                    7197      MOVE.w  d6,d2               * save the index to flag the decimal point
00FF2606                          7198  LAB_U006
00FF2606  5246                    7199      ADDQ.w  #1,d6               * increment the number string index
00FF2608  1032 6000               7200      MOVE.b  (a2,d6.w),d0        * get a number string character
00FF260C  677A                    7201      BEQ.s       LAB_U010            * if null then number complete
00FF260E                          7202  
00FF260E  B03C 0045               7203      CMP.b       #'E',d0         * compare the character with an "E"
00FF2612  6706                    7204      BEQ.s       LAB_U008            * was sx[.x]Esxx so go handle sci notation
00FF2614                          7205  
00FF2614  B004                    7206      CMP.b       d4,d0               * compare the character with "."
00FF2616  66EE                    7207      BNE.s       LAB_U006            * if not decimal point go get the next digit
00FF2618                          7208  
00FF2618  60EA                    7209      BRA.s       LAB_U005            * go save the index and get the next digit
00FF261A                          7210  
00FF261A                          7211  * have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
00FF261A                          7212  
00FF261A                          7213  LAB_U008
00FF261A  3606                    7214      MOVE.w  d6,d3               * copy the index to the "E"
00FF261C  5343                    7215      SUBQ.w  #1,d3               * -1 gives the last digit index
00FF261E                          7216  
00FF261E  5246                    7217      ADDQ.w  #1,d6               * increment the index to the exponent sign
00FF2620  1032 6000               7218      MOVE.b  (a2,d6.w),d0        * get the exponent sign character
00FF2624  B03C 002D               7219      CMP.b       #'-',d0         * compare the exponent sign with "-"
00FF2628  6600 DB68               7220      BNE     LAB_FCER            * if it wasn't sx[.x]E-xx go do function
00FF262C                          7221                              * call error
00FF262C                          7222  
00FF262C                          7223  * found an sx[.x]E-xx number so check the exponent magnitude
00FF262C                          7224  
00FF262C  5246                    7225      ADDQ.w  #1,d6               * increment the index to the exponent 10s
00FF262E  1032 6000               7226      MOVE.b  (a2,d6.w),d0        * get the exponent 10s character
00FF2632  B03C 0030               7227      CMP.b       #'0',d0         * compare the exponent 10s with "0"
00FF2636  6704                    7228      BEQ.s       LAB_U009            * if it was sx[.x]E-0x go get the exponent
00FF2638                          7229                              * 1s character
00FF2638                          7230  
00FF2638  700A                    7231      MOVEQ       #10,d0          * else start writing at index 10
00FF263A  6008                    7232      BRA.s       LAB_U00A            * go copy the digits
00FF263C                          7233  
00FF263C                          7234  * found an sx[.x]E-0x number so get the exponent magnitude
00FF263C                          7235  
00FF263C                          7236  LAB_U009
00FF263C  5246                    7237      ADDQ.w  #1,d6               * increment the index to the exponent 1s
00FF263E  700F                    7238      MOVEQ       #$0F,d0         * set the mask for the exponent 1s digit
00FF2640  C032 6000               7239      AND.b       (a2,d6.w),d0        * get and convert the exponent 1s digit
00FF2644                          7240  LAB_U00A
00FF2644  3403                    7241      MOVE.w  d3,d2               * copy the number last digit index
00FF2646  0C42 0001               7242      CMPI.w  #1,d2               * is the number of the form sxE-0x
00FF264A  6602                    7243      BNE.s       LAB_U00B            * if it is sx.xE-0x skip the increment
00FF264C                          7244  
00FF264C                          7245                              * else make room for the decimal point
00FF264C  5242                    7246      ADDQ.w  #1,d2               * add 1 to the write index
00FF264E                          7247  LAB_U00B
00FF264E  D440                    7248      ADD.w       d0,d2               * add the exponent 1s to the write index
00FF2650  700A                    7249      MOVEQ       #10,d0          * set the maximum write index
00FF2652  9042                    7250      SUB.w       d2,d0               * compare the index with the maximum
00FF2654  6E0C                    7251      BGT.s       LAB_U00C            * if the index < the maximum continue
00FF2656                          7252  
00FF2656  D440                    7253      ADD.w       d0,d2               * else set the index to the maximum
00FF2658  D640                    7254      ADD.w       d0,d3               * adjust the read index
00FF265A  0C43 0001               7255      CMPI.w  #1,d3               * compare the adjusted index with 1
00FF265E  6E02                    7256      BGT.s       LAB_U00C            * if > 1 continue
00FF2660                          7257  
00FF2660  7600                    7258      MOVEQ       #0,d3               * else allow for the decimal point
00FF2662                          7259  LAB_U00C
00FF2662  3C02                    7260      MOVE.       d2,d6               * copy the write index as the number
00FF2664                          7261                              * string length
00FF2664  7000                    7262      MOVEQ       #0,d0               * clear d0 to null terminate the number
00FF2666                          7263                              * string
00FF2666                          7264  LAB_U00D
00FF2666  1580 2000               7265      MOVE.b  d0,(a2,d2.w)        * save the character to the number string
00FF266A  5342                    7266      SUBQ.w  #1,d2               * decrement the number write index
00FF266C  0C42 0001               7267      CMPI.w  #1,d2               * compare the number write index with 1
00FF2670  6712                    7268      BEQ.s       LAB_U00F            * if at the decimal point go save it
00FF2672                          7269  
00FF2672                          7270                              * else write a digit to the number string
00FF2672  7030                    7271      MOVEQ       #'0',d0         * default to "0"
00FF2674  4A43                    7272      TST.w       d3              * test the number read index
00FF2676  67EE                    7273      BEQ.s       LAB_U00D            * if zero just go save the "0"
00FF2678                          7274  
00FF2678                          7275  LAB_U00E
00FF2678  1032 3000               7276      MOVE.b  (a2,d3.w),d0        * read the next number digit
00FF267C  5343                    7277      SUBQ.w  #1,d3               * decrement the read index
00FF267E  B004                    7278      CMP.b       d4,d0               * compare the digit with "."
00FF2680  66E4                    7279      BNE.s       LAB_U00D            * if not "." go save the digit
00FF2682                          7280  
00FF2682  60F4                    7281      BRA.s       LAB_U00E            * else go get the next digit
00FF2684                          7282  
00FF2684                          7283  LAB_U00F
00FF2684  1584 2000               7284      MOVE.b  d4,(a2,d2.w)        * save the decimal point
00FF2688                          7285  LAB_U010
00FF2688  4A42                    7286      TST.w       d2              * test the number string decimal point index
00FF268A  6602                    7287      BNE.s       LAB_U014            * if dp present skip the reset
00FF268C                          7288  
00FF268C  3406                    7289      MOVE.w  d6,d2               * make the decimal point index = the length
00FF268E                          7290  
00FF268E                          7291  * copy the fractional digit characters from the number string
00FF268E                          7292  
00FF268E                          7293  LAB_U014
00FF268E  3602                    7294      MOVE.w  d2,d3               * copy the number string decimal point index
00FF2690  5243                    7295      ADDQ.w  #1,d3               * increment the number string index
00FF2692  382F 0008               7296      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00FF2696                          7297  LAB_U018
00FF2696  5244                    7298      ADDQ.w  #1,d4               * increment the new format string index
00FF2698  B244                    7299      CMP.w       d4,d1               * compare it with the new format string length
00FF269A  6322                    7300      BLS.s       LAB_U022            * if done the fraction digits go do integer
00FF269C                          7301  
00FF269C  1030 4000               7302      MOVE.b  (a0,d4.w),d0        * get a new format string character
00FF26A0  B03C 0025               7303      CMP.b       #'%',d0         * compare it with "%"
00FF26A4  6706                    7304      BEQ.s       LAB_U01C            * if "%" go copy a number character
00FF26A6                          7305  
00FF26A6  B03C 0023               7306      CMP.b       #'#',d0         * compare it with "#"
00FF26AA  66EA                    7307      BNE.s       LAB_U018            * if not "#" go do the next new format character
00FF26AC                          7308  
00FF26AC                          7309  LAB_U01C
00FF26AC  7030                    7310      MOVEQ       #'0',d0         * default to "0" character
00FF26AE  BC43                    7311      CMP.w       d3,d6               * compare the number string index with length
00FF26B0  6306                    7312      BLS.s       LAB_U020            * if there skip the character get
00FF26B2                          7313  
00FF26B2  1032 3000               7314      MOVE.b  (a2,d3.w),d0        * get a character from the number string
00FF26B6  5243                    7315      ADDQ.w  #1,d3               * increment the number string index
00FF26B8                          7316  LAB_U020
00FF26B8  1180 4000               7317      MOVE.b  d0,(a0,d4.w)        * save the number character to the new format
00FF26BC                          7318                              * string
00FF26BC  60D8                    7319      BRA.s       LAB_U018            * go do the next new format character
00FF26BE                          7320  
00FF26BE                          7321  * now copy the integer digit characters from the number string
00FF26BE                          7322  
00FF26BE                          7323  LAB_U022
00FF26BE  7C00                    7324      MOVEQ       #0,d6               * clear the sign done flag
00FF26C0  7A00                    7325      MOVEQ       #0,d5               * clear the sign present flag
00FF26C2  5342                    7326      SUBQ.w  #1,d2               * decrement the number string index
00FF26C4  6608                    7327      BNE.s       LAB_U026            * if not now at sign continue
00FF26C6                          7328  
00FF26C6  7401                    7329      MOVEQ       #1,d2               * increment the number string index
00FF26C8  15BC 0030 2000          7330      MOVE.b  #'0',(a2,d2.w)      * replace the point with a zero
00FF26CE                          7331  LAB_U026
00FF26CE  382F 0008               7332      MOVE.w  fsdpi(sp),d4        * get the new format string decimal point index
00FF26D2  B244                    7333      CMP.w       d4,d1               * compare it with the new format string length
00FF26D4  6402                    7334      BCC.s       LAB_U02A            * if within the string go use the index
00FF26D6                          7335  
00FF26D6  3801                    7336      MOVE.w  d1,d4               * else set the index to the end of the string
00FF26D8                          7337  LAB_U02A
00FF26D8  5344                    7338      SUBQ.w  #1,d4               * decrement the new format string index
00FF26DA  6B62                    7339      BMI.s       LAB_U03E            * if all done go test for any overflow
00FF26DC                          7340  
00FF26DC  1030 4000               7341      MOVE.b  (a0,d4.w),d0        * else get a new format string character
00FF26E0                          7342  
00FF26E0  7E30                    7343      MOVEQ       #'0',d7         * default to "0" character
00FF26E2  B03C 0025               7344      CMP.b       #'%',d0         * compare it with "%"
00FF26E6  6708                    7345      BEQ.s       LAB_U02B            * if "%" go copy a number character
00FF26E8                          7346  
00FF26E8  7E20                    7347      MOVEQ       #' ',d7         * default to " " character
00FF26EA  B03C 0023               7348      CMP.b       #'#',d0         * compare it with "#"
00FF26EE  6606                    7349      BNE.s       LAB_U02C            * if not "#" go try ","
00FF26F0                          7350  
00FF26F0                          7351  LAB_U02B
00FF26F0  4A42                    7352      TST.w       d2              * test the number string index
00FF26F2  6634                    7353      BNE.s       LAB_U036            * if not at the sign go get a number character
00FF26F4                          7354  
00FF26F4  6042                    7355      BRA.s       LAB_U03C            * else go save the default character
00FF26F6                          7356  
00FF26F6                          7357  LAB_U02C
00FF26F6  B03C 002C               7358      CMP.b       #',',d0         * compare it with ","
00FF26FA  6610                    7359      BNE.s       LAB_U030            * if not "," go try the sign characters
00FF26FC                          7360  
00FF26FC  4A42                    7361      TST.w       d2              * test the number string index
00FF26FE  6608                    7362      BNE.s       LAB_U02E            * if not at the sign keep the ","
00FF2700                          7363  
00FF2700  0C30 0025 40FF          7364      CMP.b       #'%',-1(a0,d4.w)        * else compare the next format string character
00FF2706                          7365                              * with "%"
00FF2706  6630                    7366      BNE.s       LAB_U03C            * if not "%" keep the default character
00FF2708                          7367  
00FF2708                          7368  LAB_U02E
00FF2708  1E00                    7369      MOVE.b  d0,d7               * else use the "," character
00FF270A  602C                    7370      BRA.s       LAB_U03C            * go save the character to the string
00FF270C                          7371  
00FF270C                          7372  LAB_U030
00FF270C  B03C 002D               7373      CMP.b       #'-',d0         * compare it with "-"
00FF2710  6710                    7374      BEQ.s       LAB_U034            * if "-" go do the sign character
00FF2712                          7375  
00FF2712  B03C 002B               7376      CMP.b       #'+',d0         * compare it with "+"
00FF2716  66C0                    7377      BNE.s       LAB_U02A            * if not "+" go do the next new format character
00FF2718                          7378  
00FF2718  0C12 002D               7379      CMP.b       #'-',(a2)           * compare the sign character with "-"
00FF271C  6704                    7380      BEQ.s       LAB_U034            * if "-" don't change the sign character
00FF271E                          7381  
00FF271E  14BC 002B               7382      MOVE.b  #'+',(a2)           * else make the sign character "+"
00FF2722                          7383  LAB_U034
00FF2722  1A00                    7384      MOVE.b  d0,d5               * set the sign present flag
00FF2724  4A42                    7385      TST.w       d2              * test the number string index
00FF2726  6708                    7386      BEQ.s       LAB_U038            * if at the sign keep the default character
00FF2728                          7387  
00FF2728                          7388  LAB_U036
00FF2728  1E32 2000               7389      MOVE.b  (a2,d2.w),d7        * else get a character from the number string
00FF272C  5342                    7390      SUBQ.w  #1,d2               * decrement the number string index
00FF272E  6008                    7391      BRA.s       LAB_U03C            * go save the character
00FF2730                          7392  
00FF2730                          7393  LAB_U038
00FF2730  4A06                    7394      TST.b       d6              * test the sign done flag
00FF2732  6604                    7395      BNE.s       LAB_U03C            * if the sign has been done go use the space
00FF2734                          7396                              * character
00FF2734                          7397  
00FF2734  1E12                    7398      MOVE.b  (a2),d7         * else get the sign character
00FF2736  1C07                    7399      MOVE.b  d7,d6               * flag that the sign has been done
00FF2738                          7400  LAB_U03C
00FF2738  1187 4000               7401      MOVE.b  d7,(a0,d4.w)        * save the number character to the new format
00FF273C                          7402                              * string
00FF273C  609A                    7403      BRA.s       LAB_U02A            * go do the next new format character
00FF273E                          7404  
00FF273E                          7405  * test for overflow conditions
00FF273E                          7406  
00FF273E                          7407  LAB_U03E
00FF273E  4A42                    7408      TST.w       d2              * test the number string index
00FF2740  6614                    7409      BNE.s       LAB_U040            * if all the digits aren't done go output
00FF2742                          7410                              * an overflow indication
00FF2742                          7411  
00FF2742                          7412  * test for sign overflows
00FF2742                          7413  
00FF2742  4A05                    7414      TST.b       d5              * test the sign present flag
00FF2744  6754                    7415      BEQ.s       LAB_U04A            * if no sign present go add the string
00FF2746                          7416  
00FF2746                          7417  * there was a sign in the format string
00FF2746                          7418  
00FF2746  4A06                    7419      TST.b       d6              * test the sign done flag
00FF2748  6650                    7420      BNE.s       LAB_U04A            * if the sign is done go add the string
00FF274A                          7421  
00FF274A                          7422  * the sign isn't done so see if it was mandatory
00FF274A                          7423  
00FF274A  0C05 002B               7424      CMPI.b  #'+',d5         * compare the sign with "+"
00FF274E  6706                    7425      BEQ.s       LAB_U040            * if it was "+" go output an overflow
00FF2750                          7426                              * indication
00FF2750                          7427  
00FF2750                          7428  * the sign wasn't mandatory but the number may have been negative
00FF2750                          7429  
00FF2750  0C12 002D               7430      CMP.b       #'-',(a2)           * compare the sign character with "-"
00FF2754  6644                    7431      BNE.s       LAB_U04A            * if it wasn't "-" go add the string
00FF2756                          7432  
00FF2756                          7433  * else the sign was "-" and a sign hasn't been output so ..
00FF2756                          7434  
00FF2756                          7435  * the number overflowed the format string so replace all the special format characters
00FF2756                          7436  * with the overflow character
00FF2756                          7437  
00FF2756                          7438  LAB_U040
00FF2756  7A23                    7439      MOVEQ       #ofchr,d5           * set the overflow character
00FF2758  3E01                    7440      MOVE.w  d1,d7               * copy the new format string length
00FF275A  5347                    7441      SUBQ.w  #1,d7               * adjust for the loop type
00FF275C  3C2F 0004               7442      MOVE.w  fsti(sp),d6         * copy the new format string last index
00FF2760  5346                    7443      SUBQ.w  #1,d6               * -1 gives the last character of this string
00FF2762  6E02                    7444      BGT.s       LAB_U044            * if not zero continue
00FF2764                          7445  
00FF2764  3C07                    7446      MOVE.w  d7,d6               * else set the format string index to the end
00FF2766                          7447  LAB_U044
00FF2766  1031 6000               7448      MOVE.b  (a1,d6.w),d0        * get a character from the format string
00FF276A  0C00 0023               7449      CMPI.b  #'#',d0         * compare it with "#" special format character
00FF276E  671E                    7450      BEQ.s       LAB_U046            * if "#" go use the overflow character
00FF2770                          7451  
00FF2770  0C00 0025               7452      CMPI.b  #'%',d0         * compare it with "%" special format character
00FF2774  6718                    7453      BEQ.s       LAB_U046            * if "%" go use the overflow character
00FF2776                          7454  
00FF2776  0C00 002C               7455      CMPI.b  #',',d0         * compare it with "," special format character
00FF277A  6712                    7456      BEQ.s       LAB_U046            * if "," go use the overflow character
00FF277C                          7457  
00FF277C  0C00 002B               7458      CMPI.b  #'+',d0         * compare it with "+" special format character
00FF2780  670C                    7459      BEQ.s       LAB_U046            * if "+" go use the overflow character
00FF2782                          7460  
00FF2782  0C00 002D               7461      CMPI.b  #'-',d0         * compare it with "-" special format character
00FF2786  6706                    7462      BEQ.s       LAB_U046            * if "-" go use the overflow character
00FF2788                          7463  
00FF2788  0C00 002E               7464      CMPI.b  #'.',d0         * compare it with "." special format character
00FF278C  6602                    7465      BNE.s       LAB_U048            * if not "." skip the using overflow character
00FF278E                          7466  
00FF278E                          7467  LAB_U046
00FF278E  1005                    7468      MOVE.b  d5,d0               * use the overflow character
00FF2790                          7469  LAB_U048
00FF2790  1180 7000               7470      MOVE.b  d0,(a0,d7.w)        * save the character to the new format string
00FF2794  5346                    7471      SUBQ.w  #1,d6               * decrement the format string index
00FF2796  51CF FFCE               7472      DBF     d7,LAB_U044         * decrement the count and loop if not all done
00FF279A                          7473  
00FF279A                          7474  * add the new string to the previous string
00FF279A                          7475  
00FF279A                          7476  LAB_U04A
00FF279A  41EC 0006               7477      LEA     6(a4),a0            * get the descriptor pointer for string 1
00FF279E  274C 0990               7478      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00FF27A2  6100 EDEC               7479      BSR     LAB_224E            * concatenate the strings
00FF27A6                          7480  
00FF27A6                          7481  * now check for any tail on the format string
00FF27A6                          7482  
00FF27A6  302F 0004               7483      MOVE.w  fsti(sp),d0         * get this index
00FF27AA  6720                    7484      BEQ.s       LAB_U04C            * if at start of string skip the output
00FF27AC                          7485  
00FF27AC  3F40 0006               7486      MOVE.w  d0,fsli(sp)         * save this index to the last index
00FF27B0  6100 0084               7487      BSR     LAB_ProcFo          * now process the format string
00FF27B4  4A02                    7488      TST.b       d2              * test the special characters flag
00FF27B6  6614                    7489      BNE.s       LAB_U04C            * if special characters present skip the output
00FF27B8                          7490  
00FF27B8                          7491  * else output the new string part
00FF27B8                          7492  
00FF27B8  613E                    7493      BSR.s       LAB_DupFmt          * duplicate the processed format string section
00FF27BA  3F6F 0004 0006          7494      MOVE.w  fsti(sp),fsli(sp)       * copy this index to the last index
00FF27C0                          7495  
00FF27C0                          7496  * add the new string to the previous string
00FF27C0                          7497  
00FF27C0  41EC 0006               7498      LEA     6(a4),a0            * get the descriptor pointer for string 1
00FF27C4  274C 0990               7499      MOVE.l  a4,FAC1_m(a3)       * save the descriptor pointer for string 2
00FF27C8  6100 EDC6               7500      BSR     LAB_224E            * concatenate the strings
00FF27CC                          7501  
00FF27CC                          7502  * check for another value or end of function
00FF27CC                          7503  
00FF27CC                          7504  LAB_U04C
00FF27CC  101D                    7505      MOVE.b  (a5)+,d0            * get the next BASIC byte
00FF27CE  B03C 0029               7506      CMP.b       #')',d0         * compare with close bracket
00FF27D2  6600 FDCA               7507      BNE     LAB_U002            * if not ")" go do next value
00FF27D6                          7508  
00FF27D6                          7509  * pop the result string off the descriptor stack
00FF27D6                          7510  
00FF27D6  204C                    7511      MOVEA.l a4,a0               * copy the result string descriptor pointer
00FF27D8  222B 0846               7512      MOVE.l  Sstorl(a3),d1       * save the bottom of string space
00FF27DC  6100 EE14               7513      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00FF27E0                          7514                              * d0 = length, a0 = pointer
00FF27E0  2741 0846               7515      MOVE.l  d1,Sstorl(a3)       * restore the bottom of string space
00FF27E4  2248                    7516      MOVEA.l a0,a1               * copy the string result pointer
00FF27E6  3200                    7517      MOVE.w  d0,d1               * copy the string result length
00FF27E8                          7518  
00FF27E8                          7519  * pop the format string off the descriptor stack
00FF27E8                          7520  
00FF27E8  205F                    7521      MOVEA.l (sp)+,a0            * pull the format string descriptor pointer
00FF27EA  6100 EE06               7522      BSR     LAB_22BA            * pop (a0) descriptor, returns with ..
00FF27EE                          7523                              * d0 = length, a0 = pointer
00FF27EE                          7524  
00FF27EE  4FEF 0008               7525      LEA     fend(sp),sp         * dump the saved values
00FF27F2                          7526  
00FF27F2                          7527  * push the result string back on the descriptor stack and return
00FF27F2                          7528  
00FF27F2  2049                    7529      MOVEA.l a1,a0               * copy the result string pointer back
00FF27F4  6000 EC4A               7530      BRA     LAB_RTST            * push a string on the descriptor stack and
00FF27F8                          7531                              * return. a0 = pointer, d1 = length
00FF27F8                          7532  
00FF27F8                          7533  
00FF27F8                          7534  *************************************************************************************
00FF27F8                          7535  *
00FF27F8                          7536  * duplicate the processed format string section
00FF27F8                          7537  
00FF27F8                          7538                              * make a string as long as the format string
00FF27F8                          7539  LAB_DupFmt
00FF27F8  226F 0004               7540      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00FF27FC  3E29 0004               7541      MOVE.w  4(a1),d7            * get the format string length
00FF2800  342F 000A               7542      MOVE.w  4+fsli(sp),d2       * get the format string last index
00FF2804  3C2F 0008               7543      MOVE.w  4+fsti(sp),d6       * get the format string this index
00FF2808  3206                    7544      MOVE.w  d6,d1               * copy the format string this index
00FF280A  9242                    7545      SUB.w       d2,d1               * subtract the format string last index
00FF280C  6202                    7546      BHI.s       LAB_D002            * if > 0 skip the correction
00FF280E                          7547  
00FF280E  D247                    7548      ADD.w       d7,d1               * else add the format string length as the
00FF2810                          7549                              * correction
00FF2810                          7550  LAB_D002
00FF2810  6100 EC48               7551      BSR     LAB_2115            * make string space d1 bytes long
00FF2814                          7552                              * return a0/Sutill = pointer, others unchanged
00FF2814                          7553  
00FF2814                          7554  * push the new string on the descriptor stack
00FF2814                          7555  
00FF2814  6100 EC2A               7556      BSR     LAB_RTST            * push a string on the descriptor stack and
00FF2818                          7557                              * return. a0 = pointer, d1 = length
00FF2818                          7558  
00FF2818                          7559  * copy the characters from the format string
00FF2818                          7560  
00FF2818  226F 0004               7561      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00FF281C  2251                    7562      MOVEA.l (a1),a1         * get the format string pointer
00FF281E  7800                    7563      MOVEQ       #0,d4               * clear the new string index
00FF2820                          7564  LAB_D00A
00FF2820  11B1 2000 4000          7565      MOVE.b  (a1,d2.w),(a0,d4.w) * get a character from the format string and
00FF2826                          7566                              * save it to the new string
00FF2826  5244                    7567      ADDQ.w  #1,d4               * increment the new string index
00FF2828  5242                    7568      ADDQ.w  #1,d2               * increment the format string index
00FF282A  BE42                    7569      CMP.w       d2,d7               * compare the format index with the length
00FF282C  6602                    7570      BNE.s       LAB_D00E            * if not there skip the reset
00FF282E                          7571  
00FF282E  7400                    7572      MOVEQ       #0,d2               * else reset the format string index
00FF2830                          7573  LAB_D00E
00FF2830  BC42                    7574      CMP.w       d2,d6               * compare the index with this index
00FF2832  66EC                    7575      BNE.s       LAB_D00A            * if not equal go do the next character
00FF2834                          7576  
00FF2834  4E75                    7577      RTS
00FF2836                          7578  
00FF2836                          7579  
00FF2836                          7580  **************************************************************************************
00FF2836                          7581  *
00FF2836                          7582  * process the format string
00FF2836                          7583  
00FF2836                          7584  LAB_ProcFo
00FF2836  226F 0004               7585      MOVEA.l 4+fsd(sp),a1        * get the format string descriptor pointer
00FF283A  3E29 0004               7586      MOVE.w  4(a1),d7            * get the format string length
00FF283E  2251                    7587      MOVEA.l (a1),a1         * get the format string pointer
00FF2840  3C2F 000A               7588      MOVE.w  4+fsli(sp),d6       * get the format string last index
00FF2844                          7589  
00FF2844  3F47 000C               7590      MOVE.w  d7,4+fsdpi(sp)      * set the format string decimal point index
00FF2848  7A00                    7591      MOVEQ       #0,d5               * no decimal point
00FF284A  7600                    7592      MOVEQ       #0,d3               * no decimal characters
00FF284C  7400                    7593      MOVEQ       #0,d2               * no special characters
00FF284E                          7594  LAB_P004
00FF284E  1031 6000               7595      MOVE.b  (a1,d6.w),d0        * get a format string byte
00FF2852                          7596  
00FF2852  B03C 002C               7597      CMP.b       #',',d0         * compare it with ","
00FF2856  6742                    7598      BEQ.s       LAB_P01A            * if "," go do the next format string byte
00FF2858                          7599  
00FF2858  B03C 0023               7600      CMP.b       #'#',d0         * compare it with "#"
00FF285C  6706                    7601      BEQ.s       LAB_P008            * if "#" go flag special characters
00FF285E                          7602  
00FF285E  B03C 0025               7603      CMP.b       #'%',d0         * compare it with "%"
00FF2862  6608                    7604      BNE.s       LAB_P00C            * if not "%" go try "+"
00FF2864                          7605  
00FF2864                          7606  LAB_P008
00FF2864  4A85                    7607      TST.l       d5              * test the decimal point flag
00FF2866  6A10                    7608      BPL.s       LAB_P00E            * if no point skip counting decimal characters
00FF2868                          7609  
00FF2868  5243                    7610      ADDQ.w  #1,d3               * else increment the decimal character count
00FF286A  602E                    7611      BRA.s       LAB_P01A            * go do the next character
00FF286C                          7612  
00FF286C                          7613  LAB_P00C
00FF286C  B03C 002B               7614      CMP.b       #'+',d0         * compare it with "+"
00FF2870  6706                    7615      BEQ.s       LAB_P00E            * if "+" go flag special characters
00FF2872                          7616  
00FF2872  B03C 002D               7617      CMP.b       #'-',d0         * compare it with "-"
00FF2876  6604                    7618      BNE.s       LAB_P010            * if not "-" go check decimal point
00FF2878                          7619  
00FF2878                          7620  LAB_P00E
00FF2878  8400                    7621      OR.b        d0,d2               * flag special characters
00FF287A  601E                    7622      BRA.s       LAB_P01A            * go do the next character
00FF287C                          7623  
00FF287C                          7624  LAB_P010
00FF287C  B03C 002E               7625      CMP.b       #'.',d0         * compare it with "."
00FF2880  6614                    7626      BNE.s       LAB_P018            * if not "." go check next
00FF2882                          7627  
00FF2882                          7628  * "." a decimal point
00FF2882                          7629  
00FF2882  4A85                    7630      TST.l       d5              * if there is already a decimal point
00FF2884  6B14                    7631      BMI.s       LAB_P01A            * go do the next character
00FF2886                          7632  
00FF2886  3006                    7633      MOVE.w  d6,d0               * copy the decimal point index
00FF2888  906F 000A               7634      SUB.w       4+fsli(sp),d0       * calculate it from the scan start
00FF288C  3F40 000C               7635      MOVE.w  d0,4+fsdpi(sp)      * save the decimal point index
00FF2890  7AFF                    7636      MOVEQ       #-1,d5          * flag decimal point
00FF2892  8400                    7637      OR.b        d0,d2               * flag special characters
00FF2894  6004                    7638      BRA.s       LAB_P01A            * go do the next character
00FF2896                          7639  
00FF2896                          7640  * was not a special character
00FF2896                          7641  
00FF2896                          7642  LAB_P018
00FF2896  4A02                    7643      TST.b       d2              * test if there have been special characters
00FF2898  6608                    7644      BNE.s       LAB_P01E            * if so exit the format string process
00FF289A                          7645  
00FF289A                          7646  LAB_P01A
00FF289A  5246                    7647      ADDQ.w  #1,d6               * increment the format string index
00FF289C  BE46                    7648      CMP.w       d6,d7               * compare it with the format string length
00FF289E  62AE                    7649      BHI.s       LAB_P004            * if length > index go get the next character
00FF28A0                          7650  
00FF28A0  7C00                    7651      MOVEQ       #0,d6               * length = index so reset the format string
00FF28A2                          7652                              * index
00FF28A2                          7653  LAB_P01E
00FF28A2  3F46 0008               7654      MOVE.w  d6,4+fsti(sp)       * save the format string this index
00FF28A6  3F43 000E               7655      MOVE.w  d3,4+fsdc(sp)       * save the format string decimal characters
00FF28AA                          7656  
00FF28AA  4E75                    7657      RTS
00FF28AC                          7658  
00FF28AC                          7659  
00FF28AC                          7660  *************************************************************************************
00FF28AC                          7661  *
00FF28AC                          7662  * perform BIN$()
00FF28AC                          7663  * # of leading 0s is in d1, the number is in d0
00FF28AC                          7664  
00FF28AC                          7665  LAB_BINS
00FF28AC  B23C 0021               7666      CMP.b       #$21,d1         * max + 1
00FF28B0  6400 D8E0               7667      BCC     LAB_FCER            * exit if too big ( > or = )
00FF28B4                          7668  
00FF28B4  741F                    7669      MOVEQ       #$1F,d2         * bit count-1
00FF28B6  41EB 09B6               7670      LEA     Binss(a3),a0        * point to string
00FF28BA  7830                    7671      MOVEQ       #$30,d4         * "0" character for ADDX
00FF28BC                          7672  NextB1
00FF28BC  7600                    7673      MOVEQ       #0,d3               * clear byte
00FF28BE  E288                    7674      LSR.l       #1,d0               * shift bit into Xb
00FF28C0  D704                    7675      ADDX.b  d4,d3               * add carry and character to zero
00FF28C2  1183 2000               7676      MOVE.b  d3,(a0,d2.w)        * save character to string
00FF28C6  51CA FFF4               7677      DBF     d2,NextB1           * decrement and loop if not done
00FF28CA                          7678  
00FF28CA                          7679  * this is the exit code and is also used by HEX$()
00FF28CA                          7680  
00FF28CA                          7681  EndBHS
00FF28CA  177C 0000 09D6          7682      MOVE.b  #0,BHsend(a3)       * null terminate the string
00FF28D0  4A01                    7683      TST.b       d1              * test # of characters
00FF28D2  670E                    7684      BEQ.s       NextB2          * go truncate string
00FF28D4                          7685  
00FF28D4  4481                    7686      NEG.l       d1              * make -ve
00FF28D6  0681 000009D6           7687      ADD.l       #BHsend,d1          * effectively (end-length)
00FF28DC  41F3 1000               7688      LEA     0(a3,d1.w),a0       * effectively add (end-length) to pointer
00FF28E0  600E                    7689      BRA.s       BinPr               * go print string
00FF28E2                          7690  
00FF28E2                          7691  * truncate string to remove leading "0"s
00FF28E2                          7692  
00FF28E2                          7693  NextB2
00FF28E2  1010                    7694      MOVE.b  (a0),d0         * get byte
00FF28E4  670A                    7695      BEQ.s       BinPr               * if null then end of string so add 1 and go
00FF28E6                          7696                              * print it
00FF28E6                          7697  
00FF28E6  B03C 0030               7698      CMP.b       #'0',d0         * compare with "0"
00FF28EA  660E                    7699      BNE.s       GoPr                * if not "0" then go print string from here
00FF28EC                          7700  
00FF28EC  5248                    7701      ADDQ.w  #1,a0               * else increment pointer
00FF28EE  60F2                    7702      BRA.s       NextB2          * loop always
00FF28F0                          7703  
00FF28F0                          7704  * make fixed length output string - ignore overflows!
00FF28F0                          7705  
00FF28F0                          7706  BinPr
00FF28F0  43EB 09D6               7707      LEA     BHsend(a3),a1       * get string end
00FF28F4  B1C9                    7708      CMPA.l  a1,a0               * are we at the string end
00FF28F6  6602                    7709      BNE.s       GoPr                * branch if not
00FF28F8                          7710  
00FF28F8  5348                    7711      SUBQ.w  #1,a0               * else need at least one zero
00FF28FA                          7712  GoPr
00FF28FA  6000 EAFE               7713      BRA     LAB_20AE            * print " terminated string to FAC1, stack & RET
00FF28FE                          7714  
00FF28FE                          7715  
00FF28FE                          7716  *************************************************************************************
00FF28FE                          7717  *
00FF28FE                          7718  * perform HEX$()
00FF28FE                          7719  * # of leading 0s is in d1, the number is in d0
00FF28FE                          7720  
00FF28FE                          7721  LAB_HEXS
00FF28FE  B23C 0009               7722      CMP.b       #$09,d1         * max + 1
00FF2902  6400 D88E               7723      BCC     LAB_FCER            * exit if too big ( > or = )
00FF2906                          7724  
00FF2906  7407                    7725      MOVEQ       #$07,d2         * nibble count-1
00FF2908  41EB 09CE               7726      LEA     Hexss(a3),a0        * point to string
00FF290C  7830                    7727      MOVEQ       #$30,d4         * "0" character for ABCD
00FF290E                          7728  NextH1
00FF290E  1600                    7729      MOVE.b  d0,d3               * copy lowest byte
00FF2910  E898                    7730      ROR.l       #4,d0               * shift nibble into 0-3
00FF2912  C63C 000F               7731      AND.b       #$0F,d3         * just this nibble
00FF2916  1A03                    7732      MOVE.b  d3,d5               * copy it
00FF2918  0605 00F6               7733      ADD.b       #$F6,d5         * set extend bit
00FF291C  C704                    7734      ABCD        d4,d3               * decimal add extend and character to zero
00FF291E  1183 2000               7735      MOVE.b  d3,(a0,d2.w)        * save character to string
00FF2922  51CA FFEA               7736      DBF     d2,NextH1           * decrement and loop if not done
00FF2926                          7737  
00FF2926  60A2                    7738      BRA.s       EndBHS          * go process string
00FF2928                          7739  
00FF2928                          7740  
00FF2928                          7741  *************************************************************************************
00FF2928                          7742  *
00FF2928                          7743  * ctrl-c check routine. includes limited "life" byte save for INGET routine
00FF2928                          7744  
00FF2928                          7745  VEC_CC
00FF2928  4A2B 09E8               7746      TST.b       ccflag(a3)          * check [CTRL-C] check flag
00FF292C  661E                    7747      BNE.s       RTS_022         * exit if [CTRL-C] check inhibited
00FF292E                          7748  
00FF292E  4EAB 080C               7749      JSR     V_INPT(a3)          * scan input device
00FF2932  640E                    7750      BCC.s       LAB_FBA0            * exit if buffer empty
00FF2934                          7751  
00FF2934  1740 09E9               7752      MOVE.b  d0,ccbyte(a3)       * save received byte
00FF2938  177C 0020 09EA          7753      MOVE.b  #$20,ccnull(a3)     * set "life" timer for bytes countdown
00FF293E  6000 DCC6               7754      BRA     LAB_1636            * return to BASIC
00FF2942                          7755  
00FF2942                          7756  LAB_FBA0
00FF2942  4A2B 09EA               7757      TST.b       ccnull(a3)          * get countdown byte
00FF2946  6704                    7758      BEQ.s       RTS_022         * exit if finished
00FF2948                          7759  
00FF2948  532B 09EA               7760      SUBQ.b  #1,ccnull(a3)       * else decrement countdown
00FF294C                          7761  RTS_022
00FF294C  4E75                    7762      RTS
00FF294E                          7763  
00FF294E                          7764  
00FF294E                          7765  *************************************************************************************
00FF294E                          7766  *
00FF294E                          7767  * get byte from input device, no waiting
00FF294E                          7768  * returns with carry set if byte in A
00FF294E                          7769  
00FF294E                          7770  INGET
00FF294E  4EAB 080C               7771      JSR     V_INPT(a3)          * call scan input device
00FF2952  650A                    7772      BCS.s       LAB_FB95            * if byte go reset timer
00FF2954                          7773  
00FF2954  102B 09EA               7774      MOVE.b  ccnull(a3),d0       * get countdown
00FF2958  67F2                    7775      BEQ.s       RTS_022         * exit if empty
00FF295A                          7776  
00FF295A  102B 09E9               7777      MOVE.b  ccbyte(a3),d0       * get last received byte
00FF295E                          7778  LAB_FB95
00FF295E  177C 0000 09EA          7779      MOVE.b  #$00,ccnull(a3)     * clear timer because we got a byte
00FF2964  003C 0001               7780      ORI.b       #1,CCR          * set carry, flag we got a byte
00FF2968  4E75                    7781      RTS
00FF296A                          7782  
00FF296A                          7783  
00FF296A                          7784  *************************************************************************************
00FF296A                          7785  *
00FF296A                          7786  * perform MAX()
00FF296A                          7787  
00FF296A                          7788  LAB_MAX
00FF296A  6100 E312               7789      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00FF296E  4A2B 09B5               7790      TST.b       Dtypef(a3)          * test data type
00FF2972  6B00 D7FE               7791      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00FF2976                          7792  
00FF2976                          7793  LAB_MAXN
00FF2976  612E                    7794      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00FF2978                          7795                              * pull FAC2 & compare with FAC1
00FF2978  64FC                    7796      BCC.s       LAB_MAXN            * branch if no swap to do
00FF297A                          7797  
00FF297A  6100 F4A8               7798      BSR     LAB_279B            * copy FAC2 to FAC1
00FF297E  60F6                    7799      BRA.s       LAB_MAXN            * go do next
00FF2980                          7800  
00FF2980                          7801  
00FF2980                          7802  *************************************************************************************
00FF2980                          7803  *
00FF2980                          7804  * perform MIN()
00FF2980                          7805  
00FF2980                          7806  LAB_MIN
00FF2980  6100 E2FC               7807      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00FF2984  4A2B 09B5               7808      TST.b       Dtypef(a3)          * test data type
00FF2988  6B00 D7E8               7809      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00FF298C                          7810  
00FF298C                          7811  LAB_MINN
00FF298C  6118                    7812      BSR.s       LAB_PHFA            * push FAC1, evaluate expression,
00FF298E                          7813                              * pull FAC2 & compare with FAC1
00FF298E  63FC                    7814      BLS.s       LAB_MINN            * branch if no swap to do
00FF2990                          7815  
00FF2990  6100 F492               7816      BSR     LAB_279B            * copy FAC2 to FAC1
00FF2994  60F6                    7817      BRA.s       LAB_MINN            * go do next (branch always)
00FF2996                          7818  
00FF2996                          7819  * exit routine. don't bother returning to the loop code
00FF2996                          7820  * check for correct exit, else so syntax error
00FF2996                          7821  
00FF2996                          7822  LAB_MMEC
00FF2996  B03C 0029               7823      CMP.b       #')',d0         * is it end of function?
00FF299A  6600 D802               7824      BNE     LAB_SNER            * if not do MAX MIN syntax error
00FF299E                          7825  
00FF299E  4FEF 0004               7826      LEA     4(sp),sp            * dump return address (faster)
00FF29A2  6000 E438               7827      BRA     LAB_IGBY            * update BASIC execute pointer (to chr past ")")
00FF29A6                          7828                              * and return
00FF29A6                          7829  
00FF29A6                          7830  * check for next, evaluate & return or exit
00FF29A6                          7831  * this is the routine that does most of the work
00FF29A6                          7832  
00FF29A6                          7833  LAB_PHFA
00FF29A6  6100 E436               7834      BSR     LAB_GBYT            * get next BASIC byte
00FF29AA  B03C 002C               7835      CMP.b       #',',d0         * is there more ?
00FF29AE  66E6                    7836      BNE.s       LAB_MMEC            * if not go do end check
00FF29B0                          7837  
00FF29B0  3F2B 0994               7838      MOVE.w  FAC1_e(a3),-(sp)        * push exponent and sign
00FF29B4  2F2B 0990               7839      MOVE.l  FAC1_m(a3),-(sp)        * push mantissa
00FF29B8                          7840  
00FF29B8  6100 E2C4               7841      BSR     LAB_EVEZ            * evaluate expression (no decrement)
00FF29BC  4A2B 09B5               7842      TST.b       Dtypef(a3)          * test data type
00FF29C0  6B00 D7B0               7843      BMI     LAB_TMER            * if string do Type missmatch Error/warm start
00FF29C4                          7844  
00FF29C4                          7845  
00FF29C4                          7846                              * pop FAC2 (MAX/MIN expression so far)
00FF29C4  275F 0998               7847      MOVE.l  (sp)+,FAC2_m(a3)        * pop mantissa
00FF29C8                          7848  
00FF29C8  301F                    7849      MOVE.w  (sp)+,d0            * pop exponent and sign
00FF29CA  3740 099C               7850      MOVE.w  d0,FAC2_e(a3)       * save exponent and sign
00FF29CE  176B 0995 099E          7851      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * get FAC1 sign
00FF29D4  B12B 099E               7852      EOR.b       d0,FAC_sc(a3)       * EOR to create sign compare
00FF29D8  6000 F4B6               7853      BRA     LAB_27FA            * compare FAC1 with FAC2 & return
00FF29DC                          7854                              * returns d0=+1 Cb=0 if FAC1 > FAC2
00FF29DC                          7855                              * returns d0= 0 Cb=0 if FAC1 = FAC2
00FF29DC                          7856                              * returns d0=-1 Cb=1 if FAC1 < FAC2
00FF29DC                          7857  
00FF29DC                          7858  
00FF29DC                          7859  *************************************************************************************
00FF29DC                          7860  *
00FF29DC                          7861  * perform WIDTH
00FF29DC                          7862  
00FF29DC                          7863  LAB_WDTH
00FF29DC  B03C 002C               7864      CMP.b       #',',d0         * is next byte ","
00FF29E0  672C                    7865      BEQ.s       LAB_TBSZ            * if so do tab size
00FF29E2                          7866  
00FF29E2  6100 ED6A               7867      BSR     LAB_GTBY            * get byte parameter, result in d0 and Itemp
00FF29E6  4A00                    7868      TST.b       d0              * test result
00FF29E8  6712                    7869      BEQ.s       LAB_NSTT            * branch if set for infinite line
00FF29EA                          7870  
00FF29EA  B03C 0010               7871      CMP.b       #$10,d0         * else make min width = 16d
00FF29EE  6500 D7A2               7872      BCS     LAB_FCER            * if less do function call error & exit
00FF29F2                          7873  
00FF29F2                          7874  * this next compare ensures that we can't exit WIDTH via an error leaving the
00FF29F2                          7875  * tab size greater than the line length.
00FF29F2                          7876  
00FF29F2  B02B 09E2               7877      CMP.b       TabSiz(a3),d0       * compare with tab size
00FF29F6  6404                    7878      BCC.s       LAB_NSTT            * branch if >= tab size
00FF29F8                          7879  
00FF29F8  1740 09E2               7880      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
00FF29FC                          7881  LAB_NSTT
00FF29FC  1740 09E6               7882      MOVE.b  d0,TWidth(a3)       * set the terminal width
00FF2A00  6100 E3DC               7883      BSR     LAB_GBYT            * get BASIC byte back
00FF2A04  672C                    7884      BEQ.s       WExit               * exit if no following
00FF2A06                          7885  
00FF2A06  B03C 002C               7886      CMP.b       #',',d0         * else is it ","
00FF2A0A  6600 D792               7887      BNE     LAB_SNER            * if not do syntax error
00FF2A0E                          7888  
00FF2A0E                          7889  LAB_TBSZ
00FF2A0E  6100 ED3A               7890      BSR     LAB_SGBY            * increment and get byte, result in d0 and Itemp
00FF2A12  4A00                    7891      TST.b       d0              * test TAB size
00FF2A14  6B00 D77C               7892      BMI     LAB_FCER            * if >127 do function call error & exit
00FF2A18                          7893  
00FF2A18  B03C 0001               7894      CMP.b       #1,d0               * compare with min-1
00FF2A1C  6500 D774               7895      BCS     LAB_FCER            * if <=1 do function call error & exit
00FF2A20                          7896  
00FF2A20  122B 09E6               7897      MOVE.b  TWidth(a3),d1       * set flags for width
00FF2A24  6708                    7898      BEQ.s       LAB_SVTB            * skip check if infinite line
00FF2A26                          7899  
00FF2A26  B02B 09E6               7900      CMP.b       TWidth(a3),d0       * compare TAB with width
00FF2A2A  6E00 D766               7901      BGT     LAB_FCER            * branch if too big
00FF2A2E                          7902  
00FF2A2E                          7903  LAB_SVTB
00FF2A2E  1740 09E2               7904      MOVE.b  d0,TabSiz(a3)       * save TAB size
00FF2A32                          7905  
00FF2A32                          7906  * calculate tab column limit from TAB size. The Iclim is set to the last tab
00FF2A32                          7907  * position on a line that still has at least one whole tab width between it
00FF2A32                          7908  * and the end of the line.
00FF2A32                          7909  
00FF2A32                          7910  WExit
00FF2A32  102B 09E6               7911      MOVE.b  TWidth(a3),d0       * get width
00FF2A36  670A                    7912      BEQ.s       LAB_WDLP            * branch if infinite line
00FF2A38                          7913  
00FF2A38  B02B 09E2               7914      CMP.b       TabSiz(a3),d0       * compare with tab size
00FF2A3C  6404                    7915      BCC.s       LAB_WDLP            * branch if >= tab size
00FF2A3E                          7916  
00FF2A3E  1740 09E2               7917      MOVE.b  d0,TabSiz(a3)       * else make tab size = terminal width
00FF2A42                          7918  LAB_WDLP
00FF2A42  902B 09E2               7919      SUB.b       TabSiz(a3),d0       * subtract tab size
00FF2A46  64FA                    7920      BCC.s       LAB_WDLP            * loop while no borrow
00FF2A48                          7921  
00FF2A48  D02B 09E2               7922      ADD.b       TabSiz(a3),d0       * add tab size back
00FF2A4C  D02B 09E2               7923      ADD.b       TabSiz(a3),d0       * add tab size back again
00FF2A50                          7924  
00FF2A50  4400                    7925      NEG.b       d0              * make -ve
00FF2A52  D02B 09E6               7926      ADD.b       TWidth(a3),d0       * subtract remainder from width
00FF2A56  1740 09E7               7927      MOVE.b  d0,Iclim(a3)        * save tab column limit
00FF2A5A                          7928  RTS_023
00FF2A5A  4E75                    7929      RTS
00FF2A5C                          7930  
00FF2A5C                          7931  
00FF2A5C                          7932  *************************************************************************************
00FF2A5C                          7933  *
00FF2A5C                          7934  * perform SQR()
00FF2A5C                          7935  
00FF2A5C                          7936  * d0 is number to find the root of
00FF2A5C                          7937  * d1 is the root result
00FF2A5C                          7938  * d2 is the remainder
00FF2A5C                          7939  * d3 is a counter
00FF2A5C                          7940  * d4 is temp
00FF2A5C                          7941  
00FF2A5C                          7942  LAB_SQR
00FF2A5C  4A2B 0995               7943      TST.b       FAC1_s(a3)          * test FAC1 sign
00FF2A60  6B00 D730               7944      BMI     LAB_FCER            * if -ve do function call error
00FF2A64                          7945  
00FF2A64  4A2B 0994               7946      TST.b       FAC1_e(a3)          * test exponent
00FF2A68  67F0                    7947      BEQ.s       RTS_023         * exit if zero
00FF2A6A                          7948  
00FF2A6A  48E7 7800               7949      MOVEM.l d1-d4,-(sp)         * save registers
00FF2A6E  202B 0990               7950      MOVE.l  FAC1_m(a3),d0       * copy FAC1
00FF2A72  7400                    7951      MOVEQ       #0,d2               * clear remainder
00FF2A74  2202                    7952      MOVE.l  d2,d1               * clear root
00FF2A76                          7953  
00FF2A76  761F                    7954      MOVEQ       #$1F,d3         * $1F for DBF, 64 pairs of bits to
00FF2A78                          7955                              * do for a 32 bit result
00FF2A78  082B 0000 0994          7956      BTST        #0,FAC1_e(a3)       * test exponent odd/even
00FF2A7E  6606                    7957      BNE.s       LAB_SQE2            * if odd only 1 shift first time
00FF2A80                          7958  
00FF2A80                          7959  LAB_SQE1
00FF2A80  D080                    7960      ADD.l       d0,d0               * shift highest bit of number ..
00FF2A82  D582                    7961      ADDX.l  d2,d2               * .. into remainder .. never overflows
00FF2A84  D281                    7962      ADD.l       d1,d1               * root = root * 2 .. never overflows
00FF2A86                          7963  LAB_SQE2
00FF2A86  D080                    7964      ADD.l       d0,d0               * shift highest bit of number ..
00FF2A88  D582                    7965      ADDX.l  d2,d2               * .. into remainder .. never overflows
00FF2A8A                          7966  
00FF2A8A  2801                    7967      MOVE.l  d1,d4               * copy root
00FF2A8C  D884                    7968      ADD.l       d4,d4               * 2n
00FF2A8E  5284                    7969      ADDQ.l  #1,d4               * 2n+1
00FF2A90                          7970  
00FF2A90  B484                    7971      CMP.l       d4,d2               * compare 2n+1 to remainder
00FF2A92  6504                    7972      BCS.s       LAB_SQNS            * skip sub if remainder smaller
00FF2A94                          7973  
00FF2A94  9484                    7974      SUB.l       d4,d2               * subtract temp from remainder
00FF2A96  5281                    7975      ADDQ.l  #1,d1               * increment root
00FF2A98                          7976  LAB_SQNS
00FF2A98  51CB FFE6               7977      DBF     d3,LAB_SQE1         * loop if not all done
00FF2A9C                          7978  
00FF2A9C  2741 0990               7979      MOVE.l  d1,FAC1_m(a3)       * save result mantissa
00FF2AA0  102B 0994               7980      MOVE.b  FAC1_e(a3),d0       * get exponent (d0 is clear here)
00FF2AA4  0440 0080               7981      SUB.w       #$80,d0         * normalise
00FF2AA8  E248                    7982      LSR.w       #1,d0               * /2
00FF2AAA  6402                    7983      BCC.s       LAB_SQNA            * skip increment if carry clear
00FF2AAC                          7984  
00FF2AAC  5240                    7985      ADDQ.w  #1,d0               * add bit zero back in (allow for half shift)
00FF2AAE                          7986  LAB_SQNA
00FF2AAE  0640 0080               7987      ADD.w       #$80,d0         * re-bias to $80
00FF2AB2  1740 0994               7988      MOVE.b  d0,FAC1_e(a3)       * save it
00FF2AB6  4CDF 001E               7989      MOVEM.l (sp)+,d1-d4         * restore registers
00FF2ABA  6000 F0A6               7990      BRA     LAB_24D5            * normalise FAC1 & return
00FF2ABE                          7991  
00FF2ABE                          7992  
00FF2ABE                          7993  *************************************************************************************
00FF2ABE                          7994  *
00FF2ABE                          7995  * perform VARPTR()
00FF2ABE                          7996  
00FF2ABE                          7997  LAB_VARPTR
00FF2ABE  101D                    7998      MOVE.b  (a5)+,d0            * increment pointer
00FF2AC0  6100 E532               7999      BSR     LAB_GVAR            * get variable address in a0
00FF2AC4  6100 E304               8000      BSR     LAB_1BFB            * scan for ")", else do syntax error/warm start
00FF2AC8  2008                    8001      MOVE.l  a0,d0               * get var address
00FF2ACA  6000 E818               8002      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00FF2ACE                          8003  
00FF2ACE                          8004  
00FF2ACE                          8005  *************************************************************************************
00FF2ACE                          8006  *
00FF2ACE                          8007  * perform RAMBASE
00FF2ACE                          8008  
00FF2ACE                          8009  LAB_RAM
00FF2ACE  41EB 0800               8010      LEA     ram_base(a3),a0     * get start of EhBASIC RAM
00FF2AD2  2008                    8011      MOVE.l  a0,d0               * copy it
00FF2AD4  6000 E80E               8012      BRA     LAB_AYFC            * convert d0 to signed longword in FAC1 & return
00FF2AD8                          8013  
00FF2AD8                          8014  
00FF2AD8                          8015  *************************************************************************************
00FF2AD8                          8016  *
00FF2AD8                          8017  * perform PI
00FF2AD8                          8018  
00FF2AD8                          8019  LAB_PI
00FF2AD8  277C C90FDAA2 0990      8020      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * pi mantissa (32 bit)
00FF2AE0  377C 8200 0994          8021      MOVE.w  #$8200,FAC1_e(a3)       * pi exponent and sign
00FF2AE6  4E75                    8022      RTS
00FF2AE8                          8023  
00FF2AE8                          8024  
00FF2AE8                          8025  *************************************************************************************
00FF2AE8                          8026  *
00FF2AE8                          8027  * perform TWOPI
00FF2AE8                          8028  
00FF2AE8                          8029  LAB_TWOPI
00FF2AE8  277C C90FDAA2 0990      8030      MOVE.l  #$C90FDAA2,FAC1_m(a3)   * 2pi mantissa (32 bit)
00FF2AF0  377C 8300 0994          8031      MOVE.w  #$8300,FAC1_e(a3)       * 2pi exponent and sign
00FF2AF6  4E75                    8032      RTS
00FF2AF8                          8033  
00FF2AF8                          8034  
00FF2AF8                          8035  *************************************************************************************
00FF2AF8                          8036  *
00FF2AF8                          8037  * get ASCII string equivalent into FAC1 as integer32 or float
00FF2AF8                          8038  
00FF2AF8                          8039  * entry is with a5 pointing to the first character of the string
00FF2AF8                          8040  * exit with a5 pointing to the first character after the string
00FF2AF8                          8041  
00FF2AF8                          8042  * d0 is character
00FF2AF8                          8043  * d1 is mantissa
00FF2AF8                          8044  * d2 is partial and table mantissa
00FF2AF8                          8045  * d3 is mantissa exponent (decimal & binary)
00FF2AF8                          8046  * d4 is decimal exponent
00FF2AF8                          8047  
00FF2AF8                          8048  * get FAC1 from string
00FF2AF8                          8049  * this routine now handles hex and binary values from strings
00FF2AF8                          8050  * starting with "$" and "%" respectively
00FF2AF8                          8051  
00FF2AF8                          8052  LAB_2887
00FF2AF8  48E7 7C00               8053      MOVEM.l d1-d5,-(sp)         * save registers
00FF2AFC  7200                    8054      MOVEQ       #$00,d1         * clear temp accumulator
00FF2AFE  2601                    8055      MOVE.l  d1,d3               * set mantissa decimal exponent count
00FF2B00  2801                    8056      MOVE.l  d1,d4               * clear decimal exponent
00FF2B02  1741 0995               8057      MOVE.b  d1,FAC1_s(a3)       * clear sign byte
00FF2B06  1741 09B5               8058      MOVE.b  d1,Dtypef(a3)       * set float data type
00FF2B0A  1741 09AF               8059      MOVE.b  d1,expneg(a3)       * clear exponent sign
00FF2B0E  6100 E2CE               8060      BSR     LAB_GBYT            * get first byte back
00FF2B12  653C                    8061      BCS.s       LAB_28FE            * go get floating if 1st character numeric
00FF2B14                          8062  
00FF2B14  B03C 002D               8063      CMP.b       #'-',d0         * or is it -ve number
00FF2B18  6608                    8064      BNE.s       LAB_289A            * branch if not
00FF2B1A                          8065  
00FF2B1A  177C 00FF 0995          8066      MOVE.b  #$FF,FAC1_s(a3)     * set sign byte
00FF2B20  6006                    8067      BRA.s       LAB_289C            * now go scan & check for hex/bin/int
00FF2B22                          8068  
00FF2B22                          8069  LAB_289A
00FF2B22                          8070                              * first character wasn't numeric or -
00FF2B22  B03C 002B               8071      CMP.b       #'+',d0         * compare with '+'
00FF2B26  6606                    8072      BNE.s       LAB_289D            * branch if not '+', go check for '.'/hex/binary
00FF2B28                          8073                              * /integer
00FF2B28                          8074      
00FF2B28                          8075  LAB_289C
00FF2B28                          8076                              * was "+" or "-" to start, so get next character
00FF2B28  6100 E2B2               8077      BSR     LAB_IGBY            * increment & scan memory
00FF2B2C  6522                    8078      BCS.s       LAB_28FE            * branch if numeric character
00FF2B2E                          8079  
00FF2B2E                          8080  LAB_289D
00FF2B2E  B03C 002E               8081      CMP.b       #'.',d0         * else compare with '.'
00FF2B32  6700 0092               8082      BEQ     LAB_2904            * branch if '.'
00FF2B36                          8083  
00FF2B36                          8084                              * code here for hex/binary/integer numbers
00FF2B36  B03C 0024               8085      CMP.b       #'$',d0         * compare with '$'
00FF2B3A  6700 010A               8086      BEQ     LAB_CHEX            * branch if '$'
00FF2B3E                          8087  
00FF2B3E  B03C 0025               8088      CMP.b       #'%',d0         * else compare with '%'
00FF2B42  6700 0164               8089      BEQ     LAB_CBIN            * branch if '%'
00FF2B46                          8090  
00FF2B46  6000 008C               8091      BRA     LAB_2Y01            * not #.$%& so return 0
00FF2B4A                          8092  
00FF2B4A                          8093  LAB_28FD
00FF2B4A  6100 E290               8094      BSR     LAB_IGBY            * get next character
00FF2B4E  646C                    8095      BCC.s       LAB_2902            * exit loop if not a digit
00FF2B50                          8096  
00FF2B50                          8097  LAB_28FE
00FF2B50  6100 01A8               8098      BSR     d1x10               * multiply d1 by 10 and add character
00FF2B54  64F4                    8099      BCC.s       LAB_28FD            * loop for more if no overflow
00FF2B56                          8100  
00FF2B56                          8101  LAB_28FF
00FF2B56                          8102                              * overflowed mantissa, count 10s exponent
00FF2B56  5283                    8103      ADDQ.l  #1,d3               * increment mantissa decimal exponent count
00FF2B58  6100 E282               8104      BSR     LAB_IGBY            * get next character
00FF2B5C  65F8                    8105      BCS.s       LAB_28FF            * loop while numeric character
00FF2B5E                          8106  
00FF2B5E                          8107                              * done overflow, now flush fraction or do E
00FF2B5E  B03C 002E               8108      CMP.b       #'.',d0         * else compare with '.'
00FF2B62  6606                    8109      BNE.s       LAB_2901            * branch if not '.'
00FF2B64                          8110  
00FF2B64                          8111  LAB_2900
00FF2B64                          8112                              * flush remaining fraction digits
00FF2B64  6100 E276               8113      BSR     LAB_IGBY            * get next character
00FF2B68  65FA                    8114      BCS     LAB_2900            * loop while numeric character
00FF2B6A                          8115  
00FF2B6A                          8116  LAB_2901
00FF2B6A                          8117                              * done number, only (possible) exponent remains
00FF2B6A  B03C 0045               8118      CMP.b       #'E',d0         * else compare with 'E'
00FF2B6E  6664                    8119      BNE.s       LAB_2Y01            * if not 'E' all done, go evaluate
00FF2B70                          8120  
00FF2B70                          8121                              * process exponent
00FF2B70  6100 E26A               8122      BSR     LAB_IGBY            * get next character
00FF2B74  6528                    8123      BCS.s       LAB_2X04            * branch if digit
00FF2B76                          8124  
00FF2B76  B03C 002D               8125      CMP.b       #'-',d0         * or is it -ve number
00FF2B7A  6706                    8126      BEQ.s       LAB_2X01            * branch if so
00FF2B7C                          8127  
00FF2B7C  B03C 00C0               8128      CMP.b       #TK_MINUS,d0        * or is it -ve number
00FF2B80  6608                    8129      BNE.s       LAB_2X02            * branch if not
00FF2B82                          8130  
00FF2B82                          8131  LAB_2X01
00FF2B82  177C 00FF 09AF          8132      MOVE.b  #$FF,expneg(a3)     * set exponent sign
00FF2B88  600E                    8133      BRA.s       LAB_2X03            * now go scan & check exponent
00FF2B8A                          8134  
00FF2B8A                          8135  LAB_2X02
00FF2B8A  B03C 002B               8136      CMP.b       #'+',d0         * or is it +ve number
00FF2B8E  6708                    8137      BEQ.s       LAB_2X03            * branch if so
00FF2B90                          8138  
00FF2B90  B03C 00BF               8139      CMP.b       #TK_PLUS,d0         * or is it +ve number
00FF2B94  6600 D608               8140      BNE     LAB_SNER            * wasn't - + TK_MINUS TK_PLUS or # so do error
00FF2B98                          8141  
00FF2B98                          8142  LAB_2X03
00FF2B98  6100 E242               8143      BSR     LAB_IGBY            * get next character
00FF2B9C  6436                    8144      BCC.s       LAB_2Y01            * if not digit all done, go evaluate
00FF2B9E                          8145  LAB_2X04
00FF2B9E  C8FC 000A               8146      MULU        #10,d4          * multiply decimal exponent by 10
00FF2BA2  C0BC 000000FF           8147      AND.l       #$FF,d0         * mask character
00FF2BA8  0400 0030               8148      SUB.b       #'0',d0         * convert to value
00FF2BAC  D880                    8149      ADD.l       d0,d4               * add to decimal exponent
00FF2BAE  B83C 0030               8150      CMP.b       #48,d4          * compare with decimal exponent limit+10
00FF2BB2  6FE4                    8151      BLE.s       LAB_2X03            * loop if no overflow/underflow
00FF2BB4                          8152  
00FF2BB4                          8153  LAB_2X05
00FF2BB4                          8154                              * exponent value has overflowed
00FF2BB4  6100 E226               8155      BSR     LAB_IGBY            * get next character
00FF2BB8  65FA                    8156      BCS.s       LAB_2X05            * loop while numeric digit
00FF2BBA                          8157  
00FF2BBA  6018                    8158      BRA.s       LAB_2Y01            * all done, go evaluate
00FF2BBC                          8159  
00FF2BBC                          8160  LAB_2902
00FF2BBC  B03C 002E               8161      CMP.b       #'.',d0         * else compare with '.'
00FF2BC0  6704                    8162      BEQ.s       LAB_2904            * branch if was '.'
00FF2BC2                          8163  
00FF2BC2  60A6                    8164      BRA.s       LAB_2901            * branch if not '.' (go check/do 'E')
00FF2BC4                          8165  
00FF2BC4                          8166  LAB_2903
00FF2BC4  5383                    8167      SUBQ.l  #1,d3               * decrement mantissa decimal exponent
00FF2BC6                          8168  LAB_2904
00FF2BC6                          8169                              * was dp so get fraction part
00FF2BC6  6100 E214               8170      BSR     LAB_IGBY            * get next character
00FF2BCA  649E                    8171      BCC.s       LAB_2901            * exit loop if not a digit (go check/do 'E')
00FF2BCC                          8172  
00FF2BCC  6100 012C               8173      BSR     d1x10               * multiply d1 by 10 and add character
00FF2BD0  64F2                    8174      BCC.s       LAB_2903            * loop for more if no overflow
00FF2BD2                          8175  
00FF2BD2  6090                    8176      BRA.s       LAB_2900            * else go flush remaining fraction part
00FF2BD4                          8177  
00FF2BD4                          8178  LAB_2Y01
00FF2BD4                          8179                              * now evaluate result
00FF2BD4  4A2B 09AF               8180      TST.b       expneg(a3)          * test exponent sign
00FF2BD8  6A02                    8181      BPL.s       LAB_2Y02            * branch if sign positive
00FF2BDA                          8182  
00FF2BDA  4484                    8183      NEG.l       d4              * negate decimal exponent
00FF2BDC                          8184  LAB_2Y02
00FF2BDC  D883                    8185      ADD.l       d3,d4               * add mantissa decimal exponent
00FF2BDE  7620                    8186      MOVEQ       #32,d3          * set up max binary exponent
00FF2BE0  4A81                    8187      TST.l       d1              * test mantissa
00FF2BE2  6752                    8188      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
00FF2BE4                          8189  
00FF2BE4  6B08                    8190      BMI.s       LAB_2Y04            * branch if already mormalised
00FF2BE6                          8191  
00FF2BE6  5383                    8192      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
00FF2BE8                          8193  LAB_2Y03
00FF2BE8  D281                    8194      ADD.l       d1,d1               * shift mantissa
00FF2BEA  5BCB FFFC               8195      DBMI        d3,LAB_2Y03         * decrement & loop if not normalised
00FF2BEE                          8196  
00FF2BEE                          8197                              * ensure not too big or small
00FF2BEE                          8198  LAB_2Y04
00FF2BEE  B8BC 00000026           8199      CMP.l       #38,d4          * compare decimal exponent with max exponent
00FF2BF4  6E00 D598               8200      BGT     LAB_OFER            * if greater do overflow error and warm start
00FF2BF8                          8201  
00FF2BF8  B8BC FFFFFFDA           8202      CMP.l       #-38,d4         * compare decimal exponent with min exponent
00FF2BFE  6D34                    8203      BLT.s       LAB_ret0            * if less just return zero
00FF2C00                          8204  
00FF2C00  4484                    8205      NEG.l       d4              * negate decimal exponent to go right way
00FF2C02  C9FC 0006               8206      MULS        #6,d4               * 6 bytes per entry
00FF2C06  2F08                    8207      MOVE.l  a0,-(sp)            * save register
00FF2C08  41FA 0210               8208      LEA     LAB_P_10(pc),a0     * point to table
00FF2C0C  1770 4000 099C          8209      MOVE.b  (a0,d4.w),FAC2_e(a3)    * copy exponent for multiply
00FF2C12  2770 4002 0998          8210      MOVE.l  2(a0,d4.w),FAC2_m(a3)   * copy table mantissa
00FF2C18  205F                    8211      MOVE.l  (sp)+,a0            * restore register
00FF2C1A                          8212  
00FF2C1A  0A03 0080               8213      EORI.b  #$80,d3         * normalise input exponent
00FF2C1E  2741 0990               8214      MOVE.l  d1,FAC1_m(a3)       * save input mantissa
00FF2C22  1743 0994               8215      MOVE.b  d3,FAC1_e(a3)       * save input exponent
00FF2C26  176B 0995 099E          8216      MOVE.b  FAC1_s(a3),FAC_sc(a3)   * set sign as sign compare
00FF2C2C                          8217  
00FF2C2C  4CDF 003E               8218      MOVEM.l (sp)+,d1-d5         * restore registers
00FF2C30  6000 F058               8219      BRA     LAB_MULTIPLY        * go multiply input by table
00FF2C34                          8220  
00FF2C34                          8221  LAB_ret0
00FF2C34  7200                    8222      MOVEQ       #0,d1               * clear mantissa
00FF2C36                          8223  LAB_rtn0
00FF2C36  2601                    8224      MOVE.l  d1,d3               * clear exponent
00FF2C38  1743 0994               8225      MOVE.b  d3,FAC1_e(a3)       * save exponent
00FF2C3C  2741 0990               8226      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00FF2C40  4CDF 003E               8227      MOVEM.l (sp)+,d1-d5         * restore registers
00FF2C44  4E75                    8228      RTS
00FF2C46                          8229  
00FF2C46                          8230  
00FF2C46                          8231  *************************************************************************************
00FF2C46                          8232  *
00FF2C46                          8233  * $ for hex add-on
00FF2C46                          8234  
00FF2C46                          8235  * gets here if the first character was "$" for hex
00FF2C46                          8236  * get hex number
00FF2C46                          8237  
00FF2C46                          8238  LAB_CHEX
00FF2C46  177C 0040 09B5          8239      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
00FF2C4C  7620                    8240      MOVEQ       #32,d3          * set up max binary exponent
00FF2C4E                          8241  LAB_CHXX
00FF2C4E  6100 E18C               8242      BSR     LAB_IGBY            * increment & scan memory
00FF2C52  6514                    8243      BCS.s       LAB_ISHN            * branch if numeric character
00FF2C54                          8244  
00FF2C54  803C 0020               8245      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
00FF2C58  0400 0061               8246      SUB.b       #'a',d0         * subtract "a"
00FF2C5C  652A                    8247      BCS.s       LAB_CHX3            * exit if <"a"
00FF2C5E                          8248  
00FF2C5E  B03C 0006               8249      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
00FF2C62  6424                    8250      BCC.s       LAB_CHX3            * exit if >"f"
00FF2C64                          8251  
00FF2C64  0600 003A               8252      ADD.b       #$3A,d0         * convert to nibble+"0"
00FF2C68                          8253  LAB_ISHN
00FF2C68  616C                    8254      BSR.s       d1x16               * multiply d1 by 16 and add character
00FF2C6A  64E2                    8255      BCC.s       LAB_CHXX            * loop for more if no overflow
00FF2C6C                          8256  
00FF2C6C                          8257                              * overflowed mantissa, count 16s exponent
00FF2C6C                          8258  LAB_CHX1
00FF2C6C  5883                    8259      ADDQ.l  #4,d3               * increment mantissa exponent count
00FF2C6E  6900 D51E               8260      BVS     LAB_OFER            * do overflow error if overflowed
00FF2C72                          8261  
00FF2C72  6100 E168               8262      BSR     LAB_IGBY            * get next character
00FF2C76  65F4                    8263      BCS.s       LAB_CHX1            * loop while numeric character
00FF2C78                          8264  
00FF2C78  803C 0020               8265      OR.b        #$20,d0         * case convert, allow "A" to "F" and "a" to "f"
00FF2C7C  0400 0061               8266      SUB.b       #'a',d0         * subtract "a"
00FF2C80  6506                    8267      BCS.s       LAB_CHX3            * exit if <"a"
00FF2C82                          8268  
00FF2C82  B03C 0006               8269      CMP.b       #$06,d0         * compare normalised with $06 (max+1)
00FF2C86  65E4                    8270      BCS.s       LAB_CHX1            * loop if <="f"
00FF2C88                          8271  
00FF2C88                          8272                              * now return value
00FF2C88                          8273  LAB_CHX3
00FF2C88  4A81                    8274      TST.l       d1              * test mantissa
00FF2C8A  67AA                    8275      BEQ.s       LAB_rtn0            * if mantissa=0 return 0
00FF2C8C                          8276  
00FF2C8C  6B08                    8277      BMI.s       LAB_exxf            * branch if already mormalised
00FF2C8E                          8278  
00FF2C8E  5383                    8279      SUBQ.l  #1,d3               * decrement bianry exponent for DBMI loop
00FF2C90                          8280  LAB_CHX2
00FF2C90  D281                    8281      ADD.l       d1,d1               * shift mantissa
00FF2C92  5BCB FFFC               8282      DBMI        d3,LAB_CHX2         * decrement & loop if not normalised
00FF2C96                          8283  
00FF2C96                          8284  LAB_exxf
00FF2C96  0A03 0080               8285      EORI.b  #$80,d3         * normalise exponent
00FF2C9A  1743 0994               8286      MOVE.b  d3,FAC1_e(a3)       * save exponent
00FF2C9E  2741 0990               8287      MOVE.l  d1,FAC1_m(a3)       * save mantissa
00FF2CA2  4CDF 003E               8288      MOVEM.l (sp)+,d1-d5         * restore registers
00FF2CA6                          8289  RTS_024
00FF2CA6  4E75                    8290      RTS
00FF2CA8                          8291  
00FF2CA8                          8292  
00FF2CA8                          8293  *************************************************************************************
00FF2CA8                          8294  *
00FF2CA8                          8295  * % for binary add-on
00FF2CA8                          8296  
00FF2CA8                          8297  * gets here if the first character was "%" for binary
00FF2CA8                          8298  * get binary number
00FF2CA8                          8299  
00FF2CA8                          8300  LAB_CBIN
00FF2CA8  177C 0040 09B5          8301      MOVE.b  #$40,Dtypef(a3)     * set integer numeric data type
00FF2CAE  7620                    8302      MOVEQ       #32,d3          * set up max binary exponent
00FF2CB0                          8303  LAB_CBXN
00FF2CB0  6100 E12A               8304      BSR     LAB_IGBY            * increment & scan memory
00FF2CB4  64D2                    8305      BCC.s       LAB_CHX3            * if not numeric character go return value
00FF2CB6                          8306  
00FF2CB6  B03C 0032               8307      CMP.b       #'2',d0         * compare with "2" (max+1)
00FF2CBA  64CC                    8308      BCC.s       LAB_CHX3            * if >="2" go return value
00FF2CBC                          8309  
00FF2CBC  2401                    8310      MOVE.l  d1,d2               * copy value
00FF2CBE  6124                    8311      BSR.s       d1x02               * multiply d1 by 2 and add character
00FF2CC0  64EE                    8312      BCC.s       LAB_CBXN            * loop for more if no overflow
00FF2CC2                          8313  
00FF2CC2                          8314                              * overflowed mantissa, count 2s exponent
00FF2CC2                          8315  LAB_CBX1
00FF2CC2  5283                    8316      ADDQ.l  #1,d3               * increment mantissa exponent count
00FF2CC4  6900 D4C8               8317      BVS     LAB_OFER            * do overflow error if overflowed
00FF2CC8                          8318  
00FF2CC8  6100 E112               8319      BSR     LAB_IGBY            * get next character
00FF2CCC  64BA                    8320      BCC.s       LAB_CHX3            * if not numeric character go return value
00FF2CCE                          8321  
00FF2CCE  B03C 0032               8322      CMP.b       #'2',d0         * compare with "2" (max+1)
00FF2CD2  65EE                    8323      BCS.s       LAB_CBX1            * loop if <"2"
00FF2CD4                          8324  
00FF2CD4  60B2                    8325      BRA.s       LAB_CHX3            * if not numeric character go return value
00FF2CD6                          8326  
00FF2CD6                          8327  * half way decent times 16 and times 2 with overflow checks
00FF2CD6                          8328  
00FF2CD6                          8329  d1x16
00FF2CD6  2401                    8330      MOVE.l  d1,d2               * copy value
00FF2CD8  D482                    8331      ADD.l       d2,d2               * times two
00FF2CDA  65CA                    8332      BCS.s       RTS_024         * return if overflow
00FF2CDC                          8333  
00FF2CDC  D482                    8334      ADD.l       d2,d2               * times four
00FF2CDE  65C6                    8335      BCS.s       RTS_024         * return if overflow
00FF2CE0                          8336  
00FF2CE0  D482                    8337      ADD.l       d2,d2               * times eight
00FF2CE2  65C2                    8338      BCS.s       RTS_024         * return if overflow
00FF2CE4                          8339  
00FF2CE4                          8340  d1x02
00FF2CE4  D482                    8341      ADD.l       d2,d2               * times sixteen (ten/two)
00FF2CE6  65BE                    8342      BCS.s       RTS_024         * return if overflow
00FF2CE8                          8343  
00FF2CE8                          8344  * now add in new digit
00FF2CE8                          8345  
00FF2CE8  C0BC 000000FF           8346      AND.l       #$FF,d0         * mask character
00FF2CEE  0400 0030               8347      SUB.b       #'0',d0         * convert to value
00FF2CF2  D480                    8348      ADD.l       d0,d2               * add to result
00FF2CF4  65B0                    8349      BCS.s       RTS_024         * return if overflow, it should never ever do
00FF2CF6                          8350                              * this
00FF2CF6                          8351  
00FF2CF6  2202                    8352      MOVE.l  d2,d1               * copy result
00FF2CF8  4E75                    8353      RTS
00FF2CFA                          8354  
00FF2CFA                          8355  * half way decent times 10 with overflow checks
00FF2CFA                          8356  
00FF2CFA                          8357  d1x10
00FF2CFA  2401                    8358      MOVE.l  d1,d2               * copy value
00FF2CFC  D482                    8359      ADD.l       d2,d2               * times two
00FF2CFE  6508                    8360      BCS.s       RTS_025         * return if overflow
00FF2D00                          8361  
00FF2D00  D482                    8362      ADD.l       d2,d2               * times four
00FF2D02  6504                    8363      BCS.s       RTS_025         * return if overflow
00FF2D04                          8364  
00FF2D04  D481                    8365      ADD.l       d1,d2               * times five
00FF2D06  64DC                    8366      BCC.s       d1x02               * do times two and add in new digit if ok
00FF2D08                          8367  
00FF2D08                          8368  RTS_025
00FF2D08  4E75                    8369      RTS
00FF2D0A                          8370  
00FF2D0A                          8371  
00FF2D0A                          8372  *************************************************************************************
00FF2D0A                          8373  
00FF2D0A                          8374  * token values needed for BASIC
00FF2D0A                          8375  
00FF2D0A  =00000080               8376  TK_END      EQU $80         * $80
00FF2D0A  =00000081               8377  TK_FOR      EQU TK_END+1        * $81
00FF2D0A  =00000082               8378  TK_NEXT     EQU TK_FOR+1        * $82
00FF2D0A  =00000083               8379  TK_DATA     EQU TK_NEXT+1       * $83
00FF2D0A  =00000084               8380  TK_INPUT        EQU TK_DATA+1       * $84
00FF2D0A  =00000085               8381  TK_DIM      EQU TK_INPUT+1      * $85
00FF2D0A  =00000086               8382  TK_READ     EQU TK_DIM+1        * $86
00FF2D0A  =00000087               8383  TK_LET      EQU TK_READ+1       * $87
00FF2D0A  =00000088               8384  TK_DEC      EQU TK_LET+1        * $88
00FF2D0A  =00000089               8385  TK_GOTO     EQU TK_DEC+1        * $89
00FF2D0A  =0000008A               8386  TK_RUN      EQU TK_GOTO+1       * $8A
00FF2D0A  =0000008B               8387  TK_IF           EQU TK_RUN+1        * $8B
00FF2D0A  =0000008C               8388  TK_RESTORE      EQU TK_IF+1         * $8C
00FF2D0A  =0000008D               8389  TK_GOSUB        EQU TK_RESTORE+1        * $8D
00FF2D0A  =0000008E               8390  TK_RETURN       EQU TK_GOSUB+1      * $8E
00FF2D0A  =0000008F               8391  TK_REM      EQU TK_RETURN+1     * $8F
00FF2D0A  =00000090               8392  TK_STOP     EQU TK_REM+1        * $90
00FF2D0A  =00000091               8393  TK_ON           EQU TK_STOP+1       * $91
00FF2D0A  =00000092               8394  TK_NULL     EQU TK_ON+1         * $92
00FF2D0A  =00000093               8395  TK_INC      EQU TK_NULL+1       * $93
00FF2D0A  =00000094               8396  TK_WAIT     EQU TK_INC+1        * $94
00FF2D0A  =00000095               8397  TK_LOAD     EQU TK_WAIT+1       * $95
00FF2D0A  =00000096               8398  TK_SAVE     EQU TK_LOAD+1       * $96
00FF2D0A  =00000097               8399  TK_DEF      EQU TK_SAVE+1       * $97
00FF2D0A  =00000098               8400  TK_POKE     EQU TK_DEF+1        * $98
00FF2D0A  =00000099               8401  TK_DOKE     EQU TK_POKE+1       * $99
00FF2D0A  =0000009A               8402  TK_LOKE     EQU TK_DOKE+1       * $9A
00FF2D0A  =0000009B               8403  TK_CALL     EQU TK_LOKE+1       * $9B
00FF2D0A  =0000009C               8404  TK_DO           EQU TK_CALL+1       * $9C
00FF2D0A  =0000009D               8405  TK_LOOP     EQU TK_DO+1         * $9D
00FF2D0A  =0000009E               8406  TK_PRINT        EQU TK_LOOP+1       * $9E
00FF2D0A  =0000009F               8407  TK_CONT     EQU TK_PRINT+1      * $9F
00FF2D0A                          8408  
00FF2D0A  =000000A0               8409  TK_BUFFER       EQU TK_CONT+1       * $A0 EASy68k graphics extension
00FF2D0A  =000000A1               8410  TK_CLS      EQU TK_BUFFER+1     * $A1 EASy68k graphics extension
00FF2D0A  =000000A2               8411  TK_CURSOR       EQU TK_CLS+1        * $A2 EASy68k graphics extension
00FF2D0A  =000000A3               8412  TK_LINE     EQU TK_CURSOR+1     * $A3 EASy68k graphics extension
00FF2D0A  =000000A4               8413  TK_FILL     EQU TK_LINE+1       * $A4 EASy68k graphics extension
00FF2D0A  =000000A5               8414  TK_MOVE     EQU TK_FILL+1       * $A5 EASy68k graphics extension
00FF2D0A  =000000A6               8415  TK_POINT        EQU TK_MOVE+1       * $A6 EASy68k graphics extension
00FF2D0A  =000000A7               8416  TK_RECT     EQU TK_POINT+1      * $A7 EASy68k graphics extension
00FF2D0A  =000000A8               8417  TK_FRECT        EQU TK_RECT+1       * $A8 EASy68k graphics extension
00FF2D0A  =000000A9               8418  TK_ELLIPSE      EQU TK_FRECT+1      * $A9 EASy68k graphics extension
00FF2D0A  =000000AA               8419  TK_FELLIPSE     EQU TK_ELLIPSE+1        * $AA EASy68k graphics extension
00FF2D0A  =000000AB               8420  TK_MODE     EQU TK_FELLIPSE+1       * $AB EASy68k graphics extension
00FF2D0A  =000000AC               8421  TK_SIZE     EQU TK_MODE+1       * $AC EASy68k graphics extension
00FF2D0A                          8422  
00FF2D0A  =000000AD               8423  TK_LIST     EQU TK_SIZE+1       * $AD
00FF2D0A  =000000AE               8424  TK_CLEAR        EQU TK_LIST+1       * $AE
00FF2D0A  =000000AF               8425  TK_NEW      EQU TK_CLEAR+1      * $AF
00FF2D0A  =000000B0               8426  TK_WIDTH        EQU TK_NEW+1        * $B0
00FF2D0A  =000000B1               8427  TK_GET      EQU TK_WIDTH+1      * $B1
00FF2D0A  =000000B2               8428  TK_SWAP     EQU TK_GET+1        * $B2
00FF2D0A  =000000B3               8429  TK_BITSET       EQU TK_SWAP+1       * $B3
00FF2D0A  =000000B4               8430  TK_BITCLR       EQU TK_BITSET+1     * $B4
00FF2D0A  =000000B5               8431  TK_TAB      EQU TK_BITCLR+1     * $B5
00FF2D0A  =000000B6               8432  TK_ELSE     EQU TK_TAB+1        * $B6
00FF2D0A  =000000B7               8433  TK_TO           EQU TK_ELSE+1       * $B7
00FF2D0A  =000000B8               8434  TK_FN           EQU TK_TO+1         * $B8
00FF2D0A  =000000B9               8435  TK_SPC      EQU TK_FN+1         * $B9
00FF2D0A  =000000BA               8436  TK_THEN     EQU TK_SPC+1        * $BA
00FF2D0A  =000000BB               8437  TK_NOT      EQU TK_THEN+1       * $BB
00FF2D0A  =000000BC               8438  TK_STEP     EQU TK_NOT+1        * $BC
00FF2D0A  =000000BD               8439  TK_UNTIL        EQU TK_STEP+1       * $BD
00FF2D0A  =000000BE               8440  TK_WHILE        EQU TK_UNTIL+1      * $BE
00FF2D0A  =000000BF               8441  TK_PLUS     EQU TK_WHILE+1      * $BF
00FF2D0A  =000000C0               8442  TK_MINUS        EQU TK_PLUS+1       * $C0
00FF2D0A  =000000C1               8443  TK_MULT     EQU TK_MINUS+1      * $C1
00FF2D0A  =000000C2               8444  TK_DIV      EQU TK_MULT+1       * $C2
00FF2D0A  =000000C3               8445  TK_POWER        EQU TK_DIV+1        * $C3
00FF2D0A  =000000C4               8446  TK_AND      EQU TK_POWER+1      * $C4
00FF2D0A  =000000C5               8447  TK_EOR      EQU TK_AND+1        * $C5
00FF2D0A  =000000C6               8448  TK_OR           EQU TK_EOR+1        * $C6
00FF2D0A  =000000C7               8449  TK_RSHIFT       EQU TK_OR+1         * $C7
00FF2D0A  =000000C8               8450  TK_LSHIFT       EQU TK_RSHIFT+1     * $C8
00FF2D0A  =000000C9               8451  TK_GT           EQU TK_LSHIFT+1     * $C9
00FF2D0A  =000000CA               8452  TK_EQUAL        EQU TK_GT+1         * $CA
00FF2D0A  =000000CB               8453  TK_LT           EQU TK_EQUAL+1      * $CB
00FF2D0A  =000000CC               8454  TK_SGN      EQU TK_LT+1         * $CC
00FF2D0A  =000000CD               8455  TK_INT      EQU TK_SGN+1        * $CD
00FF2D0A  =000000CE               8456  TK_ABS      EQU TK_INT+1        * $CE
00FF2D0A  =000000CF               8457  TK_USR      EQU TK_ABS+1        * $CF
00FF2D0A  =000000D0               8458  TK_FRE      EQU TK_USR+1        * $D0
00FF2D0A  =000000D1               8459  TK_POS      EQU TK_FRE+1        * $D1
00FF2D0A  =000000D2               8460  TK_SQR      EQU TK_POS+1        * $D2
00FF2D0A  =000000D3               8461  TK_RND      EQU TK_SQR+1        * $D3
00FF2D0A  =000000D4               8462  TK_LOG      EQU TK_RND+1        * $D4
00FF2D0A  =000000D5               8463  TK_EXP      EQU TK_LOG+1        * $D5
00FF2D0A  =000000D6               8464  TK_COS      EQU TK_EXP+1        * $D6
00FF2D0A  =000000D7               8465  TK_SIN      EQU TK_COS+1        * $D7
00FF2D0A  =000000D8               8466  TK_TAN      EQU TK_SIN+1        * $D8
00FF2D0A  =000000D9               8467  TK_ATN      EQU TK_TAN+1        * $D9
00FF2D0A  =000000DA               8468  TK_PEEK     EQU TK_ATN+1        * $DA
00FF2D0A  =000000DB               8469  TK_DEEK     EQU TK_PEEK+1       * $DB
00FF2D0A  =000000DC               8470  TK_LEEK     EQU TK_DEEK+1       * $DC
00FF2D0A  =000000DD               8471  TK_LEN      EQU TK_LEEK+1       * $DD
00FF2D0A  =000000DE               8472  TK_STRS     EQU TK_LEN+1        * $DE
00FF2D0A  =000000DF               8473  TK_VAL      EQU TK_STRS+1       * $DF
00FF2D0A  =000000E0               8474  TK_ASC      EQU TK_VAL+1        * $E0
00FF2D0A  =000000E1               8475  TK_UCASES       EQU TK_ASC+1        * $E1
00FF2D0A  =000000E2               8476  TK_LCASES       EQU TK_UCASES+1     * $E2
00FF2D0A  =000000E3               8477  TK_CHRS     EQU TK_LCASES+1     * $E3
00FF2D0A  =000000E4               8478  TK_HEXS     EQU TK_CHRS+1       * $E4
00FF2D0A  =000000E5               8479  TK_BINS     EQU TK_HEXS+1       * $E5
00FF2D0A  =000000E6               8480  TK_BITTST       EQU TK_BINS+1       * $E6
00FF2D0A  =000000E7               8481  TK_MAX      EQU TK_BITTST+1     * $E7
00FF2D0A  =000000E8               8482  TK_MIN      EQU TK_MAX+1        * $E8
00FF2D0A  =000000E9               8483  TK_RAM      EQU TK_MIN+1        * $E9
00FF2D0A  =000000EA               8484  TK_KEYS     EQU TK_RAM+1        * $EA EASy68k simulator extension
00FF2D0A  =000000EB               8485  TK_TI           EQU TK_KEYS+1       * $EB EASy68k simulator extension
00FF2D0A  =000000EC               8486  TK_PI           EQU TK_TI+1         * $EC
00FF2D0A  =000000ED               8487  TK_TWOPI        EQU TK_PI+1         * $ED
00FF2D0A  =000000EE               8488  TK_VPTR     EQU TK_TWOPI+1      * $EE
00FF2D0A  =000000EF               8489  TK_SADD     EQU TK_VPTR+1       * $EF
00FF2D0A  =000000F0               8490  TK_LEFTS        EQU TK_SADD+1       * $F0
00FF2D0A  =000000F1               8491  TK_RIGHTS       EQU TK_LEFTS+1      * $F1
00FF2D0A  =000000F2               8492  TK_MIDS     EQU TK_RIGHTS+1     * $F2
00FF2D0A  =000000F3               8493  TK_USINGS       EQU TK_MIDS+1       * $F3
00FF2D0A                          8494  
00FF2D0A                          8495  
00FF2D0A                          8496  ************************************************************************************
00FF2D0A                          8497  *
00FF2D0A                          8498  * binary to unsigned decimal table
00FF2D0A                          8499  
00FF2D0A                          8500  Bin2dec
00FF2D0A= 3B9ACA00                8501      dc.l    $3B9ACA00               * 1000000000
00FF2D0E= 05F5E100                8502      dc.l    $05F5E100               * 100000000
00FF2D12= 00989680                8503      dc.l    $00989680               * 10000000
00FF2D16= 000F4240                8504      dc.l    $000F4240               * 1000000
00FF2D1A= 000186A0                8505      dc.l    $000186A0               * 100000
00FF2D1E= 00002710                8506      dc.l    $00002710               * 10000
00FF2D22= 000003E8                8507      dc.l    $000003E8               * 1000
00FF2D26= 00000064                8508      dc.l    $00000064               * 100
00FF2D2A= 0000000A                8509      dc.l    $0000000A               * 10
00FF2D2E= 00000000                8510      dc.l    $00000000               * 0 end marker
00FF2D32                          8511  
00FF2D32                          8512  LAB_RSED
00FF2D32= 332E3232                8513      dc.l    $332E3232               * 858665522
00FF2D36                          8514  
00FF2D36                          8515  * string to value exponent table
00FF2D36                          8516  
00FF2D36= FF00                    8517      dc.w    255<<8              * 10**38
00FF2D38= 96769951                8518      dc.l    $96769951
00FF2D3C= FB00                    8519      dc.w    251<<8              * 10**37
00FF2D3E= F0BDC21B                8520      dc.l    $F0BDC21B
00FF2D42= F800                    8521      dc.w    248<<8              * 10**36
00FF2D44= C097CE7C                8522      dc.l    $C097CE7C
00FF2D48= F500                    8523      dc.w    245<<8              * 10**35
00FF2D4A= 9A130B96                8524      dc.l    $9A130B96
00FF2D4E= F100                    8525      dc.w    241<<8              * 10**34
00FF2D50= F684DF57                8526      dc.l    $F684DF57
00FF2D54= EE00                    8527      dc.w    238<<8              * 10**33
00FF2D56= C5371912                8528      dc.l    $C5371912
00FF2D5A= EB00                    8529      dc.w    235<<8              * 10**32
00FF2D5C= 9DC5ADA8                8530      dc.l    $9DC5ADA8
00FF2D60= E700                    8531      dc.w    231<<8              * 10**31
00FF2D62= FC6F7C40                8532      dc.l    $FC6F7C40
00FF2D66= E400                    8533      dc.w    228<<8              * 10**30
00FF2D68= C9F2C9CD                8534      dc.l    $C9F2C9CD
00FF2D6C= E100                    8535      dc.w    225<<8              * 10**29
00FF2D6E= A18F07D7                8536      dc.l    $A18F07D7
00FF2D72= DE00                    8537      dc.w    222<<8              * 10**28
00FF2D74= 813F3979                8538      dc.l    $813F3979
00FF2D78= DA00                    8539      dc.w    218<<8              * 10**27
00FF2D7A= CECB8F28                8540      dc.l    $CECB8F28
00FF2D7E= D700                    8541      dc.w    215<<8              * 10**26
00FF2D80= A56FA5BA                8542      dc.l    $A56FA5BA
00FF2D84= D400                    8543      dc.w    212<<8              * 10**25
00FF2D86= 84595161                8544      dc.l    $84595161
00FF2D8A= D000                    8545      dc.w    208<<8              * 10**24
00FF2D8C= D3C21BCF                8546      dc.l    $D3C21BCF
00FF2D90= CD00                    8547      dc.w    205<<8              * 10**23
00FF2D92= A968163F                8548      dc.l    $A968163F
00FF2D96= CA00                    8549      dc.w    202<<8              * 10**22
00FF2D98= 87867832                8550      dc.l    $87867832
00FF2D9C= C600                    8551      dc.w    198<<8              * 10**21
00FF2D9E= D8D726B7                8552      dc.l    $D8D726B7
00FF2DA2= C300                    8553      dc.w    195<<8              * 10**20
00FF2DA4= AD78EBC6                8554      dc.l    $AD78EBC6
00FF2DA8= C000                    8555      dc.w    192<<8              * 10**19
00FF2DAA= 8AC72305                8556      dc.l    $8AC72305
00FF2DAE= BC00                    8557      dc.w    188<<8              * 10**18
00FF2DB0= DE0B6B3A                8558      dc.l    $DE0B6B3A
00FF2DB4= B900                    8559      dc.w    185<<8              * 10**17
00FF2DB6= B1A2BC2F                8560      dc.l    $B1A2BC2F
00FF2DBA= B600                    8561      dc.w    182<<8              * 10**16
00FF2DBC= 8E1BC9BF                8562      dc.l    $8E1BC9BF
00FF2DC0= B200                    8563      dc.w    178<<8              * 10**15
00FF2DC2= E35FA932                8564      dc.l    $E35FA932
00FF2DC6= AF00                    8565      dc.w    175<<8              * 10**14
00FF2DC8= B5E620F5                8566      dc.l    $B5E620F5
00FF2DCC= AC00                    8567      dc.w    172<<8              * 10**13
00FF2DCE= 9184E72A                8568      dc.l    $9184E72A
00FF2DD2= A800                    8569      dc.w    168<<8              * 10**12
00FF2DD4= E8D4A510                8570      dc.l    $E8D4A510
00FF2DD8= A500                    8571      dc.w    165<<8              * 10**11
00FF2DDA= BA43B740                8572      dc.l    $BA43B740
00FF2DDE= A200                    8573      dc.w    162<<8              * 10**10
00FF2DE0= 9502F900                8574      dc.l    $9502F900
00FF2DE4= 9E00                    8575      dc.w    158<<8              * 10**9
00FF2DE6= EE6B2800                8576      dc.l    $EE6B2800
00FF2DEA= 9B00                    8577      dc.w    155<<8              * 10**8
00FF2DEC= BEBC2000                8578      dc.l    $BEBC2000
00FF2DF0= 9800                    8579      dc.w    152<<8              * 10**7
00FF2DF2= 98968000                8580      dc.l    $98968000
00FF2DF6= 9400                    8581      dc.w    148<<8              * 10**6
00FF2DF8= F4240000                8582      dc.l    $F4240000
00FF2DFC= 9100                    8583      dc.w    145<<8              * 10**5
00FF2DFE= C3500000                8584      dc.l    $C3500000
00FF2E02= 8E00                    8585      dc.w    142<<8              * 10**4
00FF2E04= 9C400000                8586      dc.l    $9C400000
00FF2E08= 8A00                    8587      dc.w    138<<8              * 10**3
00FF2E0A= FA000000                8588      dc.l    $FA000000
00FF2E0E= 8700                    8589      dc.w    135<<8              * 10**2
00FF2E10= C8000000                8590      dc.l    $C8000000
00FF2E14= 8400                    8591      dc.w    132<<8              * 10**1
00FF2E16= A0000000                8592      dc.l    $A0000000
00FF2E1A                          8593  LAB_P_10
00FF2E1A= 8100                    8594      dc.w    129<<8              * 10**0
00FF2E1C= 80000000                8595      dc.l    $80000000
00FF2E20= 7D00                    8596      dc.w    125<<8              * 10**-1
00FF2E22= CCCCCCCD                8597      dc.l    $CCCCCCCD
00FF2E26= 7A00                    8598      dc.w    122<<8              * 10**-2
00FF2E28= A3D70A3D                8599      dc.l    $A3D70A3D
00FF2E2C= 7700                    8600      dc.w    119<<8              * 10**-3
00FF2E2E= 83126E98                8601      dc.l    $83126E98
00FF2E32= 7300                    8602      dc.w    115<<8              * 10**-4
00FF2E34= D1B71759                8603      dc.l    $D1B71759
00FF2E38= 7000                    8604      dc.w    112<<8              * 10**-5
00FF2E3A= A7C5AC47                8605      dc.l    $A7C5AC47
00FF2E3E= 6D00                    8606      dc.w    109<<8              * 10**-6
00FF2E40= 8637BD06                8607      dc.l    $8637BD06
00FF2E44= 6900                    8608      dc.w    105<<8              * 10**-7
00FF2E46= D6BF94D6                8609      dc.l    $D6BF94D6
00FF2E4A= 6600                    8610      dc.w    102<<8              * 10**-8
00FF2E4C= ABCC7712                8611      dc.l    $ABCC7712
00FF2E50= 6300                    8612      dc.w    99<<8                   * 10**-9
00FF2E52= 89705F41                8613      dc.l    $89705F41
00FF2E56= 5F00                    8614      dc.w    95<<8                   * 10**-10
00FF2E58= DBE6FECF                8615      dc.l    $DBE6FECF
00FF2E5C= 5C00                    8616      dc.w    92<<8                   * 10**-11
00FF2E5E= AFEBFF0C                8617      dc.l    $AFEBFF0C
00FF2E62= 5900                    8618      dc.w    89<<8                   * 10**-12
00FF2E64= 8CBCCC09                8619      dc.l    $8CBCCC09
00FF2E68= 5500                    8620      dc.w    85<<8                   * 10**-13
00FF2E6A= E12E1342                8621      dc.l    $E12E1342
00FF2E6E= 5200                    8622      dc.w    82<<8                   * 10**-14
00FF2E70= B424DC35                8623      dc.l    $B424DC35
00FF2E74= 4F00                    8624      dc.w    79<<8                   * 10**-15
00FF2E76= 901D7CF7                8625      dc.l    $901D7CF7
00FF2E7A= 4B00                    8626      dc.w    75<<8                   * 10**-16
00FF2E7C= E69594BF                8627      dc.l    $E69594BF
00FF2E80= 4800                    8628      dc.w    72<<8                   * 10**-17
00FF2E82= B877AA32                8629      dc.l    $B877AA32
00FF2E86= 4500                    8630      dc.w    69<<8                   * 10**-18
00FF2E88= 9392EE8F                8631      dc.l    $9392EE8F
00FF2E8C= 4100                    8632      dc.w    65<<8                   * 10**-19
00FF2E8E= EC1E4A7E                8633      dc.l    $EC1E4A7E
00FF2E92= 3E00                    8634      dc.w    62<<8                   * 10**-20
00FF2E94= BCE50865                8635      dc.l    $BCE50865
00FF2E98= 3B00                    8636      dc.w    59<<8                   * 10**-21
00FF2E9A= 971DA050                8637      dc.l    $971DA050
00FF2E9E= 3700                    8638      dc.w    55<<8                   * 10**-22
00FF2EA0= F1C90081                8639      dc.l    $F1C90081
00FF2EA4= 3400                    8640      dc.w    52<<8                   * 10**-23
00FF2EA6= C16D9A01                8641      dc.l    $C16D9A01
00FF2EAA= 3100                    8642      dc.w    49<<8                   * 10**-24
00FF2EAC= 9ABE14CD                8643      dc.l    $9ABE14CD
00FF2EB0= 2D00                    8644      dc.w    45<<8                   * 10**-25
00FF2EB2= F79687AE                8645      dc.l    $F79687AE
00FF2EB6= 2A00                    8646      dc.w    42<<8                   * 10**-26
00FF2EB8= C6120625                8647      dc.l    $C6120625
00FF2EBC= 2700                    8648      dc.w    39<<8                   * 10**-27
00FF2EBE= 9E74D1B8                8649      dc.l    $9E74D1B8
00FF2EC2= 2300                    8650      dc.w    35<<8                   * 10**-28
00FF2EC4= FD87B5F3                8651      dc.l    $FD87B5F3
00FF2EC8= 2000                    8652      dc.w    32<<8                   * 10**-29
00FF2ECA= CAD2F7F5                8653      dc.l    $CAD2F7F5
00FF2ECE= 1D00                    8654      dc.w    29<<8                   * 10**-30
00FF2ED0= A2425FF7                8655      dc.l    $A2425FF7
00FF2ED4= 1A00                    8656      dc.w    26<<8                   * 10**-31
00FF2ED6= 81CEB32C                8657      dc.l    $81CEB32C
00FF2EDA= 1600                    8658      dc.w    22<<8                   * 10**-32
00FF2EDC= CFB11EAD                8659      dc.l    $CFB11EAD
00FF2EE0= 1300                    8660      dc.w    19<<8                   * 10**-33
00FF2EE2= A6274BBE                8661      dc.l    $A6274BBE
00FF2EE6= 1000                    8662      dc.w    16<<8                   * 10**-34
00FF2EE8= 84EC3C98                8663      dc.l    $84EC3C98
00FF2EEC= 0C00                    8664      dc.w    12<<8                   * 10**-35
00FF2EEE= D4AD2DC0                8665      dc.l    $D4AD2DC0
00FF2EF2= 0900                    8666      dc.w    9<<8                    * 10**-36
00FF2EF4= AA242499                8667      dc.l    $AA242499
00FF2EF8= 0600                    8668      dc.w    6<<8                    * 10**-37
00FF2EFA= 881CEA14                8669      dc.l    $881CEA14
00FF2EFE= 0200                    8670      dc.w    2<<8                    * 10**-38
00FF2F00= D9C7DCED                8671      dc.l    $D9C7DCED
00FF2F04                          8672  
00FF2F04                          8673  
00FF2F04                          8674  *************************************************************************************
00FF2F04                          8675  *
00FF2F04                          8676  * table of constants for cordic SIN/COS/TAN calculations
00FF2F04                          8677  * constants are un normalised fractions and are atn(2^-i)/2pi
00FF2F04                          8678  
00FF2F04= 4DBA76D4                8679      dc.l    $4DBA76D4               * SIN/COS multiply constant
00FF2F08                          8680  TAB_SNCO
00FF2F08= 20000000                8681      dc.l    $20000000               * atn(2^0)/2pi
00FF2F0C= 12E4051E                8682      dc.l    $12E4051E               * atn(2^1)/2pi
00FF2F10= 09FB385C                8683      dc.l    $09FB385C               * atn(2^2)/2pi
00FF2F14= 051111D5                8684      dc.l    $051111D5               * atn(2^3)/2pi
00FF2F18= 028B0D44                8685      dc.l    $028B0D44               * atn(2^4)/2pi
00FF2F1C= 0145D7E2                8686      dc.l    $0145D7E2               * atn(2^5)/2pi
00FF2F20= 00A2F61F                8687      dc.l    $00A2F61F               * atn(2^6)/2pi
00FF2F24= 00517C56                8688      dc.l    $00517C56               * atn(2^7)/2pi
00FF2F28= 0028BE54                8689      dc.l    $0028BE54               * atn(2^8)/2pi
00FF2F2C= 00145F2F                8690      dc.l    $00145F2F               * atn(2^9)/2pi
00FF2F30= 000A2F99                8691      dc.l    $000A2F99               * atn(2^10)/2pi
00FF2F34= 000517CD                8692      dc.l    $000517CD               * atn(2^11)/2pi
00FF2F38= 00028BE7                8693      dc.l    $00028BE7               * atn(2^12)/2pi
00FF2F3C= 000145F4                8694      dc.l    $000145F4               * atn(2^13)/2pi
00FF2F40= 0000A2FA                8695      dc.l    $0000A2FA               * atn(2^14)/2pi
00FF2F44= 0000517D                8696      dc.l    $0000517D               * atn(2^15)/2pi
00FF2F48= 000028BF                8697      dc.l    $000028BF               * atn(2^16)/2pi
00FF2F4C= 00001460                8698      dc.l    $00001460               * atn(2^17)/2pi
00FF2F50= 00000A30                8699      dc.l    $00000A30               * atn(2^18)/2pi
00FF2F54= 00000518                8700      dc.l    $00000518               * atn(2^19)/2pi
00FF2F58= 0000028C                8701      dc.l    $0000028C               * atn(2^20)/2pi
00FF2F5C= 00000146                8702      dc.l    $00000146               * atn(2^21)/2pi
00FF2F60= 000000A3                8703      dc.l    $000000A3               * atn(2^22)/2pi
00FF2F64= 00000052                8704      dc.l    $00000052               * atn(2^23)/2pi
00FF2F68= 00000029                8705      dc.l    $00000029               * atn(2^24)/2pi
00FF2F6C= 00000015                8706      dc.l    $00000015               * atn(2^25)/2pi
00FF2F70= 0000000B                8707      dc.l    $0000000B               * atn(2^26)/2pi
00FF2F74= 00000006                8708      dc.l    $00000006               * atn(2^27)/2pi
00FF2F78= 00000003                8709      dc.l    $00000003               * atn(2^28)/2pi
00FF2F7C= 00000002                8710      dc.l    $00000002               * atn(2^29)/2pi
00FF2F80= 00000001                8711      dc.l    $00000001               * atn(2^30)/2pi
00FF2F84= 00000001                8712      dc.l    $00000001               * atn(2^31)/2pi
00FF2F88                          8713  
00FF2F88                          8714  
00FF2F88                          8715  *************************************************************************************
00FF2F88                          8716  *
00FF2F88                          8717  * table of constants for cordic ATN calculation
00FF2F88                          8718  * constants are normalised to two integer bits and are atn(2^-i)
00FF2F88                          8719  
00FF2F88                          8720  TAB_ATNC
00FF2F88= 1DAC6705                8721      dc.l    $1DAC6705               * atn(2^-1)
00FF2F8C= 0FADBAFD                8722      dc.l    $0FADBAFD               * atn(2^-2)
00FF2F90= 07F56EA7                8723      dc.l    $07F56EA7               * atn(2^-3)
00FF2F94= 03FEAB77                8724      dc.l    $03FEAB77               * atn(2^-4)
00FF2F98= 01FFD55C                8725      dc.l    $01FFD55C               * atn(2^-5)
00FF2F9C= 00FFFAAB                8726      dc.l    $00FFFAAB               * atn(2^-6)
00FF2FA0= 007FFF55                8727      dc.l    $007FFF55               * atn(2^-7)
00FF2FA4= 003FFFEB                8728      dc.l    $003FFFEB               * atn(2^-8)
00FF2FA8= 001FFFFD                8729      dc.l    $001FFFFD               * atn(2^-9)
00FF2FAC= 00100000                8730      dc.l    $00100000               * atn(2^-10)
00FF2FB0= 00080000                8731      dc.l    $00080000               * atn(2^-11)
00FF2FB4= 00040000                8732      dc.l    $00040000               * atn(2^-12)
00FF2FB8= 00020000                8733      dc.l    $00020000               * atn(2^-13)
00FF2FBC= 00010000                8734      dc.l    $00010000               * atn(2^-14)
00FF2FC0= 00008000                8735      dc.l    $00008000               * atn(2^-15)
00FF2FC4= 00004000                8736      dc.l    $00004000               * atn(2^-16)
00FF2FC8= 00002000                8737      dc.l    $00002000               * atn(2^-17)
00FF2FCC= 00001000                8738      dc.l    $00001000               * atn(2^-18)
00FF2FD0= 00000800                8739      dc.l    $00000800               * atn(2^-19)
00FF2FD4= 00000400                8740      dc.l    $00000400               * atn(2^-20)
00FF2FD8= 00000200                8741      dc.l    $00000200               * atn(2^-21)
00FF2FDC= 00000100                8742      dc.l    $00000100               * atn(2^-22)
00FF2FE0= 00000080                8743      dc.l    $00000080               * atn(2^-23)
00FF2FE4= 00000040                8744      dc.l    $00000040               * atn(2^-24)
00FF2FE8= 00000020                8745      dc.l    $00000020               * atn(2^-25)
00FF2FEC= 00000010                8746      dc.l    $00000010               * atn(2^-26)
00FF2FF0= 00000008                8747      dc.l    $00000008               * atn(2^-27)
00FF2FF4= 00000004                8748      dc.l    $00000004               * atn(2^-28)
00FF2FF8= 00000002                8749      dc.l    $00000002               * atn(2^-29)
00FF2FFC= 00000001                8750      dc.l    $00000001               * atn(2^-30)
00FF3000                          8751  LAB_1D96
00FF3000= 00000000                8752      dc.l    $00000000               * atn(2^-31)
00FF3004= 00000000                8753      dc.l    $00000000               * atn(2^-32)
00FF3008                          8754  
00FF3008                          8755  * constants are normalised to n integer bits and are tanh(2^-i)
00FF3008  =00000002               8756  n   equ 2
00FF3008                          8757  TAB_HTHET
00FF3008= 2327D4F4                8758      dc.l    $8C9F53D0>>n            * atnh(2^-1)    .549306144
00FF300C= 1058AEFA                8759      dc.l    $4162BBE8>>n            * atnh(2^-2)    .255412812
00FF3010= 080AC48E                8760      dc.l    $202B1238>>n            * atnh(2^-3)
00FF3014= 04015622                8761      dc.l    $10055888>>n            * atnh(2^-4)
00FF3018= 02002AB0                8762      dc.l    $0800AAC0>>n            * atnh(2^-5)
00FF301C= 01000554                8763      dc.l    $04001550>>n            * atnh(2^-6)
00FF3020= 008000AA                8764      dc.l    $020002A8>>n            * atnh(2^-7)
00FF3024= 00400014                8765      dc.l    $01000050>>n            * atnh(2^-8)
00FF3028= 00200002                8766      dc.l    $00800008>>n            * atnh(2^-9)
00FF302C= 00100000                8767      dc.l    $00400000>>n            * atnh(2^-10)
00FF3030= 00080000                8768      dc.l    $00200000>>n            * atnh(2^-11)
00FF3034= 00040000                8769      dc.l    $00100000>>n            * atnh(2^-12)
00FF3038= 00020000                8770      dc.l    $00080000>>n            * atnh(2^-13)
00FF303C= 00010000                8771      dc.l    $00040000>>n            * atnh(2^-14)
00FF3040= 00008000                8772      dc.l    $00020000>>n            * atnh(2^-15)
00FF3044= 00004000                8773      dc.l    $00010000>>n            * atnh(2^-16)
00FF3048= 00002000                8774      dc.l    $00008000>>n            * atnh(2^-17)
00FF304C= 00001000                8775      dc.l    $00004000>>n            * atnh(2^-18)
00FF3050= 00000800                8776      dc.l    $00002000>>n            * atnh(2^-19)
00FF3054= 00000400                8777      dc.l    $00001000>>n            * atnh(2^-20)
00FF3058= 00000200                8778      dc.l    $00000800>>n            * atnh(2^-21)
00FF305C= 00000100                8779      dc.l    $00000400>>n            * atnh(2^-22)
00FF3060= 00000080                8780      dc.l    $00000200>>n            * atnh(2^-23)
00FF3064= 00000040                8781      dc.l    $00000100>>n            * atnh(2^-24)
00FF3068= 00000020                8782      dc.l    $00000080>>n            * atnh(2^-25)
00FF306C= 00000010                8783      dc.l    $00000040>>n            * atnh(2^-26)
00FF3070= 00000008                8784      dc.l    $00000020>>n            * atnh(2^-27)
00FF3074= 00000004                8785      dc.l    $00000010>>n            * atnh(2^-28)
00FF3078= 00000002                8786      dc.l    $00000008>>n            * atnh(2^-29)
00FF307C= 00000001                8787      dc.l    $00000004>>n            * atnh(2^-30)
00FF3080= 00000000                8788      dc.l    $00000002>>n            * atnh(2^-31)
00FF3084= 00000000                8789      dc.l    $00000001>>n            * atnh(2^-32)
00FF3088                          8790  
00FF3088  =26A3D110               8791  KFCTSEED    equ $9A8F4441>>n        * $26A3D110
00FF3088                          8792  
00FF3088                          8793  
00FF3088                          8794  *************************************************************************************
00FF3088                          8795  *
00FF3088                          8796  * command vector table
00FF3088                          8797  
00FF3088                          8798  LAB_CTBL
00FF3088= D586                    8799      dc.w    LAB_END-LAB_CTBL            * END
00FF308A= D4BA                    8800      dc.w    LAB_FOR-LAB_CTBL            * FOR
00FF308C= DB26                    8801      dc.w    LAB_NEXT-LAB_CTBL           * NEXT
00FF308E= D6DA                    8802      dc.w    LAB_DATA-LAB_CTBL           * DATA
00FF3090= DA1A                    8803      dc.w    LAB_INPUT-LAB_CTBL      * INPUT
00FF3092= DEFE                    8804      dc.w    LAB_DIM-LAB_CTBL            * DIM
00FF3094= DA40                    8805      dc.w    LAB_READ-LAB_CTBL           * READ
00FF3096= D84C                    8806      dc.w    LAB_LET-LAB_CTBL            * LET
00FF3098= D7EA                    8807      dc.w    LAB_DEC-LAB_CTBL            * DEC   
00FF309A= D642                    8808      dc.w    LAB_GOTO-LAB_CTBL           * GOTO
00FF309C= D60A                    8809      dc.w    LAB_RUN-LAB_CTBL            * RUN
00FF309E= D702                    8810      dc.w    LAB_IF-LAB_CTBL         * IF
00FF30A0= D5B4                    8811      dc.w    LAB_RESTORE-LAB_CTBL        * RESTORE
00FF30A2= D630                    8812      dc.w    LAB_GOSUB-LAB_CTBL      * GOSUB
00FF30A4= D6C6                    8813      dc.w    LAB_RETURN-LAB_CTBL     * RETURN
00FF30A6= D770                    8814      dc.w    LAB_REM-LAB_CTBL            * REM
00FF30A8= D58E                    8815      dc.w    LAB_STOP-LAB_CTBL           * STOP
00FF30AA= D778                    8816      dc.w    LAB_ON-LAB_CTBL         * ON
00FF30AC= D5E2                    8817      dc.w    LAB_NULL-LAB_CTBL           * NULL
00FF30AE= D7F0                    8818      dc.w    LAB_INC-LAB_CTBL            * INC   
00FF30B0= E804                    8819      dc.w    LAB_WAIT-LAB_CTBL           * WAIT
00FF30B2= E7F2                    8820      dc.w    LAB_LOAD-LAB_CTBL           * LOAD
00FF30B4= E7F6                    8821      dc.w    LAB_SAVE-LAB_CTBL           * SAVE
00FF30B6= E28E                    8822      dc.w    LAB_DEF-LAB_CTBL            * DEF
00FF30B8= E772                    8823      dc.w    LAB_POKE-LAB_CTBL           * POKE
00FF30BA= E7A2                    8824      dc.w    LAB_DOKE-LAB_CTBL           * DOKE
00FF30BC= E7A8                    8825      dc.w    LAB_LOKE-LAB_CTBL           * LOKE
00FF30BE= E7FA                    8826      dc.w    LAB_CALL-LAB_CTBL           * CALL
00FF30C0= D61E                    8827      dc.w    LAB_DO-LAB_CTBL         * DO    
00FF30C2= D670                    8828      dc.w    LAB_LOOP-LAB_CTBL           * LOOP
00FF30C4= D8E0                    8829      dc.w    LAB_PRINT-LAB_CTBL      * PRINT
00FF30C6= D5EC                    8830      dc.w    LAB_CONT-LAB_CTBL           * CONT
00FF30C8                          8831  
00FF30C8= EA2E                    8832      dc.w    LAB_BUFFER-LAB_CTBL     * BUFFER
00FF30CA= EA38                    8833      dc.w    LAB_CLS-LAB_CTBL            * CLS
00FF30CC= E9EA                    8834      dc.w    LAB_CURSOR-LAB_CTBL     * CURSOR
00FF30CE= E8F0                    8835      dc.w    LAB_LINE-LAB_CTBL           * LINE
00FF30D0= E92C                    8836      dc.w    LAB_FILL-LAB_CTBL           * FILL
00FF30D2= E91E                    8837      dc.w    LAB_MOVE-LAB_CTBL           * MOVE
00FF30D4= E928                    8838      dc.w    LAB_POINT-LAB_CTBL      * POINT
00FF30D6= E964                    8839      dc.w    LAB_RECT-LAB_CTBL           * RECT
00FF30D8= E968                    8840      dc.w    LAB_FRECT-LAB_CTBL      * FRECT
00FF30DA= E96C                    8841      dc.w    LAB_ELLIPSE-LAB_CTBL        * ELLIPSE
00FF30DC= E970                    8842      dc.w    LAB_FELLIPSE-LAB_CTBL       * FELLIPSE
00FF30DE= E9CA                    8843      dc.w    LAB_MODE-LAB_CTBL           * MODE
00FF30E0= E9DE                    8844      dc.w    LAB_SIZE-LAB_CTBL           * SIZE
00FF30E2                          8845  
00FF30E2= D404                    8846      dc.w    LAB_LIST-LAB_CTBL           * LIST
00FF30E4= D400                    8847      dc.w    LAB_CLEAR-LAB_CTBL      * CLEAR
00FF30E6= D3B0                    8848      dc.w    LAB_NEW-LAB_CTBL            * NEW
00FF30E8= F954                    8849      dc.w    LAB_WDTH-LAB_CTBL           * WIDTH
00FF30EA= D8A6                    8850      dc.w    LAB_GET-LAB_CTBL            * GET
00FF30EC= E7BC                    8851      dc.w    LAB_SWAP-LAB_CTBL           * SWAP
00FF30EE= F49E                    8852      dc.w    LAB_BITSET-LAB_CTBL     * BITSET
00FF30F0= F4AE                    8853      dc.w    LAB_BITCLR-LAB_CTBL     * BITCLR
00FF30F2                          8854  
00FF30F2                          8855  
00FF30F2                          8856  *************************************************************************************
00FF30F2                          8857  *
00FF30F2                          8858  * function pre process routine table
00FF30F2                          8859  
00FF30F2                          8860  LAB_FTPP
00FF30F2= DD92                    8861      dc.w    LAB_PPFN-LAB_FTPP           * SGN(n)    process numeric expression in ()
00FF30F4= DD92                    8862      dc.w    LAB_PPFN-LAB_FTPP           * INT(n)        "
00FF30F6= DD92                    8863      dc.w    LAB_PPFN-LAB_FTPP           * ABS(n)        "
00FF30F8= DB8C                    8864      dc.w    LAB_EVEZ-LAB_FTPP           * USR(x)    process any expression
00FF30FA= DCD4                    8865      dc.w    LAB_1BF7-LAB_FTPP           * FRE(x)    process any expression in ()
00FF30FC= DCD4                    8866      dc.w    LAB_1BF7-LAB_FTPP           * POS(x)        "
00FF30FE= DD92                    8867      dc.w    LAB_PPFN-LAB_FTPP           * SQR(n)    process numeric expression in ()
00FF3100= DD92                    8868      dc.w    LAB_PPFN-LAB_FTPP           * RND(n)        "
00FF3102= DD92                    8869      dc.w    LAB_PPFN-LAB_FTPP           * LOG(n)        "
00FF3104= DD92                    8870      dc.w    LAB_PPFN-LAB_FTPP           * EXP(n)        "
00FF3106= DD92                    8871      dc.w    LAB_PPFN-LAB_FTPP           * COS(n)        "
00FF3108= DD92                    8872      dc.w    LAB_PPFN-LAB_FTPP           * SIN(n)        "
00FF310A= DD92                    8873      dc.w    LAB_PPFN-LAB_FTPP           * TAN(n)        "
00FF310C= DD92                    8874      dc.w    LAB_PPFN-LAB_FTPP           * ATN(n)        "
00FF310E= DD92                    8875      dc.w    LAB_PPFN-LAB_FTPP           * PEEK(n)       "
00FF3110= DD92                    8876      dc.w    LAB_PPFN-LAB_FTPP           * DEEK(n)       "
00FF3112= DD92                    8877      dc.w    LAB_PPFN-LAB_FTPP           * LEEK(n)       "
00FF3114= DD84                    8878      dc.w    LAB_PPFS-LAB_FTPP           * LEN($)    process string expression in ()
00FF3116= DD92                    8879      dc.w    LAB_PPFN-LAB_FTPP           * STR$(n)   process numeric expression in ()
00FF3118= DD84                    8880      dc.w    LAB_PPFS-LAB_FTPP           * VAL($)    process string expression in ()
00FF311A= DD84                    8881      dc.w    LAB_PPFS-LAB_FTPP           * ASC($)        "
00FF311C= DD84                    8882      dc.w    LAB_PPFS-LAB_FTPP           * UCASE$($)     "
00FF311E= DD84                    8883      dc.w    LAB_PPFS-LAB_FTPP           * LCASE$($)     "
00FF3120= DD92                    8884      dc.w    LAB_PPFN-LAB_FTPP           * CHR$(n)   process numeric expression in ()
00FF3122= DDCC                    8885      dc.w    LAB_BHSS-LAB_FTPP           * HEX$()    bin/hex pre process
00FF3124= DDCC                    8886      dc.w    LAB_BHSS-LAB_FTPP           * BIN$()        "
00FF3126= 0000                    8887      dc.w    $0000                   * BITTST()  none
00FF3128= 0000                    8888      dc.w    $0000                   * MAX()     "
00FF312A= 0000                    8889      dc.w    $0000                   * MIN()     "
00FF312C= DDA0                    8890      dc.w    LAB_PPBI-LAB_FTPP           * RAMBASE   advance pointer
00FF312E= DCD4                    8891      dc.w    LAB_1BF7-LAB_FTPP           * KEYS(x)   process any expression in ()
00FF3130= DDA0                    8892      dc.w    LAB_PPBI-LAB_FTPP           * TI        advance pointer
00FF3132= DDA0                    8893      dc.w    LAB_PPBI-LAB_FTPP           * PI            "
00FF3134= DDA0                    8894      dc.w    LAB_PPBI-LAB_FTPP           * TWOPI     "
00FF3136= 0000                    8895      dc.w    $0000                   * VARPTR()  none
00FF3138= 0000                    8896      dc.w    $0000                   * SADD()        "
00FF313A= DDAA                    8897      dc.w    LAB_LRMS-LAB_FTPP           * LEFT$()   process string expression
00FF313C= DDAA                    8898      dc.w    LAB_LRMS-LAB_FTPP           * RIGHT$()      "
00FF313E= DDAA                    8899      dc.w    LAB_LRMS-LAB_FTPP           * MID$()        "
00FF3140= DB8C                    8900      dc.w    LAB_EVEZ-LAB_FTPP           * USING$(x) process any expression
00FF3142                          8901  
00FF3142                          8902  
00FF3142                          8903  *************************************************************************************
00FF3142                          8904  *
00FF3142                          8905  * action addresses for functions
00FF3142                          8906  
00FF3142                          8907  LAB_FTBL
00FF3142= ED34                    8908      dc.w    LAB_SGN-LAB_FTBL            * SGN()
00FF3144= EDB8                    8909      dc.w    LAB_INT-LAB_FTBL            * INT()
00FF3146= ED46                    8910      dc.w    LAB_ABS-LAB_FTBL            * ABS()
00FF3148= E730                    8911      dc.w    LAB_USR-LAB_FTBL            * USR()
00FF314A= E18C                    8912      dc.w    LAB_FRE-LAB_FTBL            * FRE()
00FF314C= E1BE                    8913      dc.w    LAB_POS-LAB_FTBL            * POS()
00FF314E= F91A                    8914      dc.w    LAB_SQR-LAB_FTBL            * SQR()
00FF3150= F200                    8915      dc.w    LAB_RND-LAB_FTBL            * RND()
00FF3152= EA56                    8916      dc.w    LAB_LOG-LAB_FTBL            * LOG()
00FF3154= F0E6                    8917      dc.w    LAB_EXP-LAB_FTBL            * EXP()
00FF3156= F254                    8918      dc.w    LAB_COS-LAB_FTBL            * COS()
00FF3158= F26C                    8919      dc.w    LAB_SIN-LAB_FTBL            * SIN()
00FF315A= F232                    8920      dc.w    LAB_TAN-LAB_FTBL            * TAN()
00FF315C= F332                    8921      dc.w    LAB_ATN-LAB_FTBL            * ATN()
00FF315E= E6AC                    8922      dc.w    LAB_PEEK-LAB_FTBL           * PEEK()
00FF3160= E6BE                    8923      dc.w    LAB_DEEK-LAB_FTBL           * DEEK()
00FF3162= E6D4                    8924      dc.w    LAB_LEEK-LAB_FTBL           * LEEK()
00FF3164= E5F0                    8925      dc.w    LAB_LENS-LAB_FTBL           * LEN()
00FF3166= E2B4                    8926      dc.w    LAB_STRS-LAB_FTBL           * STR$()
00FF3168= E634                    8927      dc.w    LAB_VAL-LAB_FTBL            * VAL()
00FF316A= E5F8                    8928      dc.w    LAB_ASC-LAB_FTBL            * ASC()
00FF316C= E5A6                    8929      dc.w    LAB_UCASE-LAB_FTBL      * UCASE$()
00FF316E= E576                    8930      dc.w    LAB_LCASE-LAB_FTBL      * LCASE$()
00FF3170= E4DE                    8931      dc.w    LAB_CHRS-LAB_FTBL           * CHR$()
00FF3172= F7BC                    8932      dc.w    LAB_HEXS-LAB_FTBL           * HEX$()
00FF3174= F76A                    8933      dc.w    LAB_BINS-LAB_FTBL           * BIN$()
00FF3176= F404                    8934      dc.w    LAB_BTST-LAB_FTBL           * BITTST()
00FF3178= F828                    8935      dc.w    LAB_MAX-LAB_FTBL            * MAX()
00FF317A= F83E                    8936      dc.w    LAB_MIN-LAB_FTBL            * MIN()
00FF317C= F98C                    8937      dc.w    LAB_RAM-LAB_FTBL            * RAMBASE
00FF317E= E772                    8938      dc.w    LAB_KEYS-LAB_FTBL           * KEYS()
00FF3180= E76E                    8939      dc.w    LAB_TI-LAB_FTBL         * TI
00FF3182= F996                    8940      dc.w    LAB_PI-LAB_FTBL         * PI
00FF3184= F9A6                    8941      dc.w    LAB_TWOPI-LAB_FTBL      * TWOPI
00FF3186= F97C                    8942      dc.w    LAB_VARPTR-LAB_FTBL     * VARPTR()
00FF3188= E5D8                    8943      dc.w    LAB_SADD-LAB_FTBL           * SADD()
00FF318A= E4EE                    8944      dc.w    LAB_LEFT-LAB_FTBL           * LEFT$()
00FF318C= E502                    8945      dc.w    LAB_RIGHT-LAB_FTBL      * RIGHT$()
00FF318E= E532                    8946      dc.w    LAB_MIDS-LAB_FTBL           * MID$()
00FF3190= F432                    8947      dc.w    LAB_USINGS-LAB_FTBL     * USING$()
00FF3192                          8948  
00FF3192                          8949  
00FF3192                          8950  *************************************************************************************
00FF3192                          8951  *
00FF3192                          8952  * hierarchy and action addresses for operator
00FF3192                          8953  
00FF3192                          8954  LAB_OPPT
00FF3192= 0079                    8955      dc.w    $0079                   * +
00FF3194= E954                    8956      dc.w    LAB_ADD-LAB_OPPT
00FF3196= 0079                    8957      dc.w    $0079                   * -
00FF3198= E940                    8958      dc.w    LAB_SUBTRACT-LAB_OPPT
00FF319A= 007B                    8959      dc.w    $007B                   * *
00FF319C= EAF8                    8960      dc.w    LAB_MULTIPLY-LAB_OPPT
00FF319E= 007B                    8961      dc.w    $007B                   * /
00FF31A0= EB84                    8962      dc.w    LAB_DIVIDE-LAB_OPPT
00FF31A2= 007F                    8963      dc.w    $007F                   * ^
00FF31A4= EFE0                    8964      dc.w    LAB_POWER-LAB_OPPT
00FF31A6= 0050                    8965      dc.w    $0050                   * AND
00FF31A8= DD6C                    8966      dc.w    LAB_AND-LAB_OPPT
00FF31AA= 0046                    8967      dc.w    $0046                   * EOR
00FF31AC= DD5C                    8968      dc.w    LAB_EOR-LAB_OPPT
00FF31AE= 0046                    8969      dc.w    $0046                   * OR
00FF31B0= DD64                    8970      dc.w    LAB_OR-LAB_OPPT
00FF31B2= 0056                    8971      dc.w    $0056                   * >>
00FF31B4= DE10                    8972      dc.w    LAB_RSHIFT-LAB_OPPT
00FF31B6= 0056                    8973      dc.w    $0056                   * <<
00FF31B8= DE00                    8974      dc.w    LAB_LSHIFT-LAB_OPPT
00FF31BA= 007D                    8975      dc.w    $007D                   * >
00FF31BC= F044                    8976      dc.w    LAB_GTHAN-LAB_OPPT      * used to evaluate -n
00FF31BE= 005A                    8977      dc.w    $005A                   * =
00FF31C0= DD82                    8978      dc.w    LAB_EQUAL-LAB_OPPT      * used to evaluate NOT
00FF31C2= 0064                    8979      dc.w    $0064                   * <
00FF31C4= DD8C                    8980      dc.w    LAB_LTHAN-LAB_OPPT
00FF31C6                          8981  
00FF31C6                          8982  
00FF31C6                          8983  *************************************************************************************
00FF31C6                          8984  *
00FF31C6                          8985  * misc constants
00FF31C6                          8986  
00FF31C6                          8987  * This table is used in converting numbers to ASCII.
00FF31C6                          8988  
00FF31C6                          8989  LAB_2A9A
00FF31C6= FFF0BDC0                8990      dc.l    $FFF0BDC0               * -1000000
00FF31CA= 000186A0                8991      dc.l    $000186A0               * 100000
00FF31CE= FFFFD8F0                8992      dc.l    $FFFFD8F0               * -10000
00FF31D2= 000003E8                8993      dc.l    $000003E8               * 1000
00FF31D6= FFFFFF9C                8994      dc.l    $FFFFFF9C               * -100
00FF31DA= 0000000A                8995      dc.l    $0000000A               * 10
00FF31DE= FFFFFFFF                8996      dc.l    $FFFFFFFF               * -1
00FF31E2                          8997  LAB_2A9B
00FF31E2                          8998  
00FF31E2                          8999  
00FF31E2                          9000  *************************************************************************************
00FF31E2                          9001  *
00FF31E2                          9002  * new keyword tables
00FF31E2                          9003  
00FF31E2                          9004  * offsets to keyword tables
00FF31E2                          9005  
00FF31E2                          9006  TAB_CHRT
00FF31E2= 0000                    9007      dc.w    TAB_STAR-TAB_STAR           * "*"   $2A
00FF31E4= 0002                    9008      dc.w    TAB_PLUS-TAB_STAR           * "+"   $2B
00FF31E6= FFFF                    9009      dc.w    -1                  * "," $2C no keywords
00FF31E8= 0004                    9010      dc.w    TAB_MNUS-TAB_STAR           * "-"   $2D
00FF31EA= FFFF                    9011      dc.w    -1                  * "." $2E no keywords
00FF31EC= 0006                    9012      dc.w    TAB_SLAS-TAB_STAR           * "/"   $2F
00FF31EE= FFFF                    9013      dc.w    -1                  * "0" $30 no keywords
00FF31F0= FFFF                    9014      dc.w    -1                  * "1" $31 no keywords
00FF31F2= FFFF                    9015      dc.w    -1                  * "2" $32 no keywords
00FF31F4= FFFF                    9016      dc.w    -1                  * "3" $33 no keywords
00FF31F6= FFFF                    9017      dc.w    -1                  * "4" $34 no keywords
00FF31F8= FFFF                    9018      dc.w    -1                  * "5" $35 no keywords
00FF31FA= FFFF                    9019      dc.w    -1                  * "6" $36 no keywords
00FF31FC= FFFF                    9020      dc.w    -1                  * "7" $37 no keywords
00FF31FE= FFFF                    9021      dc.w    -1                  * "8" $38 no keywords
00FF3200= FFFF                    9022      dc.w    -1                  * "9" $39 no keywords
00FF3202= FFFF                    9023      dc.w    -1                  * ";" $3A no keywords
00FF3204= FFFF                    9024      dc.w    -1                  * ":" $3B no keywords
00FF3206= 0008                    9025      dc.w    TAB_LESS-TAB_STAR           * "<"   $3C
00FF3208= 000C                    9026      dc.w    TAB_EQUL-TAB_STAR           * "="   $3D
00FF320A= 000E                    9027      dc.w    TAB_MORE-TAB_STAR           * ">"   $3E
00FF320C= 0012                    9028      dc.w    TAB_QEST-TAB_STAR           * "?"   $3F
00FF320E= FFFF                    9029      dc.w    -1                  * "@" $40 no keywords
00FF3210= 0014                    9030      dc.w    TAB_ASCA-TAB_STAR           * "A"   $41
00FF3212= 0024                    9031      dc.w    TAB_ASCB-TAB_STAR           * "B"   $42
00FF3214= 0043                    9032      dc.w    TAB_ASCC-TAB_STAR           * "C"   $43
00FF3216= 0063                    9033      dc.w    TAB_ASCD-TAB_STAR           * "D"   $44
00FF3218= 007C                    9034      dc.w    TAB_ASCE-TAB_STAR           * "E"   $45
00FF321A= 009A                    9035      dc.w    TAB_ASCF-TAB_STAR           * "F"   $46
00FF321C= 00A8                    9036      dc.w    TAB_ASCG-TAB_STAR           * "G"   $47
00FF321E= 00B5                    9037      dc.w    TAB_ASCH-TAB_STAR           * "H"   $48
00FF3220= 00BB                    9038      dc.w    TAB_ASCI-TAB_STAR           * "I"   $49
00FF3222= FFFF                    9039      dc.w    -1                  * "J" $4A no keywords
00FF3224= 00CA                    9040      dc.w    TAB_ASCK-TAB_STAR           * "K" $4B
00FF3226= 00D0                    9041      dc.w    TAB_ASCL-TAB_STAR           * "L"   $4C
00FF3228= 0102                    9042      dc.w    TAB_ASCM-TAB_STAR           * "M"   $4D
00FF322A= 0118                    9043      dc.w    TAB_ASCN-TAB_STAR           * "N"   $4E
00FF322C= 0127                    9044      dc.w    TAB_ASCO-TAB_STAR           * "O"   $4F
00FF322E= 012C                    9045      dc.w    TAB_ASCP-TAB_STAR           * "P"   $50
00FF3230= FFFF                    9046      dc.w    -1                  * "Q" $51 no keywords
00FF3232= 0146                    9047      dc.w    TAB_ASCR-TAB_STAR           * "R"   $52
00FF3234= 0179                    9048      dc.w    TAB_ASCS-TAB_STAR           * "S"   $53
00FF3236= 01A8                    9049      dc.w    TAB_ASCT-TAB_STAR           * "T"   $54
00FF3238= 01BE                    9050      dc.w    TAB_ASCU-TAB_STAR           * "U"   $55
00FF323A= 01D6                    9051      dc.w    TAB_ASCV-TAB_STAR           * "V"   $56
00FF323C= 01E2                    9052      dc.w    TAB_ASCW-TAB_STAR           * "W"   $57
00FF323E= FFFF                    9053      dc.w    -1                  * "X" $58 no keywords
00FF3240= FFFF                    9054      dc.w    -1                  * "Y" $59 no keywords
00FF3242= FFFF                    9055      dc.w    -1                  * "Z" $5A no keywords
00FF3244= FFFF                    9056      dc.w    -1                  * "[" $5B no keywords
00FF3246= FFFF                    9057      dc.w    -1                  * "\" $5C no keywords
00FF3248= FFFF                    9058      dc.w    -1                  * "]" $5D no keywords
00FF324A= 01F1                    9059      dc.w    TAB_POWR-TAB_STAR           * "^"   $5E
00FF324C                          9060  
00FF324C                          9061  
00FF324C                          9062  *************************************************************************************
00FF324C                          9063  *
00FF324C                          9064  * Table of Basic keywords for LIST command
00FF324C                          9065  * [byte]first character,[byte]remaining length -1
00FF324C                          9066  * [word]offset from table start
00FF324C                          9067  
00FF324C                          9068  LAB_KEYT
00FF324C= 45 01                   9069      dc.b    'E',1
00FF324E= 0080                    9070      dc.w    KEY_END-TAB_STAR            * END
00FF3250= 46 01                   9071      dc.b    'F',1
00FF3252= 009E                    9072      dc.w    KEY_FOR-TAB_STAR            * FOR
00FF3254= 4E 02                   9073      dc.b    'N',2
00FF3256= 011B                    9074      dc.w    KEY_NEXT-TAB_STAR           * NEXT
00FF3258= 44 02                   9075      dc.b    'D',2
00FF325A= 0063                    9076      dc.w    KEY_DATA-TAB_STAR           * DATA
00FF325C= 49 03                   9077      dc.b    'I',3
00FF325E= 00C0                    9078      dc.w    KEY_INPUT-TAB_STAR      * INPUT
00FF3260= 44 01                   9079      dc.b    'D',1
00FF3262= 0072                    9080      dc.w    KEY_DIM-TAB_STAR            * DIM
00FF3264= 52 02                   9081      dc.b    'R',2
00FF3266= 014D                    9082      dc.w    KEY_READ-TAB_STAR           * READ
00FF3268= 4C 01                   9083      dc.b    'L',1
00FF326A= 00E6                    9084      dc.w    KEY_LET-TAB_STAR            * LET
00FF326C= 44 01                   9085      dc.b    'D',1
00FF326E= 0067                    9086      dc.w    KEY_DEC-TAB_STAR            * DEC
00FF3270= 47 02                   9087      dc.b    'G',2
00FF3272= 00AB                    9088      dc.w    KEY_GOTO-TAB_STAR           * GOTO
00FF3274= 52 01                   9089      dc.b    'R',1
00FF3276= 0175                    9090      dc.w    KEY_RUN-TAB_STAR            * RUN
00FF3278= 49 00                   9091      dc.b    'I',0
00FF327A= 00BB                    9092      dc.w    KEY_IF-TAB_STAR         * IF
00FF327C= 52 05                   9093      dc.b    'R',5
00FF327E= 015D                    9094      dc.w    KEY_RESTORE-TAB_STAR        * RESTORE
00FF3280= 47 03                   9095      dc.b    'G',3
00FF3282= 00AF                    9096      dc.w    KEY_GOSUB-TAB_STAR      * GOSUB
00FF3284= 52 04                   9097      dc.b    'R',4
00FF3286= 0164                    9098      dc.w    KEY_RETURN-TAB_STAR     * RETURN
00FF3288= 52 01                   9099      dc.b    'R',1
00FF328A= 015A                    9100      dc.w    KEY_REM-TAB_STAR            * REM
00FF328C= 53 02                   9101      dc.b    'S',2
00FF328E= 019A                    9102      dc.w    KEY_STOP-TAB_STAR           * STOP
00FF3290= 4F 00                   9103      dc.b    'O',0
00FF3292= 0127                    9104      dc.w    KEY_ON-TAB_STAR         * ON
00FF3294= 4E 02                   9105      dc.b    'N',2
00FF3296= 0122                    9106      dc.w    KEY_NULL-TAB_STAR           * NULL
00FF3298= 49 01                   9107      dc.b    'I',1
00FF329A= 00BD                    9108      dc.w    KEY_INC-TAB_STAR            * INC
00FF329C= 57 02                   9109      dc.b    'W',2
00FF329E= 01E2                    9110      dc.w    KEY_WAIT-TAB_STAR           * WAIT
00FF32A0= 4C 02                   9111      dc.b    'L',2
00FF32A2= 00F1                    9112      dc.w    KEY_LOAD-TAB_STAR           * LOAD
00FF32A4= 53 02                   9113      dc.b    'S',2
00FF32A6= 017E                    9114      dc.w    KEY_SAVE-TAB_STAR           * SAVE
00FF32A8= 44 01                   9115      dc.b    'D',1
00FF32AA= 006F                    9116      dc.w    KEY_DEF-TAB_STAR            * DEF
00FF32AC= 50 02                   9117      dc.b    'P',2
00FF32AE= 0138                    9118      dc.w    KEY_POKE-TAB_STAR           * POKE
00FF32B0= 44 02                   9119      dc.b    'D',2
00FF32B2= 0075                    9120      dc.w    KEY_DOKE-TAB_STAR           * DOKE
00FF32B4= 4C 02                   9121      dc.b    'L',2
00FF32B6= 00F9                    9122      dc.w    KEY_LOKE-TAB_STAR           * LOKE
00FF32B8= 43 02                   9123      dc.b    'C',2
00FF32BA= 0043                    9124      dc.w    KEY_CALL-TAB_STAR           * CALL
00FF32BC= 44 00                   9125      dc.b    'D',0
00FF32BE= 0079                    9126      dc.w    KEY_DO-TAB_STAR         * DO
00FF32C0= 4C 02                   9127      dc.b    'L',2
00FF32C2= 00FD                    9128      dc.w    KEY_LOOP-TAB_STAR           * LOOP
00FF32C4= 50 03                   9129      dc.b    'P',3
00FF32C6= 0140                    9130      dc.w    KEY_PRINT-TAB_STAR      * PRINT
00FF32C8= 43 02                   9131      dc.b    'C',2
00FF32CA= 0054                    9132      dc.w    KEY_CONT-TAB_STAR           * CONT
00FF32CC                          9133  
00FF32CC= 42 04                   9134      dc.b    'B',4
00FF32CE= 003C                    9135      dc.w    KEY_BUFFER-TAB_STAR     * BUFFER
00FF32D0= 43 01                   9136      dc.b    'C',1
00FF32D2= 0051                    9137      dc.w    KEY_CLS-TAB_STAR            * CLS
00FF32D4= 43 04                   9138      dc.b    'C',4
00FF32D6= 005C                    9139      dc.w    KEY_CURSOR-TAB_STAR     * CURSOR
00FF32D8= 4C 02                   9140      dc.b    'L',2
00FF32DA= 00E9                    9141      dc.w    KEY_LINE-TAB_STAR           * LINE
00FF32DC= 46 02                   9142      dc.b    'F',2
00FF32DE= 009A                    9143      dc.w    KEY_FILL-TAB_STAR           * FILL
00FF32E0= 4D 02                   9144      dc.b    'M',2
00FF32E2= 0113                    9145      dc.w    KEY_MOVE-TAB_STAR           * MOVE
00FF32E4= 50 03                   9146      dc.b    'P',3
00FF32E6= 0133                    9147      dc.w    KEY_POINT-TAB_STAR      * POINT
00FF32E8= 52 02                   9148      dc.b    'R',2
00FF32EA= 0156                    9149      dc.w    KEY_RECT-TAB_STAR           * RECT
00FF32EC= 52 03                   9150      dc.b    'R',3
00FF32EE= 0151                    9151      dc.w    KEY_FRECT-TAB_STAR      * RECTF
00FF32F0= 45 05                   9152      dc.b    'E',5
00FF32F2= 008B                    9153      dc.w    KEY_ELLIPSE-TAB_STAR        * ELLIPSE
00FF32F4= 45 06                   9154      dc.b    'E',6
00FF32F6= 0083                    9155      dc.w    KEY_FELLIPSE-TAB_STAR       * ELLIPSEF
00FF32F8= 4D 02                   9156      dc.b    'M',2
00FF32FA= 010F                    9157      dc.w    KEY_MODE-TAB_STAR           * MODE
00FF32FC= 53 02                   9158      dc.b    'S',2
00FF32FE= 018A                    9159      dc.w    KEY_SIZE-TAB_STAR           * SIZE
00FF3300                          9160  
00FF3300= 4C 02                   9161      dc.b    'L',2
00FF3302= 00ED                    9162      dc.w    KEY_LIST-TAB_STAR           * LIST
00FF3304= 43 03                   9163      dc.b    'C',3
00FF3306= 004C                    9164      dc.w    KEY_CLEAR-TAB_STAR      * CLEAR
00FF3308= 4E 01                   9165      dc.b    'N',1
00FF330A= 0118                    9166      dc.w    KEY_NEW-TAB_STAR            * NEW
00FF330C= 57 03                   9167      dc.b    'W',3
00FF330E= 01EB                    9168      dc.w    KEY_WIDTH-TAB_STAR      * WIDTH
00FF3310= 47 01                   9169      dc.b    'G',1
00FF3312= 00A8                    9170      dc.w    KEY_GET-TAB_STAR            * GET
00FF3314= 53 02                   9171      dc.b    'S',2
00FF3316= 01A3                    9172      dc.w    KEY_SWAP-TAB_STAR           * SWAP
00FF3318= 42 04                   9173      dc.b    'B',4
00FF331A= 002F                    9174      dc.w    KEY_BITSET-TAB_STAR     * BITSET
00FF331C= 42 04                   9175      dc.b    'B',4
00FF331E= 0029                    9176      dc.w    KEY_BITCLR-TAB_STAR     * BITCLR
00FF3320= 54 02                   9177      dc.b    'T',2
00FF3322= 01A8                    9178      dc.w    KEY_TAB-TAB_STAR            * TAB(
00FF3324= 45 02                   9179      dc.b    'E',2
00FF3326= 007C                    9180      dc.w    KEY_ELSE-TAB_STAR           * ELSE
00FF3328= 54 00                   9181      dc.b    'T',0
00FF332A= 01B6                    9182      dc.w    KEY_TO-TAB_STAR         * TO
00FF332C= 46 00                   9183      dc.b    'F',0
00FF332E= 00A1                    9184      dc.w    KEY_FN-TAB_STAR         * FN
00FF3330= 53 02                   9185      dc.b    'S',2
00FF3332= 018E                    9186      dc.w    KEY_SPC-TAB_STAR            * SPC(
00FF3334= 54 02                   9187      dc.b    'T',2
00FF3336= 01B0                    9188      dc.w    KEY_THEN-TAB_STAR           * THEN
00FF3338= 4E 01                   9189      dc.b    'N',1
00FF333A= 011F                    9190      dc.w    KEY_NOT-TAB_STAR            * NOT
00FF333C= 53 02                   9191      dc.b    'S',2
00FF333E= 0196                    9192      dc.w    KEY_STEP-TAB_STAR           * STEP
00FF3340= 55 03                   9193      dc.b    'U',3
00FF3342= 01C5                    9194      dc.w    KEY_UNTIL-TAB_STAR      * UNTIL
00FF3344= 57 03                   9195      dc.b    'W',3
00FF3346= 01E6                    9196      dc.w    KEY_WHILE-TAB_STAR      * WHILE
00FF3348                          9197  
00FF3348= 2B FF                   9198      dc.b    '+',-1
00FF334A= 0002                    9199      dc.w    KEY_PLUS-TAB_STAR           * +
00FF334C= 2D FF                   9200      dc.b    '-',-1
00FF334E= 0004                    9201      dc.w    KEY_MINUS-TAB_STAR      * -
00FF3350= 2A FF                   9202      dc.b    '*',-1
00FF3352= 0000                    9203      dc.w    KEY_MULT-TAB_STAR           * *
00FF3354= 2F FF                   9204      dc.b    '/',-1
00FF3356= 0006                    9205      dc.w    KEY_DIV-TAB_STAR            * /
00FF3358= 5E FF                   9206      dc.b    '^',-1
00FF335A= 01F1                    9207      dc.w    KEY_POWER-TAB_STAR      * ^
00FF335C= 41 01                   9208      dc.b    'A',1
00FF335E= 0018                    9209      dc.w    KEY_AND-TAB_STAR            * AND
00FF3360= 45 01                   9210      dc.b    'E',1
00FF3362= 0092                    9211      dc.w    KEY_EOR-TAB_STAR            * EOR
00FF3364= 4F 00                   9212      dc.b    'O',0
00FF3366= 0129                    9213      dc.w    KEY_OR-TAB_STAR         * OR
00FF3368= 3E 00                   9214      dc.b    '>',0
00FF336A= 000E                    9215      dc.w    KEY_RSHIFT-TAB_STAR     * >>
00FF336C= 3C 00                   9216      dc.b    '<',0
00FF336E= 0008                    9217      dc.w    KEY_LSHIFT-TAB_STAR     * <<
00FF3370= 3E FF                   9218      dc.b    '>',-1
00FF3372= 0010                    9219      dc.w    KEY_GT-TAB_STAR         * >
00FF3374= 3D FF                   9220      dc.b    '=',-1
00FF3376= 000C                    9221      dc.w    KEY_EQUAL-TAB_STAR      * =
00FF3378= 3C FF                   9222      dc.b    '<',-1
00FF337A= 000A                    9223      dc.w    KEY_LT-TAB_STAR         * <
00FF337C                          9224  
00FF337C= 53 02                   9225      dc.b    'S',2
00FF337E= 0182                    9226      dc.w    KEY_SGN-TAB_STAR            * SGN(
00FF3380= 49 02                   9227      dc.b    'I',2
00FF3382= 00C5                    9228      dc.w    KEY_INT-TAB_STAR            * INT(
00FF3384= 41 02                   9229      dc.b    'A',2
00FF3386= 0014                    9230      dc.w    KEY_ABS-TAB_STAR            * ABS(
00FF3388= 55 02                   9231      dc.b    'U',2
00FF338A= 01D1                    9232      dc.w    KEY_USR-TAB_STAR            * USR(
00FF338C= 46 02                   9233      dc.b    'F',2
00FF338E= 00A3                    9234      dc.w    KEY_FRE-TAB_STAR            * FRE(
00FF3390= 50 02                   9235      dc.b    'P',2
00FF3392= 013C                    9236      dc.w    KEY_POS-TAB_STAR            * POS(
00FF3394= 53 02                   9237      dc.b    'S',2
00FF3396= 0192                    9238      dc.w    KEY_SQR-TAB_STAR            * SQR(
00FF3398= 52 02                   9239      dc.b    'R',2
00FF339A= 0171                    9240      dc.w    KEY_RND-TAB_STAR            * RND(
00FF339C= 4C 02                   9241      dc.b    'L',2
00FF339E= 00F5                    9242      dc.w    KEY_LOG-TAB_STAR            * LOG(
00FF33A0= 45 02                   9243      dc.b    'E',2
00FF33A2= 0095                    9244      dc.w    KEY_EXP-TAB_STAR            * EXP(
00FF33A4= 43 02                   9245      dc.b    'C',2
00FF33A6= 0058                    9246      dc.w    KEY_COS-TAB_STAR            * COS(
00FF33A8= 53 02                   9247      dc.b    'S',2
00FF33AA= 0186                    9248      dc.w    KEY_SIN-TAB_STAR            * SIN(
00FF33AC= 54 02                   9249      dc.b    'T',2
00FF33AE= 01AC                    9250      dc.w    KEY_TAN-TAB_STAR            * TAN(
00FF33B0= 41 02                   9251      dc.b    'A',2
00FF33B2= 001F                    9252      dc.w    KEY_ATN-TAB_STAR            * ATN(
00FF33B4= 50 03                   9253      dc.b    'P',3
00FF33B6= 012C                    9254      dc.w    KEY_PEEK-TAB_STAR           * PEEK(
00FF33B8= 44 03                   9255      dc.b    'D',3
00FF33BA= 006A                    9256      dc.w    KEY_DEEK-TAB_STAR           * DEEK(
00FF33BC= 4C 03                   9257      dc.b    'L',3
00FF33BE= 00D7                    9258      dc.w    KEY_LEEK-TAB_STAR           * LEEK(
00FF33C0= 4C 02                   9259      dc.b    'L',2
00FF33C2= 00E2                    9260      dc.w    KEY_LEN-TAB_STAR            * LEN(
00FF33C4= 53 03                   9261      dc.b    'S',3
00FF33C6= 019E                    9262      dc.w    KEY_STRS-TAB_STAR           * STR$(
00FF33C8= 56 02                   9263      dc.b    'V',2
00FF33CA= 01D6                    9264      dc.w    KEY_VAL-TAB_STAR            * VAL(
00FF33CC= 41 02                   9265      dc.b    'A',2
00FF33CE= 001B                    9266      dc.w    KEY_ASC-TAB_STAR            * ASC(
00FF33D0= 55 05                   9267      dc.b    'U',5
00FF33D2= 01BE                    9268      dc.w    KEY_UCASES-TAB_STAR     * UCASE$(
00FF33D4= 4C 05                   9269      dc.b    'L',5
00FF33D6= 00D0                    9270      dc.w    KEY_LCASES-TAB_STAR     * LCASE$(
00FF33D8= 43 03                   9271      dc.b    'C',3
00FF33DA= 0047                    9272      dc.w    KEY_CHRS-TAB_STAR           * CHR$(
00FF33DC= 48 03                   9273      dc.b    'H',3
00FF33DE= 00B5                    9274      dc.w    KEY_HEXS-TAB_STAR           * HEX$(
00FF33E0= 42 03                   9275      dc.b    'B',3
00FF33E2= 0024                    9276      dc.w    KEY_BINS-TAB_STAR           * BIN$(
00FF33E4= 42 05                   9277      dc.b    'B',5
00FF33E6= 0035                    9278      dc.w    KEY_BITTST-TAB_STAR     * BITTST(
00FF33E8= 4D 02                   9279      dc.b    'M',2
00FF33EA= 0102                    9280      dc.w    KEY_MAX-TAB_STAR            * MAX(
00FF33EC= 4D 02                   9281      dc.b    'M',2
00FF33EE= 010B                    9282      dc.w    KEY_MIN-TAB_STAR            * MIN(
00FF33F0= 52 05                   9283      dc.b    'R',5
00FF33F2= 0146                    9284      dc.w    KEY_RAM-TAB_STAR            * RAMBASE
00FF33F4= 4B 03                   9285      dc.b    'K',3
00FF33F6= 00CA                    9286      dc.w    KEY_KEYS-TAB_STAR           * KEYS(
00FF33F8= 54 00                   9287      dc.b    'T',0
00FF33FA= 01B4                    9288      dc.w    KEY_TI-TAB_STAR         * TI
00FF33FC= 50 00                   9289      dc.b    'P',0
00FF33FE= 0131                    9290      dc.w    KEY_PI-TAB_STAR         * PI
00FF3400= 54 03                   9291      dc.b    'T',3
00FF3402= 01B8                    9292      dc.w    KEY_TWOPI-TAB_STAR      * TWOPI
00FF3404= 56 05                   9293      dc.b    'V',5
00FF3406= 01DA                    9294      dc.w    KEY_VPTR-TAB_STAR           * VARPTR(
00FF3408= 53 03                   9295      dc.b    'S',3
00FF340A= 0179                    9296      dc.w    KEY_SADD-TAB_STAR           * SADD(
00FF340C= 4C 04                   9297      dc.b    'L',4
00FF340E= 00DC                    9298      dc.w    KEY_LEFTS-TAB_STAR      * LEFT$(
00FF3410= 52 05                   9299      dc.b    'R',5
00FF3412= 016A                    9300      dc.w    KEY_RIGHTS-TAB_STAR     * RIGHT$(
00FF3414= 4D 03                   9301      dc.b    'M',3
00FF3416= 0106                    9302      dc.w    KEY_MIDS-TAB_STAR           * MID$(
00FF3418= 55 05                   9303      dc.b    'U',5
00FF341A= 01CA                    9304      dc.w    KEY_USINGS-TAB_STAR     * USING$(
00FF341C                          9305  
00FF341C                          9306  
00FF341C                          9307  *************************************************************************************
00FF341C                          9308  *
00FF341C                          9309  * BASIC error messages
00FF341C                          9310  
00FF341C                          9311  LAB_BAER
00FF341C= 002E                    9312      dc.w    LAB_NF-LAB_BAER         * $00 NEXT without FOR
00FF341E= 003F                    9313      dc.w    LAB_SN-LAB_BAER         * $02 syntax
00FF3420= 0046                    9314      dc.w    LAB_RG-LAB_BAER         * $04 RETURN without GOSUB
00FF3422= 005B                    9315      dc.w    LAB_OD-LAB_BAER         * $06 out of data
00FF3424= 0067                    9316      dc.w    LAB_FC-LAB_BAER         * $08 function call
00FF3426= 0075                    9317      dc.w    LAB_OV-LAB_BAER         * $0A overflow
00FF3428= 007E                    9318      dc.w    LAB_OM-LAB_BAER         * $0C out of memory
00FF342A= 008C                    9319      dc.w    LAB_US-LAB_BAER         * $0E undefined statement
00FF342C= 00A0                    9320      dc.w    LAB_BS-LAB_BAER         * $10 array bounds
00FF342E= 00AD                    9321      dc.w    LAB_DD-LAB_BAER         * $12 double dimension array
00FF3430= 00BE                    9322      dc.w    LAB_D0-LAB_BAER         * $14 divide by 0
00FF3432= 00CD                    9323      dc.w    LAB_ID-LAB_BAER         * $16 illegal direct
00FF3434= 00DC                    9324      dc.w    LAB_TM-LAB_BAER         * $18 type mismatch
00FF3436= 00EA                    9325      dc.w    LAB_LS-LAB_BAER         * $1A long string
00FF3438= 00FA                    9326      dc.w    LAB_ST-LAB_BAER         * $1C string too complex
00FF343A= 010D                    9327      dc.w    LAB_CN-LAB_BAER         * $1E continue error
00FF343C= 011C                    9328      dc.w    LAB_UF-LAB_BAER         * $20 undefined function
00FF343E= 012F                    9329      dc.w    LAB_LD-LAB_BAER         * $22 LOOP without DO
00FF3440= 013F                    9330      dc.w    LAB_UV-LAB_BAER         * $24 undefined variable
00FF3442= 0152                    9331      dc.w    LAB_UA-LAB_BAER         * $26 undimensioned array
00FF3444= 0166                    9332      dc.w    LAB_WD-LAB_BAER         * $28 wrong dimensions
00FF3446= 0177                    9333      dc.w    LAB_AD-LAB_BAER         * $2A address
00FF3448= 017F                    9334      dc.w    LAB_FO-LAB_BAER         * $2C format
00FF344A                          9335  
00FF344A= 4E 45 58 54 20 77 ...   9336  LAB_NF  dc.b    'NEXT without FOR',$00
00FF345B= 53 79 6E 74 61 78 00    9337  LAB_SN  dc.b    'Syntax',$00
00FF3462= 52 45 54 55 52 4E ...   9338  LAB_RG  dc.b    'RETURN without GOSUB',$00
00FF3477= 4F 75 74 20 6F 66 ...   9339  LAB_OD  dc.b    'Out of DATA',$00
00FF3483= 46 75 6E 63 74 69 ...   9340  LAB_FC  dc.b    'Function call',$00
00FF3491= 4F 76 65 72 66 6C ...   9341  LAB_OV  dc.b    'Overflow',$00
00FF349A= 4F 75 74 20 6F 66 ...   9342  LAB_OM  dc.b    'Out of memory',$00
00FF34A8= 55 6E 64 65 66 69 ...   9343  LAB_US  dc.b    'Undefined statement',$00
00FF34BC= 41 72 72 61 79 20 ...   9344  LAB_BS  dc.b    'Array bounds',$00
00FF34C9= 44 6F 75 62 6C 65 ...   9345  LAB_DD  dc.b    'Double dimension',$00
00FF34DA= 44 69 76 69 64 65 ...   9346  LAB_D0  dc.b    'Divide by zero',$00
00FF34E9= 49 6C 6C 65 67 61 ...   9347  LAB_ID  dc.b    'Illegal direct',$00
00FF34F8= 54 79 70 65 20 6D ...   9348  LAB_TM  dc.b    'Type mismatch',$00
00FF3506= 53 74 72 69 6E 67 ...   9349  LAB_LS  dc.b    'String too long',$00
00FF3516= 53 74 72 69 6E 67 ...   9350  LAB_ST  dc.b    'String too complex',$00
00FF3529= 43 61 6E 27 74 20 ...   9351  LAB_CN  dc.b    'Can''t continue',$00
00FF3538= 55 6E 64 65 66 69 ...   9352  LAB_UF  dc.b    'Undefined function',$00
00FF354B= 4C 4F 4F 50 20 77 ...   9353  LAB_LD  dc.b    'LOOP without DO',$00
00FF355B= 55 6E 64 65 66 69 ...   9354  LAB_UV  dc.b    'Undefined variable',$00
00FF356E= 55 6E 64 69 6D 65 ...   9355  LAB_UA  dc.b    'Undimensioned array',$00
00FF3582= 57 72 6F 6E 67 20 ...   9356  LAB_WD  dc.b    'Wrong dimensions',$00
00FF3593= 41 64 64 72 65 73 ...   9357  LAB_AD  dc.b    'Address',$00
00FF359B= 46 6F 72 6D 61 74 00    9358  LAB_FO  dc.b    'Format',$00
00FF35A2                          9359  
00FF35A2                          9360  
00FF35A2                          9361  *************************************************************************************
00FF35A2                          9362  *
00FF35A2                          9363  * keyword table for line (un)crunching
00FF35A2                          9364  
00FF35A2                          9365  * [keyword,token
00FF35A2                          9366  * [keyword,token]]
00FF35A2                          9367  * end marker (#$00)
00FF35A2                          9368  
00FF35A2                          9369  TAB_STAR
00FF35A2                          9370  KEY_MULT
00FF35A2= C1 00                   9371      dc.b TK_MULT,$00                * *
00FF35A4                          9372  TAB_PLUS
00FF35A4                          9373  KEY_PLUS
00FF35A4= BF 00                   9374      dc.b TK_PLUS,$00                * +
00FF35A6                          9375  TAB_MNUS
00FF35A6                          9376  KEY_MINUS
00FF35A6= C0 00                   9377      dc.b TK_MINUS,$00               * -
00FF35A8                          9378  TAB_SLAS
00FF35A8                          9379  KEY_DIV
00FF35A8= C2 00                   9380      dc.b TK_DIV,$00             * /
00FF35AA                          9381  TAB_LESS
00FF35AA                          9382  KEY_LSHIFT
00FF35AA= 3C C8                   9383      dc.b    '<',TK_LSHIFT           * <<
00FF35AC                          9384  KEY_LT
00FF35AC= CB                      9385      dc.b TK_LT                  * <
00FF35AD= 00                      9386      dc.b    $00
00FF35AE                          9387  TAB_EQUL
00FF35AE                          9388  KEY_EQUAL
00FF35AE= CA 00                   9389      dc.b TK_EQUAL,$00               * =
00FF35B0                          9390  TAB_MORE
00FF35B0                          9391  KEY_RSHIFT
00FF35B0= 3E C7                   9392      dc.b    '>',TK_RSHIFT           * >>
00FF35B2                          9393  KEY_GT
00FF35B2= C9                      9394      dc.b TK_GT                  * >
00FF35B3= 00                      9395      dc.b    $00
00FF35B4                          9396  TAB_QEST
00FF35B4= 9E 00                   9397      dc.b TK_PRINT,$00               * ?
00FF35B6                          9398  TAB_ASCA
00FF35B6                          9399  KEY_ABS
00FF35B6= 42 53 28 CE             9400      dc.b    'BS(',TK_ABS            * ABS(
00FF35BA                          9401  KEY_AND
00FF35BA= 4E 44 C4                9402      dc.b    'ND',TK_AND             * AND
00FF35BD                          9403  KEY_ASC
00FF35BD= 53 43 28 E0             9404      dc.b    'SC(',TK_ASC            * ASC(
00FF35C1                          9405  KEY_ATN
00FF35C1= 54 4E 28 D9             9406      dc.b    'TN(',TK_ATN            * ATN(
00FF35C5= 00                      9407      dc.b    $00
00FF35C6                          9408  TAB_ASCB
00FF35C6                          9409  KEY_BINS
00FF35C6= 49 4E 24 28 E5          9410      dc.b    'IN$(',TK_BINS          * BIN$(
00FF35CB                          9411  KEY_BITCLR
00FF35CB= 49 54 43 4C 52 B4       9412      dc.b    'ITCLR',TK_BITCLR           * BITCLR
00FF35D1                          9413  KEY_BITSET
00FF35D1= 49 54 53 45 54 B3       9414      dc.b    'ITSET',TK_BITSET           * BITSET
00FF35D7                          9415  KEY_BITTST
00FF35D7= 49 54 54 53 54 28 E6    9416      dc.b    'ITTST(',TK_BITTST      * BITTST(
00FF35DE                          9417  KEY_BUFFER
00FF35DE= 55 46 46 45 52 A0       9418      dc.b    'UFFER',TK_BUFFER           * BUFFER
00FF35E4= 00                      9419      dc.b    $00
00FF35E5                          9420  TAB_ASCC
00FF35E5                          9421  KEY_CALL
00FF35E5= 41 4C 4C 9B             9422      dc.b    'ALL',TK_CALL           * CALL
00FF35E9                          9423  KEY_CHRS
00FF35E9= 48 52 24 28 E3          9424      dc.b    'HR$(',TK_CHRS          * CHR$(
00FF35EE                          9425  KEY_CLEAR
00FF35EE= 4C 45 41 52 AE          9426      dc.b    'LEAR',TK_CLEAR         * CLEAR
00FF35F3                          9427  KEY_CLS
00FF35F3= 4C 53 A1                9428      dc.b    'LS',TK_CLS             * CLS
00FF35F6                          9429  KEY_CONT
00FF35F6= 4F 4E 54 9F             9430      dc.b    'ONT',TK_CONT           * CONT
00FF35FA                          9431  KEY_COS
00FF35FA= 4F 53 28 D6             9432      dc.b    'OS(',TK_COS            * COS(
00FF35FE                          9433  KEY_CURSOR
00FF35FE= 55 52 53 4F 52 A2       9434      dc.b    'URSOR',TK_CURSOR           * CURSOR
00FF3604= 00                      9435      dc.b    $00
00FF3605                          9436  TAB_ASCD
00FF3605                          9437  KEY_DATA
00FF3605= 41 54 41 83             9438      dc.b    'ATA',TK_DATA           * DATA
00FF3609                          9439  KEY_DEC
00FF3609= 45 43 88                9440      dc.b    'EC',TK_DEC             * DEC
00FF360C                          9441  KEY_DEEK
00FF360C= 45 45 4B 28 DB          9442      dc.b    'EEK(',TK_DEEK          * DEEK(
00FF3611                          9443  KEY_DEF
00FF3611= 45 46 97                9444      dc.b    'EF',TK_DEF             * DEF
00FF3614                          9445  KEY_DIM
00FF3614= 49 4D 85                9446      dc.b    'IM',TK_DIM             * DIM
00FF3617                          9447  KEY_DOKE
00FF3617= 4F 4B 45 99             9448      dc.b    'OKE',TK_DOKE           * DOKE
00FF361B                          9449  KEY_DO
00FF361B= 4F 9C                   9450      dc.b    'O',TK_DO               * DO
00FF361D= 00                      9451      dc.b    $00
00FF361E                          9452  TAB_ASCE
00FF361E                          9453  KEY_ELSE
00FF361E= 4C 53 45 B6             9454      dc.b    'LSE',TK_ELSE           * ELSE
00FF3622                          9455  KEY_END
00FF3622= 4E 44 80                9456      dc.b    'ND',TK_END             * END
00FF3625                          9457  KEY_FELLIPSE
00FF3625= 4C 4C 49 50 53 45 ...   9458      dc.b    'LLIPSEF',TK_FELLIPSE       * ELLIPSEF
00FF362D                          9459  KEY_ELLIPSE
00FF362D= 4C 4C 49 50 53 45 A9    9460      dc.b    'LLIPSE',TK_ELLIPSE     * ELLIPSE
00FF3634                          9461  KEY_EOR
00FF3634= 4F 52 C5                9462      dc.b    'OR',TK_EOR             * EOR
00FF3637                          9463  KEY_EXP
00FF3637= 58 50 28 D5             9464      dc.b    'XP(',TK_EXP            * EXP(
00FF363B= 00                      9465      dc.b    $00
00FF363C                          9466  TAB_ASCF
00FF363C                          9467  KEY_FILL
00FF363C= 49 4C 4C A4             9468      dc.b    'ILL',TK_FILL           * FILL
00FF3640                          9469  KEY_FOR
00FF3640= 4F 52 81                9470      dc.b    'OR',TK_FOR             * FOR
00FF3643                          9471  KEY_FN
00FF3643= 4E B8                   9472      dc.b    'N',TK_FN               * FN
00FF3645                          9473  KEY_FRE
00FF3645= 52 45 28 D0             9474      dc.b    'RE(',TK_FRE            * FRE(
00FF3649= 00                      9475      dc.b    $00
00FF364A                          9476  TAB_ASCG
00FF364A                          9477  KEY_GET
00FF364A= 45 54 B1                9478      dc.b    'ET',TK_GET             * GET
00FF364D                          9479  KEY_GOTO
00FF364D= 4F 54 4F 89             9480      dc.b    'OTO',TK_GOTO           * GOTO
00FF3651                          9481  KEY_GOSUB
00FF3651= 4F 53 55 42 8D          9482      dc.b    'OSUB',TK_GOSUB         * GOSUB
00FF3656= 00                      9483      dc.b    $00
00FF3657                          9484  TAB_ASCH
00FF3657                          9485  KEY_HEXS
00FF3657= 45 58 24 28 E4 00       9486      dc.b    'EX$(',TK_HEXS,$00      * HEX$(
00FF365D                          9487  TAB_ASCI
00FF365D                          9488  KEY_IF
00FF365D= 46 8B                   9489      dc.b    'F',TK_IF               * IF
00FF365F                          9490  KEY_INC
00FF365F= 4E 43 93                9491      dc.b    'NC',TK_INC             * INC
00FF3662                          9492  KEY_INPUT
00FF3662= 4E 50 55 54 84          9493      dc.b    'NPUT',TK_INPUT         * INPUT
00FF3667                          9494  KEY_INT
00FF3667= 4E 54 28 CD             9495      dc.b    'NT(',TK_INT            * INT(
00FF366B= 00                      9496      dc.b    $00
00FF366C                          9497  TAB_ASCK
00FF366C                          9498  KEY_KEYS
00FF366C= 45 59 53 28 EA          9499      dc.b    'EYS(',TK_KEYS          * KEYS(
00FF3671= 00                      9500      dc.b    $00
00FF3672                          9501  TAB_ASCL
00FF3672                          9502  KEY_LCASES
00FF3672= 43 41 53 45 24 28 E2    9503      dc.b    'CASE$(',TK_LCASES      * LCASE$(
00FF3679                          9504  KEY_LEEK
00FF3679= 45 45 4B 28 DC          9505      dc.b    'EEK(',TK_LEEK          * LEEK(
00FF367E                          9506  KEY_LEFTS
00FF367E= 45 46 54 24 28 F0       9507      dc.b    'EFT$(',TK_LEFTS            * LEFT$(
00FF3684                          9508  KEY_LEN
00FF3684= 45 4E 28 DD             9509      dc.b    'EN(',TK_LEN            * LEN(
00FF3688                          9510  KEY_LET
00FF3688= 45 54 87                9511      dc.b    'ET',TK_LET             * LET
00FF368B                          9512  KEY_LINE
00FF368B= 49 4E 45 A3             9513      dc.b    'INE',TK_LINE           * LINE
00FF368F                          9514  KEY_LIST
00FF368F= 49 53 54 AD             9515      dc.b    'IST',TK_LIST           * LIST
00FF3693                          9516  KEY_LOAD
00FF3693= 4F 41 44 95             9517      dc.b    'OAD',TK_LOAD           * LOAD
00FF3697                          9518  KEY_LOG
00FF3697= 4F 47 28 D4             9519      dc.b    'OG(',TK_LOG            * LOG(
00FF369B                          9520  KEY_LOKE
00FF369B= 4F 4B 45 9A             9521      dc.b    'OKE',TK_LOKE           * LOKE
00FF369F                          9522  KEY_LOOP
00FF369F= 4F 4F 50 9D             9523      dc.b    'OOP',TK_LOOP           * LOOP
00FF36A3= 00                      9524      dc.b    $00
00FF36A4                          9525  TAB_ASCM
00FF36A4                          9526  KEY_MAX
00FF36A4= 41 58 28 E7             9527      dc.b    'AX(',TK_MAX            * MAX(
00FF36A8                          9528  KEY_MIDS
00FF36A8= 49 44 24 28 F2          9529      dc.b    'ID$(',TK_MIDS          * MID$(
00FF36AD                          9530  KEY_MIN
00FF36AD= 49 4E 28 E8             9531      dc.b    'IN(',TK_MIN            * MIN(
00FF36B1                          9532  KEY_MODE
00FF36B1= 4F 44 45 AB             9533      dc.b    'ODE',TK_MODE           * MODE
00FF36B5                          9534  KEY_MOVE
00FF36B5= 4F 56 45 A5             9535      dc.b    'OVE',TK_MOVE           * MOVE
00FF36B9= 00                      9536      dc.b    $00
00FF36BA                          9537  TAB_ASCN
00FF36BA                          9538  KEY_NEW
00FF36BA= 45 57 AF                9539      dc.b    'EW',TK_NEW             * NEW
00FF36BD                          9540  KEY_NEXT
00FF36BD= 45 58 54 82             9541      dc.b    'EXT',TK_NEXT           * NEXT
00FF36C1                          9542  KEY_NOT
00FF36C1= 4F 54 BB                9543      dc.b    'OT',TK_NOT             * NOT
00FF36C4                          9544  KEY_NULL
00FF36C4= 55 4C 4C 92             9545      dc.b    'ULL',TK_NULL           * NULL
00FF36C8= 00                      9546      dc.b    $00
00FF36C9                          9547  TAB_ASCO
00FF36C9                          9548  KEY_ON
00FF36C9= 4E 91                   9549      dc.b    'N',TK_ON               * ON
00FF36CB                          9550  KEY_OR
00FF36CB= 52 C6                   9551      dc.b    'R',TK_OR               * OR
00FF36CD= 00                      9552      dc.b    $00
00FF36CE                          9553  TAB_ASCP
00FF36CE                          9554  KEY_PEEK
00FF36CE= 45 45 4B 28 DA          9555      dc.b    'EEK(',TK_PEEK          * PEEK(
00FF36D3                          9556  KEY_PI
00FF36D3= 49 EC                   9557      dc.b    'I',TK_PI               * PI
00FF36D5                          9558  KEY_POINT
00FF36D5= 4F 49 4E 54 A6          9559      dc.b    'OINT',TK_POINT         * POINT
00FF36DA                          9560  KEY_POKE
00FF36DA= 4F 4B 45 98             9561      dc.b    'OKE',TK_POKE           * POKE
00FF36DE                          9562  KEY_POS
00FF36DE= 4F 53 28 D1             9563      dc.b    'OS(',TK_POS            * POS(
00FF36E2                          9564  KEY_PRINT
00FF36E2= 52 49 4E 54 9E          9565      dc.b    'RINT',TK_PRINT         * PRINT
00FF36E7= 00                      9566      dc.b    $00
00FF36E8                          9567  TAB_ASCR
00FF36E8                          9568  KEY_RAM
00FF36E8= 41 4D 42 41 53 45 E9    9569      dc.b    'AMBASE',TK_RAM         * RAMBASE
00FF36EF                          9570  KEY_READ
00FF36EF= 45 41 44 86             9571      dc.b    'EAD',TK_READ           * READ
00FF36F3                          9572  KEY_FRECT
00FF36F3= 45 43 54 46 A8          9573      dc.b    'ECTF',TK_FRECT         * RECTF
00FF36F8                          9574  KEY_RECT
00FF36F8= 45 43 54 A7             9575      dc.b    'ECT',TK_RECT           * RECT
00FF36FC                          9576  KEY_REM
00FF36FC= 45 4D 8F                9577      dc.b    'EM',TK_REM             * REM
00FF36FF                          9578  KEY_RESTORE
00FF36FF= 45 53 54 4F 52 45 8C    9579      dc.b    'ESTORE',TK_RESTORE     * RESTORE
00FF3706                          9580  KEY_RETURN
00FF3706= 45 54 55 52 4E 8E       9581      dc.b    'ETURN',TK_RETURN           * RETURN
00FF370C                          9582  KEY_RIGHTS
00FF370C= 49 47 48 54 24 28 F1    9583      dc.b    'IGHT$(',TK_RIGHTS      * RIGHT$(
00FF3713                          9584  KEY_RND
00FF3713= 4E 44 28 D3             9585      dc.b    'ND(',TK_RND            * RND(
00FF3717                          9586  KEY_RUN
00FF3717= 55 4E 8A                9587      dc.b    'UN',TK_RUN             * RUN
00FF371A= 00                      9588      dc.b    $00
00FF371B                          9589  TAB_ASCS
00FF371B                          9590  KEY_SADD
00FF371B= 41 44 44 28 EF          9591      dc.b    'ADD(',TK_SADD          * SADD(
00FF3720                          9592  KEY_SAVE
00FF3720= 41 56 45 96             9593      dc.b    'AVE',TK_SAVE           * SAVE
00FF3724                          9594  KEY_SGN
00FF3724= 47 4E 28 CC             9595      dc.b    'GN(',TK_SGN            * SGN(
00FF3728                          9596  KEY_SIN
00FF3728= 49 4E 28 D7             9597      dc.b    'IN(',TK_SIN            * SIN(
00FF372C                          9598  KEY_SIZE
00FF372C= 49 5A 45 AC             9599      dc.b    'IZE',TK_SIZE           * SIZE
00FF3730                          9600  KEY_SPC
00FF3730= 50 43 28 B9             9601      dc.b    'PC(',TK_SPC            * SPC(
00FF3734                          9602  KEY_SQR
00FF3734= 51 52 28 D2             9603      dc.b    'QR(',TK_SQR            * SQR(
00FF3738                          9604  KEY_STEP
00FF3738= 54 45 50 BC             9605      dc.b    'TEP',TK_STEP           * STEP
00FF373C                          9606  KEY_STOP
00FF373C= 54 4F 50 90             9607      dc.b    'TOP',TK_STOP           * STOP
00FF3740                          9608  KEY_STRS
00FF3740= 54 52 24 28 DE          9609      dc.b    'TR$(',TK_STRS          * STR$(
00FF3745                          9610  KEY_SWAP
00FF3745= 57 41 50 B2             9611      dc.b    'WAP',TK_SWAP           * SWAP
00FF3749= 00                      9612      dc.b    $00
00FF374A                          9613  TAB_ASCT
00FF374A                          9614  KEY_TAB
00FF374A= 41 42 28 B5             9615      dc.b    'AB(',TK_TAB            * TAB(
00FF374E                          9616  KEY_TAN
00FF374E= 41 4E 28 D8             9617      dc.b    'AN(',TK_TAN            * TAN
00FF3752                          9618  KEY_THEN
00FF3752= 48 45 4E BA             9619      dc.b    'HEN',TK_THEN           * THEN
00FF3756                          9620  KEY_TI
00FF3756= 49 EB                   9621      dc.b    'I',TK_TI               * TI
00FF3758                          9622  KEY_TO
00FF3758= 4F B7                   9623      dc.b    'O',TK_TO               * TO
00FF375A                          9624  KEY_TWOPI
00FF375A= 57 4F 50 49 ED          9625      dc.b    'WOPI',TK_TWOPI         * TWOPI
00FF375F= 00                      9626      dc.b    $00
00FF3760                          9627  TAB_ASCU
00FF3760                          9628  KEY_UCASES
00FF3760= 43 41 53 45 24 28 E1    9629      dc.b    'CASE$(',TK_UCASES      * UCASE$(
00FF3767                          9630  KEY_UNTIL
00FF3767= 4E 54 49 4C BD          9631      dc.b    'NTIL',TK_UNTIL         * UNTIL
00FF376C                          9632  KEY_USINGS
00FF376C= 53 49 4E 47 24 28 F3    9633      dc.b    'SING$(',TK_USINGS      * USING$(
00FF3773                          9634  KEY_USR
00FF3773= 53 52 28 CF             9635      dc.b    'SR(',TK_USR            * USR(
00FF3777= 00                      9636      dc.b    $00
00FF3778                          9637  TAB_ASCV
00FF3778                          9638  KEY_VAL
00FF3778= 41 4C 28 DF             9639      dc.b    'AL(',TK_VAL            * VAL(
00FF377C                          9640  KEY_VPTR
00FF377C= 41 52 50 54 52 28 EE    9641      dc.b    'ARPTR(',TK_VPTR            * VARPTR(
00FF3783= 00                      9642      dc.b    $00
00FF3784                          9643  TAB_ASCW
00FF3784                          9644  KEY_WAIT
00FF3784= 41 49 54 94             9645      dc.b    'AIT',TK_WAIT           * WAIT
00FF3788                          9646  KEY_WHILE
00FF3788= 48 49 4C 45 BE          9647      dc.b    'HILE',TK_WHILE         * WHILE
00FF378D                          9648  KEY_WIDTH
00FF378D= 49 44 54 48 B0          9649      dc.b    'IDTH',TK_WIDTH         * WIDTH
00FF3792= 00                      9650      dc.b    $00
00FF3793                          9651  TAB_POWR
00FF3793                          9652  KEY_POWER
00FF3793= C3 00                   9653      dc.b    TK_POWER,$00            * ^
00FF3795                          9654  
00FF3795                          9655  
00FF3795                          9656  *************************************************************************************
00FF3795                          9657  *
00FF3795                          9658  * just messages
00FF3795                          9659  
00FF3795                          9660  LAB_BMSG
00FF3795= 0D 0A 42 72 65 61 ...   9661      dc.b    $0D,$0A,'Break',$00
00FF379D                          9662  LAB_EMSG
00FF379D= 20 45 72 72 6F 72 00    9663      dc.b    ' Error',$00
00FF37A4                          9664  LAB_LMSG
00FF37A4= 20 69 6E 20 6C 69 ...   9665      dc.b    ' in line ',$00
00FF37AE                          9666  LAB_IMSG
00FF37AE= 45 78 74 72 61 20 ...   9667      dc.b    'Extra ignored',$0D,$0A,$00
00FF37BE                          9668  LAB_REDO
00FF37BE= 52 65 64 6F 20 66 ...   9669      dc.b    'Redo from start',$0D,$0A,$00
00FF37D0                          9670  LAB_RMSG
00FF37D0= 0D 0A 52 65 61 64 ...   9671      dc.b    $0D,$0A,'Ready',$0D,$0A,$00
00FF37DA                          9672  LAB_SMSG
00FF37DA= 20 42 79 74 65 73 ...   9673      dc.b    ' Bytes free',$0D,$0A,$0A
00FF37E8= 45 6E 68 61 6E 63 ...   9674      dc.b    'Enhanced 68k BASIC Version 3.52',$0D,$0A
00FF3809= 66 6F 72 20 74 68 ...   9675      dc.b    'for the Raven68k computing project',$0D,$0A
00FF382D= 28 42 75 69 6C 64 ...   9676      dc.b    '(Build: 0.0.2-rev1, 2021-02-29)',$0D,$0A,$00
00FF384F                          9677  
00FF384F                          9678  *************************************************************************************
00FF384F                          9679  * EhBASIC keywords quick reference list                             *
00FF384F                          9680  *************************************************************************************
00FF384F                          9681  
00FF384F                          9682  * glossary
00FF384F                          9683  
00FF384F                          9684  *       <.>       required
00FF384F                          9685  *       {.|.}         one of required
00FF384F                          9686  *       [.]       optional
00FF384F                          9687  *       ...       may repeat as last
00FF384F                          9688  
00FF384F                          9689  *       any     = anything
00FF384F                          9690  *       num     = number
00FF384F                          9691  *       state       = statement
00FF384F                          9692  *       pint        = positive integer
00FF384F                          9693  *       str     = string
00FF384F                          9694  *       var     = variable
00FF384F                          9695  *       nvar        = numeric variable
00FF384F                          9696  *       svar        = string variable
00FF384F                          9697  *       expr        = expression
00FF384F                          9698  *       nexpr       = numeric expression
00FF384F                          9699  *       sexpr       = string expression
00FF384F                          9700  
00FF384F                          9701  * statement separator
00FF384F                          9702  
00FF384F                          9703  * :     . [<state>] : [<state>]                     * done
00FF384F                          9704  
00FF384F                          9705  * number bases
00FF384F                          9706  
00FF384F                          9707  * %     . %<binary num>                         * done
00FF384F                          9708  * $     . $<hex num>                            * done
00FF384F                          9709  
00FF384F                          9710  * commands
00FF384F                          9711  
00FF384F                          9712  * END       . END                                   * done
00FF384F                          9713  * FOR       . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00FF384F                          9714  * NEXT  . NEXT [<nvar>[,<nvar>]...]                 * done
00FF384F                          9715  * DATA  . DATA [{num|["]str["]}[,{num|["]str["]}]...]       * done
00FF384F                          9716  * INPUT . INPUT [<">str<">;] <var>[,<var>[,<var>]...]       * done
00FF384F                          9717  * DIM       . DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])            * done
00FF384F                          9718  * READ  . READ <var>[,<var>[,<var>]...]             * done
00FF384F                          9719  * LET       . [LET] <var>=<expr>                        * done
00FF384F                          9720  * DEC       . DEC <nvar>[,<nvar>[,<nvar>]...]               * done
00FF384F                          9721  * GOTO  . GOTO <pint>                           * done
00FF384F                          9722  * RUN       . RUN [pint]                            * done
00FF384F                          9723  * IF        . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00FF384F                          9724  * RESTORE   . RESTORE [pint]                            * done
00FF384F                          9725  * GOSUB . GOSUB <pint>                          * done
00FF384F                          9726  * RETURN    . RETURN                                * done
00FF384F                          9727  * REM       . REM [any]                             * done
00FF384F                          9728  * STOP  . STOP                              * done
00FF384F                          9729  * ON        . ON <nexpr> {GOTO|GOSUB} <pint>[,<pint>[,<pint>]...]   * done
00FF384F                          9730  * NULL  . NULL <nexpr>                          * done
00FF384F                          9731  * INC       . INC <nvar>[,<nvar>[,<nvar>]...]               * done
00FF384F                          9732  * WAIT  . WAIT <nexpr>,<nexpr>[,<nexpr>]                * done
00FF384F                          9733  * LOAD  . LOAD [<sexpr>]                            * done for simulator
00FF384F                          9734  * SAVE  . SAVE [<sexpr>][,[<n>][-<n>]]              * done for simulator
00FF384F                          9735  * DEF       . DEF FN<var>(<var>)=<expr>                 * done
00FF384F                          9736  * POKE  . POKE <nexpr>,<nexpr>                      * done
00FF384F                          9737  * DOKE  . DOKE <nexpr>,<nexpr>                      * done
00FF384F                          9738  * LOKE  . LOKE <nexpr>,<nexpr>                      * done
00FF384F                          9739  * CALL  . CALL <nexpr>                          * done
00FF384F                          9740  * DO        . DO                                    * done
00FF384F                          9741  * LOOP  . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00FF384F                          9742  * PRINT . PRINT [{;|,}][expr][{;|,}[expr][{;|,}[expr]]...]  * done
00FF384F                          9743  * CONT  . CONT                              * done
00FF384F                          9744  * LIST  . LIST [pint][-pint]                        * done
00FF384F                          9745  * CLEAR . CLEAR                             * done
00FF384F                          9746  * NEW       . NEW                                   * done
00FF384F                          9747  * WIDTH . WIDTH [<pint>][,<pint>]                   * done
00FF384F                          9748  * GET       . GET <var>                             * done
00FF384F                          9749  * SWAP  . SWAP <var>,<var>                      * done
00FF384F                          9750  * BITSET    . BITSET <nexpr>,<nexpr>                    * done
00FF384F                          9751  * BITCLR    . BITCLR <nexpr>,<nexpr>                    * done
00FF384F                          9752  
00FF384F                          9753  * new graphics commands for EASy68k
00FF384F                          9754  
00FF384F                          9755  * BUFFER    . BUFFER                                * done
00FF384F                          9756  * CLS       . CLS                                   * done
00FF384F                          9757  * CURSOR    . CURSOR <nexpr>,<nexpr>                    * done
00FF384F                          9758  * LINE  . LINE <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,][<nexpr>]    * done
00FF384F                          9759  * FILL  . FILL <nexpr>,<nexpr>[,][<nexpr>]              * done
00FF384F                          9760  * MOVE  . MOVE <nexpr>,<nexpr>                      * done
00FF384F                          9761  * POINT . POINT <nexpr>,<nexpr>[,][<nexpr>]             * done
00FF384F                          9762  * RECT  . RECT <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]    * done
00FF384F                          9763  * RECTF . RECTF <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]   * done
00FF384F                          9764  * ELLIPSE   . ELLIPSE <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]] * done
00FF384F                          9765  * ELLIPSEF  . ELLIPSEF <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]    * done
00FF384F                          9766  * MODE  . MODE <pint>                           * done
00FF384F                          9767  * SIZE  . SIZE <pint>                           * done
00FF384F                          9768  
00FF384F                          9769  * sub commands (may not start a statement)
00FF384F                          9770  
00FF384F                          9771  * TAB       . TAB(<nexpr>)                          * done
00FF384F                          9772  * ELSE  . IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]    * done
00FF384F                          9773  * TO        . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00FF384F                          9774  * FN        . FN<var>(<expr>)                           * done
00FF384F                          9775  * SPC       . SPC(<nexpr>)                          * done
00FF384F                          9776  * THEN  . IF <nexpr> {THEN {pint|comm}|GOTO <pint>}     * done
00FF384F                          9777  * NOT       . NOT <nexpr>                           * done
00FF384F                          9778  * STEP  . FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]      * done
00FF384F                          9779  * UNTIL . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00FF384F                          9780  * WHILE . LOOP [{WHILE|UNTIL}<nexpr>]                   * done
00FF384F                          9781  
00FF384F                          9782  * operators
00FF384F                          9783  
00FF384F                          9784  * +     . [expr] + <expr>                           * done
00FF384F                          9785  * -     . [nexpr] - <nexpr>                     * done
00FF384F                          9786  * *     . <nexpr> * <nexpr>                     * done fast hardware
00FF384F                          9787  * /     . <nexpr> / <nexpr>                     * done fast hardware
00FF384F                          9788  * ^     . <nexpr> ^ <nexpr>                     * done
00FF384F                          9789  * AND       . <nexpr> AND <nexpr>                       * done
00FF384F                          9790  * EOR       . <nexpr> EOR <nexpr>                       * done
00FF384F                          9791  * OR        . <nexpr> OR <nexpr>                        * done
00FF384F                          9792  * >>        . <nexpr> >> <nexpr>                        * done
00FF384F                          9793  * <<        . <nexpr> << <nexpr>                        * done
00FF384F                          9794  
00FF384F                          9795  * compare functions
00FF384F                          9796  
00FF384F                          9797  * <     . <expr> < <expr>                           * done
00FF384F                          9798  * =     . <expr> = <expr>                           * done
00FF384F                          9799  * >     . <expr> > <expr>                           * done
00FF384F                          9800  
00FF384F                          9801  * functions
00FF384F                          9802  
00FF384F                          9803  * SGN       . SGN(<nexpr>)                          * done
00FF384F                          9804  * INT       . INT(<nexpr>)                          * done
00FF384F                          9805  * ABS       . ABS(<nexpr>)                          * done
00FF384F                          9806  * USR       . USR(<expr>)                           * done
00FF384F                          9807  * FRE       . FRE(<expr>)                           * done
00FF384F                          9808  * POS       . POS(<expr>)                           * done
00FF384F                          9809  * SQR       . SQR(<nexpr>)                          * done fast shift/sub
00FF384F                          9810  * RND       . RND(<nexpr>)                          * done 32 bit PRNG
00FF384F                          9811  * LOG       . LOG(<nexpr>)                          * done fast cordic
00FF384F                          9812  * EXP       . EXP(<nexpr>)                          * done fast cordic
00FF384F                          9813  * COS       . COS(<nexpr>)                          * done fast cordic
00FF384F                          9814  * SIN       . SIN(<nexpr>)                          * done fast cordic
00FF384F                          9815  * TAN       . TAN(<nexpr>)                          * done fast cordic
00FF384F                          9816  * ATN       . ATN(<nexpr>)                          * done fast cordic
00FF384F                          9817  * PEEK  . PEEK(<nexpr>)                         * done
00FF384F                          9818  * DEEK  . DEEK(<nexpr>)                         * done
00FF384F                          9819  * LEEK  . LEEK(<nexpr>)                         * done
00FF384F                          9820  * LEN       . LEN(<sexpr>)                          * done
00FF384F                          9821  * STR$  . STR$(<nexpr>)                         * done
00FF384F                          9822  * VAL       . VAL(<sexpr>)                          * done
00FF384F                          9823  * ASC       . ASC(<sexpr>)                          * done
00FF384F                          9824  * UCASE$    . UCASE$(<sexpr>)                           * done
00FF384F                          9825  * LCASE$    . LCASE$(<sexpr>)                           * done
00FF384F                          9826  * CHR$  . CHR$(<nexpr>)                         * done
00FF384F                          9827  * HEX$  . HEX$(<nexpr>)                         * done
00FF384F                          9828  * BIN$  . BIN$(<nexpr>)                         * done
00FF384F                          9829  * BTST  . BTST(<nexpr>,<nexpr>)                     * done
00FF384F                          9830  * MAX       . MAX(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00FF384F                          9831  * MIN       . MIN(<nexpr>[,<nexpr>[,<nexpr>]...])           * done
00FF384F                          9832  * KEYS  . KEYS(<expr>)                          * done for simulator
00FF384F                          9833  * TI        . TI                                    * done for simulator
00FF384F                          9834  * PI        . PI                                    * done
00FF384F                          9835  * TWOPI . TWOPI                             * done
00FF384F                          9836  * VARPTR    . VARPTR(<var>)                         * done
00FF384F                          9837  * SADD  . SADD(<svar>)                          * done
00FF384F                          9838  * LEFT$ . LEFT$(<sexpr>,<nexpr>)                    * done
00FF384F                          9839  * RIGHT$    . RIGHT$(<sexpr>,<nexpr>)                   * done
00FF384F                          9840  * MID$  . MID$(<sexpr>,<nexpr>[,<nexpr>])               * done
00FF384F                          9841  * USING$    . USING$(<sexpr>,<nexpr>[,<nexpr>]...])         * done
00FF384F                          9842  
00FF384F                          9843  * New functions for EASy68k
00FF384F                          9844  
00FF384F                          9845  * POINT . POINT(<nexpr>,<nexpr>)                    * done
00FF384F                          9846  
00FF384F                          9847  
00FF384F                          9848  *************************************************************************************
00FF384F                          9849  
00FF384F                          9850      END code_start

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
AC1GTAC2            FF1D4E
ACR                 200009
ASPTL               9A8
ASRCH               9DA
ASTRTL              9AC
BHSEND              9D6
BIN2DEC             FF2D0A
BINPR               FF28F0
BINSS               9B6
BLINEL              856
BREAKF              9DC
CCBYTE              9E9
CCFLAG              9E8
CCNULL              9EA
CFLAG               9E1
CLINEL              852
CODE_START          FF007A
COMP_F              9E3
COSOUT              9B4
CPNTRL              85A
CRA                 200005
CRB                 200015
CSRA                200003
CSRB                200013
CVARAL              86E
D1X02               FF2CE4
D1X10               FF2CFA
D1X16               FF2CD6
DECSS               9C6
DEFDIM              9B4
DES_SK              88E
DES_SK_E            876
DIMCNT              9DB
DLINEL              85E
DOCMP               FF072E
DOREST              FF071A
DPTRL               862
DTYPEF              9B5
DUART               200000
EARRYL              842
EMEML               84A
ENDBHS              FF28CA
EXPCNT              9AD
EXPNEG              9AF
FAC1_E              994
FAC1_M              990
FAC1_S              995
FAC2_E              99C
FAC2_M              998
FAC2_S              99D
FAC_SC              99E
FEND                8
FILE_BYTE           9EB
FILE_ID             9EC
FLAG                99F
FSD                 0
FSDC                A
FSDPI               8
FSLI                6
FSTI                4
FUNC_L              9B0
GCLCTD              9DE
GETFIRST            FF0F06
GETPAIR             FF0FC2
GOPR                FF28FA
HEXSS               9CE
IBUFFE              990
IBUFFS              890
ICLIM               9E7
IMODE               9E0
IMR                 20000B
INGET               FF294E
INIT_DUART          FF0042
ISR                 20000B
ITEMP               82A
IVR                 200019
KEY_ABS             FF35B6
KEY_AND             FF35BA
KEY_ASC             FF35BD
KEY_ATN             FF35C1
KEY_BINS            FF35C6
KEY_BITCLR          FF35CB
KEY_BITSET          FF35D1
KEY_BITTST          FF35D7
KEY_BUFFER          FF35DE
KEY_CALL            FF35E5
KEY_CHRS            FF35E9
KEY_CLEAR           FF35EE
KEY_CLS             FF35F3
KEY_CONT            FF35F6
KEY_COS             FF35FA
KEY_CURSOR          FF35FE
KEY_DATA            FF3605
KEY_DEC             FF3609
KEY_DEEK            FF360C
KEY_DEF             FF3611
KEY_DIM             FF3614
KEY_DIV             FF35A8
KEY_DO              FF361B
KEY_DOKE            FF3617
KEY_ELLIPSE         FF362D
KEY_ELSE            FF361E
KEY_END             FF3622
KEY_EOR             FF3634
KEY_EQUAL           FF35AE
KEY_EXP             FF3637
KEY_FELLIPSE        FF3625
KEY_FILL            FF363C
KEY_FN              FF3643
KEY_FOR             FF3640
KEY_FRE             FF3645
KEY_FRECT           FF36F3
KEY_GET             FF364A
KEY_GOSUB           FF3651
KEY_GOTO            FF364D
KEY_GT              FF35B2
KEY_HEXS            FF3657
KEY_IF              FF365D
KEY_INC             FF365F
KEY_INPUT           FF3662
KEY_INT             FF3667
KEY_KEYS            FF366C
KEY_LCASES          FF3672
KEY_LEEK            FF3679
KEY_LEFTS           FF367E
KEY_LEN             FF3684
KEY_LET             FF3688
KEY_LINE            FF368B
KEY_LIST            FF368F
KEY_LOAD            FF3693
KEY_LOG             FF3697
KEY_LOKE            FF369B
KEY_LOOP            FF369F
KEY_LSHIFT          FF35AA
KEY_LT              FF35AC
KEY_MAX             FF36A4
KEY_MIDS            FF36A8
KEY_MIN             FF36AD
KEY_MINUS           FF35A6
KEY_MODE            FF36B1
KEY_MOVE            FF36B5
KEY_MULT            FF35A2
KEY_NEW             FF36BA
KEY_NEXT            FF36BD
KEY_NOT             FF36C1
KEY_NULL            FF36C4
KEY_ON              FF36C9
KEY_OR              FF36CB
KEY_PEEK            FF36CE
KEY_PI              FF36D3
KEY_PLUS            FF35A4
KEY_POINT           FF36D5
KEY_POKE            FF36DA
KEY_POS             FF36DE
KEY_POWER           FF3793
KEY_PRINT           FF36E2
KEY_RAM             FF36E8
KEY_READ            FF36EF
KEY_RECT            FF36F8
KEY_REM             FF36FC
KEY_RESTORE         FF36FF
KEY_RETURN          FF3706
KEY_RIGHTS          FF370C
KEY_RND             FF3713
KEY_RSHIFT          FF35B0
KEY_RUN             FF3717
KEY_SADD            FF371B
KEY_SAVE            FF3720
KEY_SGN             FF3724
KEY_SIN             FF3728
KEY_SIZE            FF372C
KEY_SPC             FF3730
KEY_SQR             FF3734
KEY_STEP            FF3738
KEY_STOP            FF373C
KEY_STRS            FF3740
KEY_SWAP            FF3745
KEY_TAB             FF374A
KEY_TAN             FF374E
KEY_THEN            FF3752
KEY_TI              FF3756
KEY_TO              FF3758
KEY_TWOPI           FF375A
KEY_UCASES          FF3760
KEY_UNTIL           FF3767
KEY_USINGS          FF376C
KEY_USR             FF3773
KEY_VAL             FF3778
KEY_VPTR            FF377C
KEY_WAIT            FF3784
KEY_WHILE           FF3788
KEY_WIDTH           FF378D
KFCTSEED            26A3D110
LAB_11A5            FF0BCE
LAB_11A6            FF0BD0
LAB_11BD            FF0BDC
LAB_1269            FF01C0
LAB_1274            FF01CE
LAB_127D            FF01D6
LAB_127E            FF01E4
LAB_1295            FF01F8
LAB_12AE            FF021A
LAB_12B0            FF021C
LAB_12E6            FF023C
LAB_12FF            FF026E
LAB_1301            FF0270
LAB_1303            FF028E
LAB_1325            FF02A6
LAB_132E            FF0296
LAB_1330            FF0298
LAB_134B            FF02B4
LAB_1357            FF02D2
LAB_1359            FF02D8
LAB_1374            FF02F8
LAB_1378            FF02FE
LAB_137F            FF030A
LAB_138E            FF0310
LAB_1392            FF0314
LAB_13A6            FF0348
LAB_13AC            FF0350
LAB_13C6            FF037A
LAB_13CC            FF0380
LAB_13D6            FF03A2
LAB_13D8            FF03A8
LAB_13EA            FF03B4
LAB_13EC            FF03B6
LAB_13FF            FF03CE
LAB_1401            FF03D2
LAB_1408            FF03DE
LAB_1410            FF03EA
LAB_1417            FF03F4
LAB_141B            FF03F6
LAB_141F            FF0406
LAB_142A            FF040C
LAB_142C            FF0418
LAB_145E            FF0432
LAB_145F            FF0424
LAB_1463            FF043A
LAB_1477            FF0446
LAB_147A            FF044C
LAB_1491            FF0470
LAB_14BD            FF04A0
LAB_14C0            FF04A4
LAB_14D4            FF04C4
LAB_14E2            FF04E0
LAB_150C            FF04EE
LAB_1519            FF04FE
LAB_152E            FF050A
LAB_1540            FF0536
LAB_15B3            FF0596
LAB_15C2            FF05C0
LAB_15D1            FF05CC
LAB_15DC            FF05A8
LAB_15F6            FF05BA
LAB_15FF            FF05DA
LAB_1602            FF05DE
LAB_1624            FF0662
LAB_1629            FF0602
LAB_1636            FF0606
LAB_1639            FF060C
LAB_163B            FF0618
LAB_1647            FF0624
LAB_164F            FF062A
LAB_16B0            FF06C2
LAB_16D0            FF06E6
LAB_1723            FF0780
LAB_1725            FF0784
LAB_172C            FF0770
LAB_172D            FF0778
LAB_174B            FF07AC
LAB_174E            FF07D0
LAB_1750            FF07D8
LAB_1752            FF07E4
LAB_1754            FF07FC
LAB_1756            FF07E8
LAB_176C            FF081A
LAB_1773            FF0824
LAB_1785            FF0840
LAB_1786            FF086C
LAB_17B7            FF0882
LAB_17B8            FF087E
LAB_17D5            FF08FC
LAB_17D6            FF0900
LAB_1810            FF0912
LAB_1811            FF0922
LAB_1813            FF0928
LAB_1829            FF0960
LAB_182C            FF0964
LAB_1831            FF096A
LAB_185E            FF09AA
LAB_1866            FF09AE
LAB_1880            FF0A70
LAB_1886            FF0A7A
LAB_188A            FF0A7E
LAB_188B            FF09BC
LAB_1898            FF09CA
LAB_18A2            FF09D4
LAB_18B7            FF09F6
LAB_18B8            FF0A02
LAB_18BD            FF0A08
LAB_18C3            FF0A12
LAB_18C6            FF0A16
LAB_18CD            FF0A20
LAB_18E3            FF0A2A
LAB_18F0            FF0A4A
LAB_18F7            FF0A58
LAB_18F9            FF0A5C
LAB_1904            FF0A82
LAB_1913            FF0A94
LAB_1934            FF0ABA
LAB_1953            FF0ACE
LAB_195B            FF0AD6
LAB_1961            FF0AE0
LAB_1984            FF0B00
LAB_1985            FF0B04
LAB_1986            FF0B08
LAB_1999            FF0B1C
LAB_19B0            FF0B2E
LAB_19B6            FF0B3E
LAB_19C2            FF0B4E
LAB_19DD            FF0B62
LAB_19F6            FF0B82
LAB_1A03            FF0B90
LAB_1A0E            FF0BA0
LAB_1A1B            FF0BA6
LAB_1A46            FF0BC0
LAB_1A90            FF0C3E
LAB_1A9B            FF0C4C
LAB_1ABA            FF0C76
LAB_1ACD            FF0CA2
LAB_1ADB            FF0CAE
LAB_1ADE            FF0CB2
LAB_1AE0            FF0CC8
LAB_1AFA            FF0CE2
LAB_1B0B            FF0CF8
LAB_1B13            FF0D00
LAB_1B1C            FF0D10
LAB_1B1D            FF0D12
LAB_1B2A            FF0D24
LAB_1B3C            FF0D40
LAB_1B43            FF0C86
LAB_1B78            FF0D4C
LAB_1B7B            FF0D50
LAB_1B7D            FF0D52
LAB_1B84            FF0D5C
LAB_1B86            FF0D60
LAB_1B9D            FF0D84
LAB_1BC1            FF0DB4
LAB_1BD0            FF0E22
LAB_1BE7            FF0E3C
LAB_1BF3            FF0DC0
LAB_1BF7            FF0DC6
LAB_1BFB            FF0DCA
LAB_1C01            FF0DD2
LAB_1C11            FF0DFA
LAB_1C13            FF0E00
LAB_1C18            FF0E08
LAB_1C19            FF0E0C
LAB_1C1A            FF0E1C
LAB_1C2A            FF0E82
LAB_1CAE            FF0F2A
LAB_1CB5            FF0F48
LAB_1CD4            FF0F52
LAB_1CD5            FF0F58
LAB_1CD6            FF0F5A
LAB_1CDB            FF0F6A
LAB_1CE6            FF0F5C
LAB_1CF2            FF0F6C
LAB_1CFE            FF0F82
LAB_1D10            FF0FFA
LAB_1D12            FF0FFE
LAB_1D2D            FF1010
LAB_1D2E            FF101C
LAB_1D44            FF1038
LAB_1D45            FF1048
LAB_1D48            FF105C
LAB_1D49            FF1064
LAB_1D4A            FF1068
LAB_1D4B            FF1078
LAB_1D5D            FF1080
LAB_1D5E            FF1086
LAB_1D83            FF0FEA
LAB_1D8A            FF0FE4
LAB_1D94            FF109A
LAB_1D96            FF3000
LAB_1D98            FF10A4
LAB_1DAC            FF10BE
LAB_1DAE            FF10C0
LAB_1DAF            FF10CC
LAB_1DB0            FF10DA
LAB_1DB1            FF10DE
LAB_1DB2            FF10E2
LAB_1DD7            FF10FA
LAB_1DE6            FF1114
LAB_1E17            FF1156
LAB_1E1F            FF115C
LAB_1E5C            FF1196
LAB_1E8D            FF11B2
LAB_1EA1            FF11CE
LAB_1EC0            FF11F6
LAB_1ED6            FF1222
LAB_1ED8            FF1230
LAB_1EDF            FF11EA
LAB_1F07            FF1242
LAB_1F28            FF125C
LAB_1F2C            FF1262
LAB_1F5A            FF1270
LAB_1F6A            FF1298
LAB_1F6B            FF12A4
LAB_1F7C            FF12AA
LAB_1FB4            FF12D8
LAB_1FD0            FF1304
LAB_201E            FF135E
LAB_2043            FF13AC
LAB_2044            FF13DE
LAB_2045            FF13E8
LAB_204S            FF13AE
LAB_204T            FF13DC
LAB_20AE            FF13FA
LAB_20B4            FF13FE
LAB_20BE            FF1404
LAB_20C9            FF1428
LAB_20CB            FF1414
LAB_20D0            FF141C
LAB_20D8            FF1432
LAB_20E0            FF143A
LAB_2115            FF145A
LAB_2117            FF1472
LAB_2128            FF148C
LAB_2137            FF1490
LAB_214B            FF14B0
LAB_2161            FF14C6
LAB_2176            FF14CE
LAB_217E            FF14DC
LAB_2183            FF14F6
LAB_218B            FF14FE
LAB_218F            FF1500
LAB_21C2            FF150C
LAB_21C4            FF1512
LAB_21D1            FF1546
LAB_2206            FF154C
LAB_2212            FF1574
LAB_2216            FF1536
LAB_2240            FF153E
LAB_224D            FF157A
LAB_224E            FF1590
LAB_229E            FF15D4
LAB_22A0            FF15E0
LAB_22B6            FF15EE
LAB_22BA            FF15F2
LAB_22BD            FF15FC
LAB_22E6            FF1616
LAB_2316            FF1656
LAB_2317            FF1658
LAB_231C            FF165C
LAB_2358            FF1690
LAB_2368            FF16B0
LAB_2441            FF18A2
LAB_2445            FF18A6
LAB_2467            FF1B18
LAB_2468            FF1B1C
LAB_249C            FF1B0A
LAB_24A8            FF1B20
LAB_24B4            FF1B4A
LAB_24D0            FF1B56
LAB_24D5            FF1B62
LAB_24D6            FF1B7C
LAB_24D7            FF1B8A
LAB_24D8            FF1B90
LAB_24D9            FF1B70
LAB_24DA            FF1B96
LAB_24F7            FF1B3A
LAB_24F8            FF1B40
LAB_2778            FF1DFE
LAB_277C            FF1E00
LAB_279B            FF1E24
LAB_27BA            FF1E32
LAB_27C3            FF1E4E
LAB_27C4            FF1E58
LAB_27CA            FF1E5E
LAB_27CE            FF1E66
LAB_27D0            FF1E6A
LAB_27DB            FF1E78
LAB_27F0            FF2136
LAB_27F1            FF214C
LAB_27F2            FF2152
LAB_27F3            FF2154
LAB_27FA            FF1E90
LAB_2828            FF1EB0
LAB_282E            FF1EB6
LAB_282F            FF1EB8
LAB_2831            FF1EBC
LAB_284G            FF1EDE
LAB_284H            FF1EF2
LAB_284J            FF1EF4
LAB_284L            FF1EE8
LAB_2887            FF2AF8
LAB_289A            FF2B22
LAB_289C            FF2B28
LAB_289D            FF2B2E
LAB_28FD            FF2B4A
LAB_28FE            FF2B50
LAB_28FF            FF2B56
LAB_2900            FF2B64
LAB_2901            FF2B6A
LAB_2902            FF2BBC
LAB_2903            FF2BC4
LAB_2904            FF2BC6
LAB_2953            FF1F14
LAB_295E            FF1F20
LAB_2967            FF1F2C
LAB_2968            FF1F34
LAB_2969            FF1F46
LAB_296A            FF1F50
LAB_2970            FF1F66
LAB_2978            FF1F76
LAB_2989            FF1F86
LAB_299C            FF1FDA
LAB_29A7            FF2002
LAB_29B7            FF201A
LAB_29B9            FF1FB2
LAB_29C0            FF2028
LAB_29C3            FF2040
LAB_29D9            FF205A
LAB_29E4            FF206C
LAB_29F7            FF2080
LAB_29FB            FF2084
LAB_29FD            FF208C
LAB_2A18            FF209C
LAB_2A1A            FF209E
LAB_2A21            FF20A6
LAB_2A3B            FF20C6
LAB_2A4B            FF20D4
LAB_2A58            FF20E8
LAB_2A68            FF2100
LAB_2A74            FF210C
LAB_2A89            FF2128
LAB_2A8C            FF212C
LAB_2A91            FF2132
LAB_2A9A            FF31C6
LAB_2A9B            FF31E2
LAB_2X01            FF2B82
LAB_2X02            FF2B8A
LAB_2X03            FF2B98
LAB_2X04            FF2B9E
LAB_2X05            FF2BB4
LAB_2Y01            FF2BD4
LAB_2Y02            FF2BDC
LAB_2Y03            FF2BE8
LAB_2Y04            FF2BEE
LAB_3216            FF1D98
LAB_32_16           FF1D96
LAB_ABER            FF0182
LAB_ABS             FF1E88
LAB_AD              FF3593
LAB_ADD             FF1AE6
LAB_ADER            FF014E
LAB_AND             FF0EFE
LAB_ASC             FF173A
LAB_ATCD            FF24D4
LAB_ATGO            FF2492
LAB_ATLE            FF24B0
LAB_ATN             FF2474
LAB_ATNP            FF24CE
LAB_AYFC            FF12E4
LAB_BAER            FF341C
LAB_BHCB            FF0EE4
LAB_BHSS            FF0EBE
LAB_BINS            FF28AC
LAB_BITCLR          FF2536
LAB_BITSET          FF2526
LAB_BMSG            FF3795
LAB_BS              FF34BC
LAB_BTST            FF2546
LAB_BUFFER          FF1AB6
LAB_CALL            FF1882
LAB_CASC            FF0FD4
LAB_CATN            FF24DA
LAB_CAUC            FF0FDA
LAB_CBIN            FF2CA8
LAB_CBX1            FF2CC2
LAB_CBXN            FF2CB0
LAB_CCER            FF0166
LAB_CDLP            FF1AA6
LAB_CHEX            FF2C46
LAB_CHRS            FF1620
LAB_CHX1            FF2C6C
LAB_CHX2            FF2C90
LAB_CHX3            FF2C88
LAB_CHXX            FF2C4E
LAB_CKRN            FF130C
LAB_CKTM            FF0C68
LAB_CLEAR           FF0488
LAB_CLS             FF1AC0
LAB_CN              FF3529
LAB_COLD            FF008C
LAB_CONT            FF0674
LAB_CORD            FF2406
LAB_COS             FF2396
LAB_CRLF            FF09B4
LAB_CRTS            FF1AB0
LAB_CTBL            FF3088
LAB_CTNM            FF0C66
LAB_CURSOR          FF1A72
LAB_D0              FF34DA
LAB_D002            FF2810
LAB_D00A            FF2820
LAB_D00E            FF2830
LAB_DATA            FF0762
LAB_DD              FF34C9
LAB_DDER            FF017E
LAB_DEC             FF0872
LAB_DECI            FF08D0
LAB_DEEK            FF1800
LAB_DEF             FF1316
LAB_DIM             FF0F86
LAB_DIV0            FF1D90
LAB_DIVIDE          FF1D16
LAB_DIVX            FF1D66
LAB_DO              FF06A6
LAB_DOKE            FF182A
LAB_DUPFMT          FF27F8
LAB_DZER            FF017A
LAB_ELLIPSE         FF19F4
LAB_EMSG            FF379D
LAB_END             FF060E
LAB_EOR             FF0EEE
LAB_EQUAL           FF0F14
LAB_ESML            FF22AC
LAB_EVBY            FF1752
LAB_EVEX            FF0C7C
LAB_EVEZ            FF0C7E
LAB_EVIN            FF1120
LAB_EVIR            FF1130
LAB_EVNM            FF0C64
LAB_EVPI            FF1128
LAB_EVSW            FF1914
LAB_EX1             FF21E4
LAB_EXAD            FF2336
LAB_EXCC            FF231C
LAB_EXCM            FF224E
LAB_EXNN            FF2308
LAB_EXOF            FF2208
LAB_EXOL            FF221E
LAB_EXOU            FF21F4
LAB_EXP             FF2228
LAB_EXPL            FF2302
LAB_EXPS            FF2260
LAB_EXRN            FF230E
LAB_EXXF            FF2C96
LAB_FB95            FF295E
LAB_FBA0            FF2942
LAB_FC              FF3483
LAB_FCER            FF0192
LAB_FELLIPSE        FF19F8
LAB_FILL            FF19B4
LAB_FO              FF359B
LAB_FOER            FF014A
LAB_FOR             FF0542
LAB_FPOINT          FF18E8
LAB_FRE             FF12CE
LAB_FRECT           FF19F0
LAB_FTBL            FF3142
LAB_FTPP            FF30F2
LAB_FVAR            FF0FF2
LAB_GADB            FF17A4
LAB_GADW            FF17B8
LAB_GARB            FF14A6
LAB_GBYT            FF0DDE
LAB_GEAD            FF17D8
LAB_GET             FF092E
LAB_GETS            FF0948
LAB_GFPN            FF0834
LAB_GGEX            FF1952
LAB_GGLP            FF1928
LAB_GGPR            FF1926
LAB_GMEM            FF00E2
LAB_GOSUB           FF06B8
LAB_GOTO            FF06CA
LAB_GOTS            FF06DA
LAB_GSCH            FF065A
LAB_GTBY            FF174E
LAB_GTHAN           FF21D6
LAB_GTSW            FF190C
LAB_GTWO            FF1762
LAB_GVAL            FF0D8A
LAB_GVAR            FF0FF4
LAB_HEXS            FF28FE
LAB_ID              FF34E9
LAB_IDER            FF0176
LAB_IF              FF078A
LAB_IGBY            FF0DDC
LAB_IMSG            FF37AE
LAB_INC             FF0878
LAB_INCI            FF08C6
LAB_INCT            FF08B8
LAB_INLN            FF02C8
LAB_INPUT           FF0AA2
LAB_INT             FF1EFA
LAB_IRTS            FF1F12
LAB_ISHN            FF2C68
LAB_ISWD            FF1922
LAB_KESS            FF18CC
LAB_KETT            FF18C0
LAB_KEYS            FF18B4
LAB_KEYT            FF324C
LAB_KEZZ            FF18BE
LAB_KKSS            FF18DA
LAB_KSSS            FF18DE
LAB_LAAD            FF1C10
LAB_LCASE           FF16B8
LAB_LD              FF354B
LAB_LDER            FF015E
LAB_LEEK            FF1816
LAB_LEFT            FF1630
LAB_LENS            FF1732
LAB_LET             FF08D4
LAB_LINE            FF1978
LAB_LIST            FF048C
LAB_LMSG            FF37A4
LAB_LNCO            FF1990
LAB_LOAD            FF187A
LAB_LOCC            FF1C16
LAB_LOCX            FF1C32
LAB_LOG             FF1B98
LAB_LOKE            FF1830
LAB_LOLP            FF1C20
LAB_LONE            FF1C4E
LAB_LONN            FF1C36
LAB_LOOP            FF06F8
LAB_LOWZ            FF1C88
LAB_LOXO            FF1C54
LAB_LOXP            FF1C44
LAB_LRMS            FF0E9C
LAB_LS              FF3506
LAB_LSHIFT          FF0F92
LAB_LTHAN           FF0F1E
LAB_LTPF            FF2416
LAB_LTPT            FF2426
LAB_LT_1            FF1DA4
LAB_MADD            FF1CB6
LAB_MAN1            FF1D8A
LAB_MAX             FF296A
LAB_MAXN            FF2976
LAB_MIDS            FF1674
LAB_MIN             FF2980
LAB_MINN            FF298C
LAB_MMEC            FF2996
LAB_MNOC            FF1CB0
LAB_MODE            FF1A52
LAB_MOVE            FF19A6
LAB_MUEX            FF1D04
LAB_MUF1            FF1CE0
LAB_MUF2            FF1CEA
LAB_MUF3            FF1D00
LAB_MULTIPLY        FF1C8A
LAB_MUUF            FF1D0A
LAB_NB1T            FF1DDC
LAB_NEW             FF0438
LAB_NEXT            FF0BAE
LAB_NF              FF344A
LAB_NFER            FF01A2
LAB_NOST            FF095A
LAB_NSTT            FF29FC
LAB_NULL            FF066A
LAB_OD              FF3477
LAB_ODER            FF0196
LAB_OFER            FF018E
LAB_OM              FF349A
LAB_OMER            FF018A
LAB_ON              FF0800
LAB_OPPT            FF3192
LAB_OR              FF0EF6
LAB_OV              FF3491
LAB_P004            FF284E
LAB_P008            FF2864
LAB_P00C            FF286C
LAB_P00E            FF2878
LAB_P010            FF287C
LAB_P018            FF2896
LAB_P01A            FF289A
LAB_P01E            FF28A2
LAB_PEEK            FF17EE
LAB_PFAC            FF1DE6
LAB_PHFA            FF29A6
LAB_PI              FF2AD8
LAB_PIXEL           FF19B6
LAB_PNCE            FF19E2
LAB_PNCO            FF19DC
LAB_POINT           FF19B0
LAB_POKE            FF17FA
LAB_POON            FF2156
LAB_POS             FF1300
LAB_POWER           FF2172
LAB_POWP            FF21A4
LAB_POZE            FF2166
LAB_PPBI            FF0E92
LAB_PPFN            FF0E84
LAB_PPFS            FF0E76
LAB_PRINT           FF0968
LAB_PRNA            FF0A2C
LAB_PROCFO          FF2836
LAB_P_10            FF2E1A
LAB_RAM             FF2ACE
LAB_READ            FF0AC8
LAB_RECT            FF19EC
LAB_REDO            FF37BE
LAB_REM             FF07F8
LAB_REMM            FF1DBC
LAB_RESS            FF064E
LAB_RESTORE         FF063C
LAB_RET0            FF2C34
LAB_RETURN          FF074E
LAB_RG              FF3462
LAB_RGER            FF019A
LAB_RIGHT           FF1644
LAB_RMSG            FF37D0
LAB_RND             FF2342
LAB_RSED            FF2D32
LAB_RSHIFT          FF0FA2
LAB_RTN0            FF2C36
LAB_RTST            FF1440
LAB_RUN             FF0692
LAB_RUNN            FF06A0
LAB_S1XY            FF1A38
LAB_S2XY            FF1A28
LAB_SADD            FF171A
LAB_SAVE            FF187E
LAB_SCCA            FF0DD4
LAB_SCER            FF016A
LAB_SCGB            FF0DCE
LAB_SCL0            FF23FC
LAB_SCLN            FF0426
LAB_SCZE            FF23EE
LAB_SELC            FF19D8
LAB_SET1            FF1D6E
LAB_SFCO            FF1966
LAB_SGBY            FF174A
LAB_SGN             FF1E76
LAB_SHAPE           FF19FA
LAB_SIN             FF23AE
LAB_SIZE            FF1A66
LAB_SIZOK           FF0098
LAB_SLCO            FF1954
LAB_SLER            FF016E
LAB_SMSG            FF37DA
LAB_SN              FF345B
LAB_SNBS            FF0768
LAB_SNER            FF019E
LAB_SNFC            FF1A16
LAB_SQE1            FF2A80
LAB_SQE2            FF2A86
LAB_SQNA            FF2AAE
LAB_SQNS            FF2A98
LAB_SQR             FF2A5C
LAB_SRTS            FF1A4E
LAB_SSLN            FF041E
LAB_ST              FF3516
LAB_STOP            FF0616
LAB_STRS            FF13F6
LAB_SUBTRACT        FF1AD2
LAB_SVAR            FF0FF0
LAB_SVTB            FF2A2E
LAB_SWAP            FF1844
LAB_TAN             FF2374
LAB_TBSZ            FF2A0E
LAB_TI              FF18B0
LAB_TM              FF34F8
LAB_TMER            FF0172
LAB_TWOPI           FF2AE8
LAB_U002            FF259E
LAB_U004            FF25F4
LAB_U005            FF2604
LAB_U006            FF2606
LAB_U008            FF261A
LAB_U009            FF263C
LAB_U00A            FF2644
LAB_U00B            FF264E
LAB_U00C            FF2662
LAB_U00D            FF2666
LAB_U00E            FF2678
LAB_U00F            FF2684
LAB_U010            FF2688
LAB_U014            FF268E
LAB_U018            FF2696
LAB_U01C            FF26AC
LAB_U020            FF26B8
LAB_U022            FF26BE
LAB_U026            FF26CE
LAB_U02A            FF26D8
LAB_U02B            FF26F0
LAB_U02C            FF26F6
LAB_U02E            FF2708
LAB_U030            FF270C
LAB_U034            FF2722
LAB_U036            FF2728
LAB_U038            FF2730
LAB_U03C            FF2738
LAB_U03E            FF273E
LAB_U040            FF2756
LAB_U044            FF2766
LAB_U046            FF278E
LAB_U048            FF2790
LAB_U04A            FF279A
LAB_U04C            FF27CC
LAB_UA              FF356E
LAB_UCASE           FF16E8
LAB_UDER            FF0156
LAB_UF              FF3538
LAB_UFAC            FF1DCA
LAB_UFER            FF0162
LAB_US              FF34A8
LAB_USER            FF0186
LAB_USINGS          FF2574
LAB_USR             FF1872
LAB_UV              FF355B
LAB_UVER            FF015A
LAB_VAL             FF1776
LAB_VALZ            FF179E
LAB_VARPTR          FF2ABE
LAB_WAIT            FF188C
LAB_WARM            800
LAB_WD              FF3582
LAB_WDER            FF0152
LAB_WDLP            FF2A42
LAB_WDTH            FF29DC
LAB_XDIV            FF1D7E
LAB_XERR            FF01A4
LAB_XGADW           FF17D2
LC_LOOP             FF16CE
LOOPALWAYS          FF0734
LOOPDONE            FF0748
LVARPL              872
L_DDIV              FF1DC4
L_DIVRND            FF1D72
MAINLOOP            FF243E
MRA                 200001
MRB                 200011
N                   2
NEXTA               FF2450
NEXTB1              FF28BC
NEXTB2              FF28E2
NEXTH1              FF290E
NEXTPRN             FF2350
NINC0               FF2358
NINC1               FF235E
NOBRK               0
NOLCASE             FF1710
NOSHIFT             FF0F9E
NOSTRING            FF1716
NOT2BIG             FF0FB6
NOUCASE             FF16E0
NOVAR               0
NULLCT              9E4
NUMEXP              9AC
OFCHR               23
OQUOTE              9DD
OUTLOOP             FF245E
PRG_STRT            9F2
PRNLWORD            9A0
PRSTK               9D8
RAM_ADDR            1000
RAM_BASE            800
RAM_SIZE            80000
RAM_STRT            400
RBA                 200007
RBB                 200017
RDPTRL              866
RETCHR              FF0028
RTS_001             FF0DF8
RTS_005             FF0486
RTS_006             FF0668
RTS_007             FF0766
RTS_007A            FF077C
RTS_008             FF092C
RTS_009             FF0A28
RTS_011             FF12A8
RTS_012             FF1578
RTS_013             FF15EC
RTS_015             FF1842
RTS_016             FF1B3E
RTS_017             FF1E5C
RTS_020             FF21E2
RTS_021             FF2524
RTS_022             FF294C
RTS_023             FF2A5A
RTS_024             FF2CA6
RTS_025             FF2D08
SARRYL              83E
SFNCL               832
SMEML               82E
SRA                 200003
SRB                 200013
SSTORL              846
SSTRL               83A
SUBEXIT             FF2468
SUBLOOP             FF2436
SUFNXF              9DF
SUTILL              84E
SVARL               836
TABSIZ              9E2
TAB_ASCA            FF35B6
TAB_ASCB            FF35C6
TAB_ASCC            FF35E5
TAB_ASCD            FF3605
TAB_ASCE            FF361E
TAB_ASCF            FF363C
TAB_ASCG            FF364A
TAB_ASCH            FF3657
TAB_ASCI            FF365D
TAB_ASCK            FF366C
TAB_ASCL            FF3672
TAB_ASCM            FF36A4
TAB_ASCN            FF36BA
TAB_ASCO            FF36C9
TAB_ASCP            FF36CE
TAB_ASCR            FF36E8
TAB_ASCS            FF371B
TAB_ASCT            FF374A
TAB_ASCU            FF3760
TAB_ASCV            FF3778
TAB_ASCW            FF3784
TAB_ATNC            FF2F88
TAB_CHRT            FF31E2
TAB_EQUL            FF35AE
TAB_HTHET           FF3008
TAB_LESS            FF35AA
TAB_MNUS            FF35A6
TAB_MORE            FF35B0
TAB_PLUS            FF35A4
TAB_POWR            FF3793
TAB_QEST            FF35B4
TAB_SLAS            FF35A8
TAB_SNCO            FF2F08
TAB_STAR            FF35A2
TBA                 200007
TBB                 200017
TK_ABS              CE
TK_AND              C4
TK_ASC              E0
TK_ATN              D9
TK_BINS             E5
TK_BITCLR           B4
TK_BITSET           B3
TK_BITTST           E6
TK_BUFFER           A0
TK_CALL             9B
TK_CHRS             E3
TK_CLEAR            AE
TK_CLS              A1
TK_CONT             9F
TK_COS              D6
TK_CURSOR           A2
TK_DATA             83
TK_DEC              88
TK_DEEK             DB
TK_DEF              97
TK_DIM              85
TK_DIV              C2
TK_DO               9C
TK_DOKE             99
TK_ELLIPSE          A9
TK_ELSE             B6
TK_END              80
TK_EOR              C5
TK_EQUAL            CA
TK_EXP              D5
TK_FELLIPSE         AA
TK_FILL             A4
TK_FN               B8
TK_FOR              81
TK_FRE              D0
TK_FRECT            A8
TK_GET              B1
TK_GOSUB            8D
TK_GOTO             89
TK_GT               C9
TK_HEXS             E4
TK_IF               8B
TK_INC              93
TK_INPUT            84
TK_INT              CD
TK_KEYS             EA
TK_LCASES           E2
TK_LEEK             DC
TK_LEFTS            F0
TK_LEN              DD
TK_LET              87
TK_LINE             A3
TK_LIST             AD
TK_LOAD             95
TK_LOG              D4
TK_LOKE             9A
TK_LOOP             9D
TK_LSHIFT           C8
TK_LT               CB
TK_MAX              E7
TK_MIDS             F2
TK_MIN              E8
TK_MINUS            C0
TK_MODE             AB
TK_MOVE             A5
TK_MULT             C1
TK_NEW              AF
TK_NEXT             82
TK_NOT              BB
TK_NULL             92
TK_ON               91
TK_OR               C6
TK_PEEK             DA
TK_PI               EC
TK_PLUS             BF
TK_POINT            A6
TK_POKE             98
TK_POS              D1
TK_POWER            C3
TK_PRINT            9E
TK_RAM              E9
TK_READ             86
TK_RECT             A7
TK_REM              8F
TK_RESTORE          8C
TK_RETURN           8E
TK_RIGHTS           F1
TK_RND              D3
TK_RSHIFT           C7
TK_RUN              8A
TK_SADD             EF
TK_SAVE             96
TK_SGN              CC
TK_SIN              D7
TK_SIZE             AC
TK_SPC              B9
TK_SQR              D2
TK_STEP             BC
TK_STOP             90
TK_STRS             DE
TK_SWAP             B2
TK_TAB              B5
TK_TAN              D8
TK_THEN             BA
TK_TI               EB
TK_TO               B7
TK_TWOPI            ED
TK_UCASES           E1
TK_UNTIL            BD
TK_USINGS           F3
TK_USR              CF
TK_VAL              DF
TK_VPTR             EE
TK_WAIT             94
TK_WHILE            BE
TK_WIDTH            B0
TOOBIG              FF0FBC
TPOS                9E5
TPOWER              9D9
TWIDTH              9E6
UC_LOOP             FF16FE
USDSS               9CC
USRJMP              806
USRJPV              808
UT1_PL              9A4
VARNAME             86A
VEC_CC              FF2928
VEC_IN              FF001A
VEC_LD              FF0036
VEC_OUT             FF0008
VEC_SV              FF003C
V_CTLC              824
V_CTLCV             826
V_INPT              80C
V_INPTV             80E
V_LOAD              818
V_LOADV             81A
V_OUTP              812
V_OUTPV             814
V_SAVE              81E
V_SAVEV             820
WEXIT               FF2A32
WRMJPV              802
