00FF0140 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 2/17/2022 4:29:02 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      : 68k Homebrew ROM Monitor
00000000                             3  * Written by : Hayden Kroepfl (ChartreuseK)
00000000                             4  * Date       : August 24th 2015
00000000                             5  * Description: A simple ROM monitor for my homebrew 68k
00000000                             6  *              breadboard computer.
00000000                             7  *-----------------------------------------------------------
00000000                             8  *
00000000                             9  * To make this responsive to different terminal widths we need to change the number of bytes printed
00000000                            10  * on a line from 16, which fits exactly on a 72 column screen, to an ammount based on a formula.
00000000                            11  *  Sizes: 
00000000                            12  *   Address:      "000000: " 8
00000000                            13  *   Each Byte:    "00 "      3
00000000                            14  *   Start ASCII:  "|"        1
00000000                            15  *   Each ASCII:   "."        1
00000000                            16  *   End ASCII:    "|"        1
00000000                            17  *
00000000                            18  *   Width = 8 + numBytes*(3 + 1) + 2
00000000                            19  *   numBytes = (Width - 10)/4 = (Width - 10)>>2
00000000                            20  *  Examples:
00000000                            21  *    (80 - 10)/4 = 70/4 = 16 Bytes
00000000                            22  *    (40 - 10)/4 = 30/4 =  7 Bytes
00000000                            23  *    (32 - 10)/4 = 22/4 =  5 Bytes
00000000                            24  * On small screens we should not show the start and end characters on the ASCII section
00000000                            25  * 40 Characters wide or less
00000000                            26  *    (40 - 8)/4  = 32/4 =  8 Bytes
00000000                            27  *    (32 - 8)/4  = 24/4 =  6 Bytes
00000000                            28  
00000000                            29  
00000000                            30  * 000000-03FFFF ROM  (138 output 0)
00000000                            31  * 040000-043FFF RAM  (138 output 1)
00000000                            32  * 044000-07FFFF RAM mirrors (138 output 1)
00000000                            33  * 080000-0BFFFF      (138 output 2)
00000000                            34  * 0C0000-0FFFFF      (138 output 3)
00000000                            35  * 100000-13FFFF      (138 output 4)
00000000                            36  * 140000-17FFFF      (138 output 5)
00000000                            37  * 180000-180003 YM2149 ((138 output 6)
00000000                            38  * 180004-1BFFFF      (138 output 6)
00000000                            39  * 1C0000-1C000F DUART (138 output 7)
00000000                            40  * 1C0010-1FFFFF DUART mirrors (138 output 7)
00000000                            41  
00000000                            42  
00000000                            43  **********************************
00000000                            44  * Defines
00000000                            45  *
00000000  =00000000                 46  RAM_START           equ     $000000
00000000  =00100000                 47  RAM_END             equ     $100000
00000000  =00000050                 48  MAX_LINE_LENGTH     equ     80
00000000  =00000080                 49  SERIAL_RING_LENGTH  equ     128
00000000                            50  
00000000  =00000050                 51  TERM_WIDTH          equ     80
00000000  =00000018                 52  TERM_HEIGHT         equ     24
00000000                            53  
00000000  =00000006                 54  DUMP_BYTES_LINE     equ     6           * 8 For 72 width+
00000000  =00000010                 55  DUMP_BYTES_QUICK    equ     16          * Still a handy width even if it wraps on small screens
00000000  =0000008A                 56  DUMP_BYTES_PAGE     equ     138         * 256 For 72 width+
00000000                            57   
00000000                            58  **********************************
00000000                            59  * Colours
00000000  =00000000                 60  COLOR_BLACK    equ 0
00000000  =00000008                 61  COLOR_DGREY    equ 8
00000000  =00000001                 62  COLOR_DRED     equ 1
00000000  =00000009                 63  COLOR_RED      equ 9
00000000  =00000002                 64  COLOR_DGREEN   equ 2
00000000  =0000000A                 65  COLOR_GREEN    equ 10
00000000  =00000003                 66  COLOR_DYELLOW  equ 3
00000000  =00000003                 67  COLOR_ORANGE   equ 3
00000000  =0000000B                 68  COLOR_YELLOW   equ 11
00000000  =00000004                 69  COLOR_DBLUE    equ 4
00000000  =0000000C                 70  COLOR_BLUE     equ 12
00000000  =00000005                 71  COLOR_DMAGENTA equ 5
00000000  =00000005                 72  COLOR_PURPLE   equ 5
00000000  =0000000D                 73  COLOR_MAGENTA  equ 13
00000000  =00000006                 74  COLOR_DCYAN    equ 6
00000000  =0000000E                 75  COLOR_CYAN     equ 14
00000000  =00000007                 76  COLOR_LGREY    equ 7
00000000  =0000000F                 77  COLOR_WHITE    equ 15
00000000                            78  
00000000                            79  
00000000  =0000000A                 80  COLOR_BANNER  equ COLOR_GREEN
00000000  =0000000C                 81  COLOR_HELP    equ COLOR_BLUE
00000000  =0000000D                 82  COLOR_PROMPT  equ COLOR_MAGENTA
00000000  =0000000F                 83  COLOR_INPUT   equ COLOR_WHITE
00000000  =0000000F                 84  COLOR_DEFAULT equ COLOR_WHITE
00000000  =0000000D                 85  COLOR_ADDR    equ COLOR_MAGENTA
00000000  =0000000E                 86  COLOR_BYTES   equ COLOR_CYAN
00000000  =0000000F                 87  COLOR_ASCII   equ COLOR_WHITE
00000000  =00000001                 88  COLOR_ERROR   equ COLOR_DRED
00000000                            89   
00000000                            90   
00000000                            91  *********************************
00000000                            92  * 68681 Duart Register Addresses
00000000                            93  *
00000000  =00200000                 94  DUART equ $200000       * Base Addr of DUART
00000000  =00200001                 95  MRA   equ DUART+1       * Mode Register A           (R/W)
00000000  =00200003                 96  SRA   equ DUART+3       * Status Register A         (r)
00000000  =00200003                 97  CSRA  equ DUART+3       * Clock Select Register A   (w)
00000000  =00200005                 98  CRA   equ DUART+5       * Commands Register A       (w)
00000000  =00200007                 99  RBA   equ DUART+7       * Receiver Buffer A         (r)
00000000  =00200007                100  TBA   equ DUART+7       * Transmitter Buffer A      (w)
00000000  =00200009                101  ACR   equ DUART+9       * Aux. Control Register     (R/W)
00000000  =0020000B                102  ISR   equ DUART+11      * Interrupt Status Register (R)
00000000  =0020000B                103  IMR   equ DUART+11      * Interrupt Mask Register   (W)
00000000  =0020000D                104  CUR   equ DUART+13      * Counter MSB               (R)
00000000  =0020000D                105  CTUR  equ DUART+13      * Counter/Timer Upper Reg   (W)
00000000  =0020000F                106  CLR   equ DUART+15      * Counter LSB               (R)
00000000  =0020000F                107  CTLR  equ DUART+15      * Counter/Timer Lower Reg   (W)
00000000  =00200011                108  MRB   equ DUART+17      * Mode Register B           (R/W)
00000000  =00200013                109  SRB   equ DUART+19      * Status Register B         (R)
00000000  =00200013                110  CSRB  equ DUART+19      * Clock Select Register B   (W)
00000000  =00200015                111  CRB   equ DUART+21      * Commands Register B       (W)
00000000  =00200017                112  RBB   equ DUART+23      * Reciever Buffer B         (R)
00000000  =00200017                113  TBB   equ DUART+23      * Transmitter Buffer B      (W)
00000000  =00200019                114  IVR   equ DUART+25      * Interrupt Vector Register (R/W)
00000000  =0020001B                115  IPUL  equ DUART+27      * Unlatched Input Port values (R)
00000000  =0020001B                116  OPCR  equ DUART+27      * Output Port Configuration Register (W)
00000000  =0020001D                117  STRT_CNTR equ DUART+29  * Start-Counter Command (R)
00000000  =0020001D                118  OPR_SET   equ DUART+29  * Output Port Bit Set Command (W)
00000000  =0020001F                119  STOP_CNTR equ DUART+31  * Stop-Counter Command (R) / Clear timer interrupt
00000000  =0020001D                120  OPR_CLR   equ DUART+29  * Output Port Bit Clear Command (W)
00000000                           121  
00000000                           122  **********************************
00000000                           123  * ASCII Control Characters
00000000                           124  *
00000000  =00000007                125  BEL   equ $07
00000000  =00000008                126  BKSP  equ $08       * CTRL-H
00000000  =00000009                127  TAB   equ $09
00000000  =0000000A                128  LF    equ $0A
00000000  =0000000D                129  CR    equ $0D
00000000  =0000001B                130  ESC   equ $1B
00000000                           131  
00000000  =00000003                132  CTRLC   EQU $03     
00000000  =00000018                133  CTRLX   EQU $18     * Line Clear
00000000                           134  
00000000                           135  
00000000                           136  **********************************
00000000                           137  * Variables
00000000                           138  *
00000000  =000FFFFC                139  varCurAddr     equ   RAM_END-4                       * Last address accessed
00000000  =000FFFA8                140  varLineBuf     equ   varCurAddr-MAX_LINE_LENGTH-4    * Line buffer
00000000  =000FFF28                141  varSerialRing  equ   varLineBuf-SERIAL_RING_LENGTH
00000000  =000FFF27                142  varSRingStart  equ   varSerialRing-1
00000000  =000FFF26                143  varSRingEnd    equ   varSRingStart-1
00000000  =000FFF25                144  varSysCntr5    equ   varSRingEnd-1                   * System Timer 50hz divider/counter 0-4
00000000  =000FFF24                145  varSysCntr6    equ   varSysCntr5-1                   * System Timer 60hz divider/counter 0-5 (Could probably pack these two into one byte)
00000000                           146  * Make sure the above is aligned to a multiple of 4, as the next two MUST be on a word boundary (Maybe move these to the first declarations)
00000000  =000FFF20                147  varHndlr50hz   equ   varSysCntr6-4                   * Pointer to 50hz handler
00000000  =000FFF1C                148  varHndlr60hz   equ   varHndlr50hz-4                  * Pointer to 60hz handler
00000000  =000FFF18                149  varHndlrSIGINT equ   varHndlr60hz-4                  * Pointer to CTRLC / SIGINT handler (Not yet implemented)
00000000                           150  
00000000  =000FFF14                151  varMYMIndex    equ   varHndlrSIGINT-4                     * Index into the file/memory
00000000  =000FFF10                152  varMYMEndPos   equ   varMYMIndex-4                   * End Position, when Index=This we're done
00000000  =000FFF0F                153  varMYMFramePos equ   varMYMEndPos-1                  * Current column into frame (0-127)
00000000  =000FFF0E                154  varMYMCurByte  equ   varMYMFramePos-1                * Current byte value being examined in data
00000000  =000FFF0D                155  varMYMBitPos   equ   varMYMCurByte-1                 * Current bit in the above byte being examined
00000000  =000FFF0C                156  varMYMFillBuf  equ   varMYMBitPos-1                  * Semaphore to fill buffer
00000000  =000FFEFC                157  varMYMCurRegs  equ   varMYMFillBuf-16                * Previous value for the registers
00000000  =000FF6FC                158  varMYMBuf      equ   varMYMCurRegs-2048              * 2k buffer for decompressed mym data 
00000000  =000FF6FC                159  varLast        equ   varMYMBuf 
00000000  =000FF6FC                160  varLast        equ   varMYMBuf
00000000                           161  
00000000                           162  
00000000                           163  **********************************
00000000                           164  * Supervisor Stack Begins after system variables
00000000  =000FF6FC                165  STACK_START         equ    varLast                   * Make sure stack is aligned to word boundary
00000000                           166  
00000000                           167  
00000000                           168  
00000000                           169  **** PROGRAM STARTS HERE ****
00000000                           170      
00FF0000                           171      ORG     $0FF0000    
00FF0000                           172  **** FIRST 8 bytes loaded after reset/Execption Vector Table ****
00FF0000= 000FF6FC                 173      DC.l    STACK_START  * 0 - Supervisor stack pointer
00FF0004= 00FF0140                 174      DC.l    START        *     Initial PC    
00FF0008= 00FF066A                 175      DC.l    RESETVECT    * 2 - Bus Error
00FF000C= 00FF066A                 176      DC.l    RESETVECT    * 3 - Address Error
00FF0010= 00FF066A                 177      DC.l    RESETVECT    * 4 - ILLEGAL Instruction
00FF0014= 00FF066A                 178      DC.l    RESETVECT    * 5 - Divide by Zero
00FF0018= 00FF066A                 179      DC.l    RESETVECT    * 6 - CHK
00FF001C= 00FF0668                 180      DC.l    UNHANDLED    * 7 - TRAPV
00FF0020= 00FF0668                 181      DC.l    UNHANDLED    * 8 - Privilage Violation
00FF0024= 00FF0668                 182      DC.l    UNHANDLED    * 9 - Trace
00FF0028= 00FF0668                 183      DC.l    UNHANDLED    * 10- Line 1010/Unused
00FF002C= 00FF0668                 184      DC.l    UNHANDLED    * 11- Line 1111/Unused
00FF0030= 00FF0668                 185      DC.l    UNHANDLED    * 12- Unused
00FF0034= 00FF0668                 186      DC.l    UNHANDLED    * 13- Unused
00FF0038= 00FF0668                 187      DC.l    UNHANDLED    * 14- Unused
00FF003C= 00FF066E                 188      DC.l    AUTOVECT1    * 15- DUART (?)
00FF0040= 00FF0668                 189      DC.l    UNHANDLED    * 16- Uninitialized Interrupt Vector
00FF0044= 00FF0668                 190      DC.l    UNHANDLED    * 17- Unused
00FF0048= 00FF0668                 191      DC.l    UNHANDLED    * 18- Unused
00FF004C= 00FF0668                 192      DC.l    UNHANDLED    * 19- Unused
00FF0050= 00FF0668                 193      DC.l    UNHANDLED    * 20- Unused
00FF0054= 00FF0668                 194      DC.l    UNHANDLED    * 21- Unused
00FF0058= 00FF0668                 195      DC.l    UNHANDLED    * 22- Unused
00FF005C= 00FF0668                 196      DC.l    UNHANDLED    * 23- Unused
00FF0060= 00FF0668                 197      DC.l    UNHANDLED    * 24- Spurious Interrupt
00FF0064= 00FF066E                 198      DC.l    AUTOVECT1    * 25- Autovector 1
00FF0068= 00FF0668                 199      DC.l    UNHANDLED    * 26- Autovector 2
00FF006C= 00FF0668                 200      DC.l    UNHANDLED    * 27- Autovector 3
00FF0070= 00FF0668                 201      DC.l    UNHANDLED    * 28- Autovector 4
00FF0074= 00FF0668                 202      DC.l    UNHANDLED    * 29- Autovector 5
00FF0078= 00FF0668                 203      DC.l    UNHANDLED    * 30- Autovector 6
00FF007C= 00FF0668                 204      DC.l    UNHANDLED    * 31- Autovector 7
00FF0080= 00FF0668                 205      DC.l    UNHANDLED    * 32- TRAP #0
00FF0084= 00FF0668                 206      DC.l    UNHANDLED    * 33- TRAP #1
00FF0088= 00FF0668                 207      DC.l    UNHANDLED    * 34- TRAP #2
00FF008C= 00FF0668                 208      DC.l    UNHANDLED    * 35- TRAP #3
00FF0090= 00FF0668                 209      DC.l    UNHANDLED    * 36- TRAP #4
00FF0094= 00FF0668                 210      DC.l    UNHANDLED    * 37- TRAP #5
00FF0098= 00FF0668                 211      DC.l    UNHANDLED    * 38- TRAP #6
00FF009C= 00FF0668                 212      DC.l    UNHANDLED    * 39- TRAP #7
00FF00A0= 00FF0668                 213      DC.l    UNHANDLED    * 40- TRAP #8
00FF00A4= 00FF0668                 214      DC.l    UNHANDLED    * 41- TRAP #9
00FF00A8= 00FF0668                 215      DC.l    UNHANDLED    * 42- TRAP #10
00FF00AC= 00FF0668                 216      DC.l    UNHANDLED    * 43- TRAP #11
00FF00B0= 00FF0668                 217      DC.l    UNHANDLED    * 44- TRAP #12
00FF00B4= 00FF0668                 218      DC.l    UNHANDLED    * 45- TRAP #13
00FF00B8= 00FF0668                 219      DC.l    UNHANDLED    * 46- TRAP #14
00FF00BC= 00FF0668                 220      DC.l    UNHANDLED    * 47- TRAP #15
00FF00C0                           221  
00FF00C0= 00FF0668                 222      DC.l    UNHANDLED    * 48- Unassigned
00FF00C4= 00FF0668                 223      DC.l    UNHANDLED    * 49- Unassigned
00FF00C8= 00FF0668                 224      DC.l    UNHANDLED    * 50- Unassigned
00FF00CC= 00FF0668                 225      DC.l    UNHANDLED    * 51- Unassigned
00FF00D0= 00FF0668                 226      DC.l    UNHANDLED    * 52- Unassigned
00FF00D4= 00FF0668                 227      DC.l    UNHANDLED    * 53- Unassigned
00FF00D8= 00FF0668                 228      DC.l    UNHANDLED    * 54- Unassigned
00FF00DC= 00FF0668                 229      DC.l    UNHANDLED    * 55- Unassigned
00FF00E0= 00FF0668                 230      DC.l    UNHANDLED    * 56- Unassigned
00FF00E4= 00FF0668                 231      DC.l    UNHANDLED    * 57- Unassigned
00FF00E8= 00FF0668                 232      DC.l    UNHANDLED    * 58- Unassigned
00FF00EC= 00FF0668                 233      DC.l    UNHANDLED    * 59- Unassigned
00FF00F0= 00FF0668                 234      DC.l    UNHANDLED    * 60- Unassigned
00FF00F4= 00FF0668                 235      DC.l    UNHANDLED    * 61- Unassigned
00FF00F8= 00FF0668                 236      DC.l    UNHANDLED    * 62- Unassigned
00FF00FC= 00FF0668                 237      DC.l    UNHANDLED    * 63- Unassigned
00FF0100                           238  
00FF0100                           239      * 64-255 User
00FF0100= 00FF0668                 240      DC.l    UNHANDLED    * 64- User #0
00FF0104= 00FF066E                 241      DC.l    AUTOVECT1    * 64- User #1
00FF0108= 00FF0668                 242      DC.l    UNHANDLED    * 64- User #2
00FF010C= 00FF0668                 243      DC.l    UNHANDLED    * 64- User #3
00FF0110= 00FF0668                 244      DC.l    UNHANDLED    * 64- User #4
00FF0114= 00FF0668                 245      DC.l    UNHANDLED    * 64- User #5
00FF0118= 00FF0668                 246      DC.l    UNHANDLED    * 64- User #6
00FF011C= 00FF0668                 247      DC.l    UNHANDLED    * 64- User #7
00FF0120= 00FF0668                 248      DC.l    UNHANDLED    * 64- User #8
00FF0124= 00FF0668                 249      DC.l    UNHANDLED    * 64- User #9
00FF0128= 00FF0668                 250      DC.l    UNHANDLED    * 64- User #10
00FF012C= 00FF0668                 251      DC.l    UNHANDLED    * 64- User #11
00FF0130= 00FF0668                 252      DC.l    UNHANDLED    * 64- User #12
00FF0134= 00FF0668                 253      DC.l    UNHANDLED    * 64- User #13
00FF0138= 00FF0668                 254      DC.l    UNHANDLED    * 64- User #14
00FF013C= 00FF066E                 255      DC.l    AUTOVECT1    * 64- User #15
00FF0140                           256  
00FF0140                           257    
00FF0140                           258  ********************************************
00FF0140                           259  * Cold start entry point
00FF0140                           260  *
00FF0140                           261  START:
00FF0140  4FF9 000FF6FC            262      lea     STACK_START, SP     * Set our stack pointer to be sure
00FF0146  4EB9 00FF061E            263      jsr     initDuart           * Setup the serial port
00FF014C  4EB9 00FF0530            264      jsr     clearScreen         * Clear the terminal
00FF0152                           265      
00FF0152                           266  ********************************************
00FF0152                           267  * Simple Ram Readback Test
00FF0152                           268  *    
00FF0152                           269  ramCheck:
00FF0152  41F9 00FF0794            270      lea     msgRamCheck, A0
00FF0158  6100 0408                271      bsr.w   printString
00FF015C                           272  *    lea     RAM_START, A2
00FF015C                           273  * .loop:
00FF015C                           274  *    move.b  #$AA, (A2)   * First test with 10101010
00FF015C                           275  *    cmp.b   #$AA, (A2)
00FF015C                           276  *    bne.s   .fail
00FF015C                           277  *    move.b  #$55, (A2)   * Then with 01010101
00FF015C                           278  *    cmp.b   #$55, (A2)
00FF015C                           279  *    bne.s   .fail
00FF015C                           280  *    move.b  #$00, (A2)   * And finally clear the memory
00FF015C                           281  *    cmp.b   #$00, (A2)+  * And move to the next byte
00FF015C                           282  *    bne.s   .fail 
00FF015C                           283  *    cmp.l   #RAM_END, A2  
00FF015C                           284  *    blt.s   .loop        * While we're still below the end of ram to check
00FF015C                           285  *    bra.s   .succ
00FF015C                           286  * .fail:                  * One of the bytes of RAM failed to readback test
00FF015C                           287  *    lea     msgRamFail, A0
00FF015C                           288  *    bsr.w   printString
00FF015C                           289  *    move.l  A2, D0
00FF015C                           290  *    bsr.w   printHexLong * Print out the address that failed
00FF015C                           291  *    bsr.w   printNewline
00FF015C                           292  * .haltloop:              * Sit forever in the halt loop
00FF015C                           293  *    bra.s   .haltloop
00FF015C                           294  * .succ:                  * All bytes passed the readback test
00FF015C                           295  *    lea     msgRamPass, A0
00FF015C                           296  *    bsr.w   printString
00FF015C                           297  *
00FF015C                           298  *
00FF015C                           299  *    lea     varSRingStart, a0   * Ring buffer ends   
00FF015C                           300  *    move.b  #0, (a0)
00FF015C                           301  *    lea     varSRingEnd,   a0
00FF015C                           302  *    move.b  #0, (a0)
00FF015C                           303      * Enable Interrupts
00FF015C  46FC 2000                304      move.w #$2000, SR       * Supervisor mode, no trace, interrupt mask 000
00FF0160                           305  
00FF0160                           306  
00FF0160                           307  **************************************************
00FF0160                           308  * Warm Restart entry point
00FF0160                           309  *
00FF0160                           310  monitorStart:
00FF0160  700A                     311      move.l  #COLOR_BANNER, d0          * Dark Green
00FF0162  6100 037C                312      bsr.w   setColor
00FF0166                           313  
00FF0166  41F9 00FF06D0            314      lea     msgBanner, A0   * Show our banner
00FF016C  6100 03F4                315      bsr.w   printString
00FF0170                           316      
00FF0170  700C                     317      move.l  #COLOR_HELP, d0         * Bright Blue
00FF0172  6100 036C                318      bsr.w   setColor
00FF0176  41F9 00FF0714            319      lea     msgHelp,   A0   * And the command help message
00FF017C  6100 03E4                320      bsr.w   printString
00FF0180                           321  
00FF0180                           322  monitorLine:                * Our main monitor loop
00FF0180  700D                     323      move.l  #COLOR_PROMPT, d0         * Bright Magenta
00FF0182  6100 035C                324      bsr.w   setColor
00FF0186  41F9 00FF075D            325      lea     msgPrompt, a0   * Prompt
00FF018C  6100 03D4                326      bsr.w   printString     
00FF0190                           327      
00FF0190  700F                     328      move.l  #COLOR_INPUT, d0
00FF0192  6100 034C                329      bsr.w   setColor
00FF0196                           330      
00FF0196  6100 02BE                331      bsr.w   readLine        * Read in the line
00FF019A  6100 000E                332      bsr.w   lineToUpper     * Convert to upper-case for ease of parsing
00FF019E                           333      
00FF019E  700F                     334      move.l  #COLOR_DEFAULT, d0         * Bright White
00FF01A0  6100 033E                335      bsr.w   setColor
00FF01A4  6100 0022                336      bsr.w   parseLine       * Then parse and respond to the line
00FF01A8                           337      
00FF01A8  60D6                     338      bra.s   monitorLine
00FF01AA                           339      
00FF01AA                           340  
00FF01AA                           341  
00FF01AA                           342  ***************************************
00FF01AA                           343  * Converts input line to uppercase
00FF01AA                           344  lineToUpper:
00FF01AA  41F9 000FFFA8            345      lea     varLineBuf, a0   * Get the start of the line buffer
00FF01B0                           346   .loop:
00FF01B0  1010                     347      move.b  (a0), d0         * Read in a character
00FF01B2  B03C 0061                348      cmp.b   #'a', d0         
00FF01B6  6D0A                     349      blt.s   .next            * Is it less than lower-case 'a', then move on
00FF01B8  B03C 007A                350      cmp.b   #'z', d0
00FF01BC  6E04                     351      bgt.s   .next            * Is it greater than lower-case 'z', then move on
00FF01BE  0400 0020                352      sub.b   #$20, d0         * Then convert a to A, b to B, etc.
00FF01C2                           353   .next:
00FF01C2  10C0                     354      move.b  d0, (a0)+        * Store the character back into a0, and move to the next
00FF01C4  66EA                     355      bne.s   .loop            * Keep going till we hit a null terminator
00FF01C6  4E75                     356      rts
00FF01C8                           357  
00FF01C8                           358  ***************************************
00FF01C8                           359  * Parse Line
00FF01C8                           360  parseLine:
00FF01C8  48E7 0030                361      movem.l a2-a3, -(SP)        * Save registers
00FF01CC  41F9 000FFFA8            362      lea     varLineBuf, a0
00FF01D2                           363   .findCommand:
00FF01D2  1018                     364      move.b  (a0)+, d0
00FF01D4  B03C 0020                365      cmp.b   #' ', d0            * Ignore spaces
00FF01D8  6700 FFF8                366      beq.w   .findCommand    
00FF01DC  B03C 0045                367      cmp.b   #'E', d0            * Examine command
00FF01E0  6700 0036                368      beq.w   .examine
00FF01E4  B03C 0044                369      cmp.b   #'D', d0            * Deposit command
00FF01E8  6700 00B6                370      beq.w   .deposit
00FF01EC  B03C 0052                371      cmp.b   #'R', d0            * Run command
00FF01F0  6700 011A                372      beq.w   .run
00FF01F4  B03C 0048                373      cmp.b   #'H', d0            * Help command
00FF01F8  6700 0124                374      beq.w   .help
00FF01FC  B03C 0000                375      cmp.b   #0, d0              * Ignore blank lines
00FF0200  6710                     376      beq.s   .exit               
00FF0202                           377   .invalid:   
00FF0202  7001                     378      move.l  #COLOR_ERROR, d0    
00FF0204  6100 02DA                379      bsr.w   setColor
00FF0208                           380      
00FF0208  41F9 00FF0760            381      lea     msgInvalidCommand, a0
00FF020E  6100 0352                382      bsr.w   printString
00FF0212                           383   .exit:
00FF0212  4CDF 0C00                384      movem.l (SP)+, a2-a3        * Restore registers
00FF0216  4E75                     385      rts
00FF0218                           386  
00FF0218                           387  **********************
00FF0218                           388  * Examines memory addresses
00FF0218                           389  * Valid modes:
00FF0218                           390  *   e ADDR                  Displays a single byte
00FF0218                           391  *   e ADDR-ADDR             Dispalys all bytes between the two addresses
00FF0218                           392  *   e ADDR+LEN              Dispays LEN bytes after ADDR
00FF0218                           393  *   e ADDR;                 Interactive mode, space shows a page, enter shows quick amount.
00FF0218                           394  *   e ADDR.                 Quick line, displays one line 
00FF0218                           395   .examine:
00FF0218  6100 012E                396      bsr.w   parseNumber         * Read in the start address
00FF021C  4A01                     397      tst.b   d1                  * Make sure it's valid (parseNumber returns non-zero in d1 for failure)
00FF021E  6600 010C                398      bne.w   .invalidAddr        
00FF0222  2640                     399      move.l  d0, a3              * Save the start address
00FF0224                           400   .exloop:
00FF0224  1018                     401      move.b  (a0)+, d0
00FF0226  B03C 0020                402      cmp.b   #' ', d0            * Ignore spaces
00FF022A  67F8                     403      beq.s   .exloop
00FF022C  B03C 002D                404      cmp.b   #'-', d0            * Check if it's a range specifier
00FF0230  6716                     405      beq.s   .exrange
00FF0232  B03C 002B                406      cmp.b   #'+', d0            * Check if it's a length specifier
00FF0236  6722                     407      beq.s   .exlength
00FF0238  B03C 003B                408      cmp.b   #';', d0            * Check if we're going interactive
00FF023C  672E                     409      beq.s   .exinter
00FF023E  B03C 002E                410      cmp.b   #'.', d0            * Check if quick 16 
00FF0242  6712                     411      beq.s   .exquick
00FF0244  7001                     412      move.l  #1, d0              * Otherwise read in a single byte
00FF0246  601C                     413      bra.s   .exend              
00FF0248                           414   .exrange:
00FF0248  6100 00FE                415      bsr.w   parseNumber         * Find the end address
00FF024C  4A01                     416      tst.b   d1                  * Check if we found a valid address
00FF024E  6600 00DC                417      bne.w   .invalidAddr
00FF0252  908B                     418      sub.l   a3, d0              * Get the length
00FF0254  600E                     419      bra.s   .exend
00FF0256                           420   .exquick:                      * Quick mode means show quick amount bytes
00FF0256  7010                     421      move.l  #DUMP_BYTES_QUICK, d0
00FF0258  600A                     422      bra.s   .exend
00FF025A                           423   .exlength:                     * Length mode means a length is specified
00FF025A  6100 00EC                424      bsr.w   parseNumber         * Find the length
00FF025E  4A01                     425      tst.b   d1
00FF0260  6600 00CA                426      bne.w   .invalidAddr
00FF0264                           427   .exend:                        * We're done parsing, give the parameters to dumpRAM and exit
00FF0264  204B                     428      move.l  a3, a0
00FF0266  6100 0140                429      bsr.w   dumpRAM
00FF026A  60A6                     430      bra.s   .exit
00FF026C                           431   .exinter:                      * Interactive mode, Space dumps a page worth of lines, enter shows quick amount
00FF026C  204B                     432      move.l  a3, a0              * Current Address
00FF026E  7010                     433      move.l  #DUMP_BYTES_QUICK, d0 * Quick amount
00FF0270  6100 0136                434      bsr.w   dumpRAM             * Dump this line
00FF0274  D7FC 00000010            435      add.l   #DUMP_BYTES_QUICK, a3 * Move up the current address by Quick amount bytes
00FF027A                           436   .exinterend:
00FF027A  6100 0360                437      bsr.w   inChar
00FF027E  B03C 000D                438      cmp.b   #CR, d0             * Display another line
00FF0282  67E8                     439      beq.s   .exinter
00FF0284  B03C 0020                440      cmp.b   #' ', d0            * Display a page 
00FF0288  6702                     441      beq.s   .exinterpage
00FF028A  6086                     442      bra.s   .exit               * Otherwise exit
00FF028C                           443   .exinterpage:
00FF028C  204B                     444      move.l  a3, a0
00FF028E                           445  
00FF028E  203C 0000008A            446      move.l  #DUMP_BYTES_PAGE, d0  * 138 bytes can fit in the 32x24 screen, 256 is 16 lines on 80x25
00FF0294  6100 0112                447      bsr.w   dumpRAM               * Dump 
00FF0298  D7FC 0000008A            448      add.l   #DUMP_BYTES_PAGE, a3  * Move up the current address by 256
00FF029E  60DA                     449      bra.s   .exinterend
00FF02A0                           450  
00FF02A0                           451  ****************************************
00FF02A0                           452  * Deposit values into RAM
00FF02A0                           453  * d ADDR VAL VAL            Deposit value(s) into RAM
00FF02A0                           454  * d ADDR VAL VAL;           Deposit values, continue with values on next line
00FF02A0                           455  *  VAL VAL VAL;              - Continuing with further continue
00FF02A0                           456  * d: VAL VAL                Continue depositing values after the last address written to
00FF02A0                           457   .deposit:
00FF02A0  1010                     458      move.b  (a0), d0
00FF02A2  B03C 003A                459      cmp.b   #':', d0            * Check if we want to continue from last
00FF02A6  672A                     460      beq.s   .depCont
00FF02A8                           461      
00FF02A8  6100 009E                462      bsr.w   parseNumber         * Otherwise read the address
00FF02AC  4A01                     463      tst.b   d1
00FF02AE  667C                     464      bne.s   .invalidAddr
00FF02B0  2640                     465      move.l  d0, a3              * Save the start address
00FF02B2                           466   .depLoop:
00FF02B2  1010                     467      move.b  (a0), d0            
00FF02B4  B03C 003B                468      cmp.b   #';', d0            * Check for continue
00FF02B8  6722                     469      beq.s   .depMultiline
00FF02BA  4A40                     470      tst     d0                  * Check for the end of line
00FF02BC  6700 0044                471      beq     .depEnd
00FF02C0                           472      
00FF02C0  6100 0086                473      bsr.w   parseNumber         * Otherwise read a value
00FF02C4  4A01                     474      tst.b   d1
00FF02C6  6672                     475      bne.s   .invalidVal
00FF02C8  B07C 00FF                476      cmp.w   #255, d0            * Make sure it's a byte
00FF02CC  6E6C                     477      bgt.s   .invalidVal
00FF02CE                           478      
00FF02CE  16C0                     479      move.b  d0, (a3)+           * Store the value into memory
00FF02D0  60E0                     480      bra.s   .depLoop
00FF02D2                           481      
00FF02D2                           482   .depCont:
00FF02D2  2679 000FFFFC            483      move.l  varCurAddr, a3      * Read in the last address 
00FF02D8  5288                     484      addq.l  #1, a0              * Skip over the ':'
00FF02DA  60D6                     485      bra.s   .depLoop
00FF02DC                           486      
00FF02DC                           487   .depMultiline:
00FF02DC  700D                     488      move.l  #COLOR_PROMPT, d0   
00FF02DE  6100 0200                489      bsr.w   setColor
00FF02E2  41F9 00FF075A            490      lea     msgDepositPrompt, a0
00FF02E8  6100 0278                491      bsr.w   printString
00FF02EC                           492      
00FF02EC  700F                     493      move.l  #COLOR_INPUT, d0   
00FF02EE  6100 01F0                494      bsr.w   setColor
00FF02F2  6100 0162                495      bsr.w   readLine            * Read in the next line to be parsed
00FF02F6                           496      
00FF02F6  6100 FEB2                497      bsr.w   lineToUpper         * Convert to uppercase
00FF02FA  41F9 000FFFA8            498      lea     varLineBuf, a0      * Reset our buffer pointer
00FF0300  60B0                     499      bra.s   .depLoop            * And jump back to decoding
00FF0302                           500   .depEnd:
00FF0302  23CB 000FFFFC            501      move.l  a3, varCurAddr
00FF0308  6000 FF08                502      bra.w   .exit
00FF030C                           503  ****************************************
00FF030C                           504  * 
00FF030C                           505   .run:
00FF030C  6100 003A                506      bsr.w   parseNumber         * Otherwise read the address
00FF0310  4A01                     507      tst.b   d1
00FF0312  6618                     508      bne.s   .invalidAddr
00FF0314  2040                     509      move.l  d0, a0
00FF0316  4E90                     510      jsr     (a0)                * Jump to the code! 
00FF0318                           511                                  * Go as subroutine to allow code to return to us
00FF0318  4EF9 00FF0160            512      jmp     monitorStart        * Warm start after returning so everything is in
00FF031E                           513                                  * a known state.
00FF031E                           514      
00FF031E                           515   .help:
00FF031E  41F9 00FF0714            516      lea     msgHelp, a0
00FF0324  6100 023C                517      bsr.w   printString
00FF0328  6000 FEE8                518      bra.w   .exit
00FF032C                           519   .invalidAddr:
00FF032C  41F9 00FF0772            520      lea     msgInvalidAddress, a0
00FF0332  6100 022E                521      bsr.w   printString
00FF0336  6000 FEDA                522      bra.w   .exit
00FF033A                           523   .invalidVal:
00FF033A  41F9 00FF0784            524      lea     msgInvalidValue, a0
00FF0340  6100 0220                525      bsr.w   printString
00FF0344  6000 FECC                526      bra.w   .exit
00FF0348                           527      
00FF0348                           528      
00FF0348                           529  **************************************
00FF0348                           530  * Find and parse a hex number
00FF0348                           531  *  Starting address in A0
00FF0348                           532  *  Number returned in D0
00FF0348                           533  *  Status in D1   (0 success, 1 fail)
00FF0348                           534  *  TODO: Try and merge first digit code with remaining digit code
00FF0348                           535  parseNumber:
00FF0348  B180                     536      eor.l   d0, d0           * Zero out d0
00FF034A  1018                     537      move.b  (a0)+, d0
00FF034C  B03C 0020                538      cmp.b   #' ', d0         * Ignore all leading spaces
00FF0350  67F6                     539      beq.s   parseNumber
00FF0352  B03C 0030                540      cmp.b   #'0', d0         * Look for hex digits 0-9
00FF0356  6D12                     541      blt.s   .invalid
00FF0358  B03C 0039                542      cmp.b   #'9', d0
00FF035C  6F16                     543      ble.s   .firstdigit1
00FF035E                           544  
00FF035E  B03C 0041                545      cmp.b   #'A', d0         * Look for hex digits A-F
00FF0362  6D06                     546      blt.s   .invalid    
00FF0364  B03C 0046                547      cmp.b   #'F', d0
00FF0368  6F04                     548      ble.s   .firstdigit2
00FF036A                           549   .invalid:
00FF036A  7201                     550      move.l  #1, d1          * Invalid character, mark failure and return
00FF036C  4E75                     551      rts
00FF036E                           552   .firstdigit2:
00FF036E  0400 0037                553      sub.b   #'7', d0        * Turn 'A' to 10
00FF0372  6004                     554      bra.s   .loop
00FF0374                           555   .firstdigit1:
00FF0374  0400 0030                556      sub.b   #'0', d0        * Turn '0' to 0
00FF0378                           557   .loop:
00FF0378  1218                     558      move.b  (a0)+, d1       * Read in a digit
00FF037A  B23C 0030                559      cmp.b   #'0', d1        * Look for hex digits 0-9
00FF037E  6D12                     560      blt.s   .end            * Any other characters mean we're done reading
00FF0380  B23C 0039                561      cmp.b   #'9', d1
00FF0384  6F18                     562      ble.s   .digit1
00FF0386  B23C 0041                563      cmp.b   #'A', d1        * Look for hex digits A-F
00FF038A  6D06                     564      blt.s   .end
00FF038C  B23C 0046                565      cmp.b   #'F', d1
00FF0390  6F06                     566      ble.s   .digit2
00FF0392                           567  
00FF0392                           568  .end:                       * We hit a non-hex digit character, we're done parsing
00FF0392  5388                     569      subq.l  #1, a0          * Move the pointer back before the end character we read
00FF0394  7200                     570      move.l  #0, d1
00FF0396  4E75                     571      rts
00FF0398                           572   .digit2:
00FF0398  0401 0037                573      sub.b   #'7', d1        * Turn 'A' to 10
00FF039C  6004                     574      bra.s   .digit3
00FF039E                           575   .digit1:
00FF039E  0401 0030                576      sub.b   #'0', d1        * Turn '0' to 0
00FF03A2                           577   .digit3:
00FF03A2  E988                     578      lsl.l   #4, d0          * Shift over to the next nybble
00FF03A4  D001                     579      add.b   d1, d0          * Place in our current nybble (could be or.b instead)
00FF03A6  60D0                     580      bra.s   .loop
00FF03A8                           581      
00FF03A8                           582      
00FF03A8                           583  ****************************************
00FF03A8                           584  * Dumps a section of RAM to the screen
00FF03A8                           585  * Displays both hex values and ASCII characters
00FF03A8                           586  * d0 - Number of bytes to dump
00FF03A8                           587  * a0 - Start Address
00FF03A8                           588  dumpRAM:
00FF03A8  48E7 3820                589      movem.l d2-d4/a2, -(SP)  * Save registers
00FF03AC  2448                     590      move.l  a0, a2           * Save the start address
00FF03AE  2400                     591      move.l  d0, d2           * And the number of bytes
00FF03B0                           592   .line:
00FF03B0  700D                     593      move.l  #COLOR_ADDR, d0   
00FF03B2  6100 012C                594      bsr.w   setColor 
00FF03B6  200A                     595      move.l  a2, d0          
00FF03B8  6100 01BC                596      bsr.w   printHexAddr     * Starting address of this line
00FF03BC  700E                     597      move.l  #COLOR_BYTES, d0   
00FF03BE  6100 0120                598      bsr.w   setColor
00FF03C2                           599      
00FF03C2  103C 0020                600      move.b  #' ', d0
00FF03C6  6100 0202                601      bsr.w   outChar          * Space out bytes
00FF03CA                           602  *    lea     msgColonSpace, a0
00FF03CA                           603  *    bsr.w   printString
00FF03CA  7606                     604      move.l  #DUMP_BYTES_LINE, d3 * Bytes that can be printed on a line
00FF03CC  2803                     605      move.l  d3, d4           * Save number of bytes on this line
00FF03CE                           606   .hexbyte:
00FF03CE  4A82                     607      tst.l   d2               * Check if we're out of bytes
00FF03D0  6718                     608      beq.s   .endbytesShort
00FF03D2  4A03                     609      tst.b   d3               * Check if we're done this line
00FF03D4  673A                     610      beq.s   .endbytes    
00FF03D6  101A                     611      move.b  (a2)+, d0        * Read a byte in from RAM
00FF03D8  6100 01C4                612      bsr.w   printHexByte     * Display it
00FF03DC  103C 0020                613      move.b  #' ', d0
00FF03E0  6100 01E8                614      bsr.w   outChar          * Space out bytes
00FF03E4  5383                     615      subq.l  #1, d3    
00FF03E6  5382                     616      subq.l  #1, d2        
00FF03E8  60E4                     617      bra.s   .hexbyte
00FF03EA                           618   .endbytesShort:
00FF03EA  9803                     619      sub.b   d3, d4           * Make d4 the actual number of bytes on this line
00FF03EC  103C 0020                620      move.b  #' ', d0
00FF03F0                           621   .endbytesShortLoop:
00FF03F0  4A03                     622      tst.b   d3               * Check if we ended the line
00FF03F2  671C                     623      beq.s   .endbytes
00FF03F4  103C 0020                624      move.b  #' ', d0
00FF03F8  6100 01D0                625      bsr.w   outChar          * Three spaces to pad out
00FF03FC  103C 0020                626      move.b  #' ', d0
00FF0400  6100 01C8                627      bsr.w   outChar
00FF0404  103C 0020                628      move.b  #' ', d0
00FF0408  6100 01C0                629      bsr.w   outChar
00FF040C                           630      
00FF040C  5303                     631      subq.b  #1, d3
00FF040E  60E0                     632      bra.s   .endbytesShortLoop
00FF0410                           633   .endbytes:
00FF0410  95C4                     634      suba.l  d4, a2           * Return to the start address of this line
00FF0412  700F                     635      move.l  #COLOR_ASCII, d0   
00FF0414  6100 00CA                636      bsr.w   setColor
00FF0418                           637   .endbytesLoop:
00FF0418  4A04                     638      tst.b   d4               * Check if we're done printing ascii
00FF041A  6700 0022                639      beq     .endline    
00FF041E  5304                     640      subq.b  #1, d4
00FF0420  101A                     641      move.b  (a2)+, d0        * Read the byte again
00FF0422  B03C 0020                642      cmp.b   #' ', d0         * Lowest printable character
00FF0426  6D0C                     643      blt.s   .unprintable
00FF0428  B03C 007E                644      cmp.b   #'~', d0         * Highest printable character
00FF042C  6E06                     645      bgt.s   .unprintable
00FF042E  6100 019A                646      bsr.w   outChar
00FF0432  60E4                     647      bra.s   .endbytesLoop
00FF0434                           648   .unprintable:
00FF0434  103C 002E                649      move.b  #'.', d0
00FF0438  6100 0190                650      bsr.w   outChar
00FF043C  60DA                     651      bra.s   .endbytesLoop
00FF043E                           652   .endline:
00FF043E  41F9 00FF07BA            653      lea     msgNewline, a0
00FF0444  6100 011C                654      bsr.w   printString
00FF0448  4A82                     655      tst.l   d2
00FF044A  6F04                     656      ble.s   .end
00FF044C  6000 FF62                657      bra.w   .line
00FF0450                           658   .end:
00FF0450  4CDF 041C                659      movem.l (SP)+, d2-d4/a2  * Restore registers
00FF0454  4E75                     660      rts
00FF0456                           661      
00FF0456                           662      
00FF0456                           663          
00FF0456                           664      
00FF0456                           665  ******
00FF0456                           666  * Read in a line into the line buffer
00FF0456                           667  readLine:
00FF0456  48E7 2020                668      movem.l d2/a2, -(SP)     * Save changed registers
00FF045A  45F9 000FFFA8            669      lea     varLineBuf, a2   * Start of the lineBuffer
00FF0460  B542                     670      eor.w   d2, d2           * Clear the character counter
00FF0462                           671   .loop:
00FF0462  6100 0178                672      bsr.w   inChar           * Read a character from the serial port
00FF0466  B03C 0008                673      cmp.b   #BKSP, d0        * Is it a backspace?
00FF046A  6722                     674      beq.s   .backspace
00FF046C  B03C 0018                675      cmp.b   #CTRLX, d0       * Is it Ctrl-H (Line Clear)?
00FF0470  673A                     676      beq.s   .lineclear
00FF0472  B03C 000D                677      cmp.b   #CR, d0          * Is it a carriage return?
00FF0476  6758                     678      beq.s   .endline
00FF0478  B03C 000A                679      cmp.b   #LF, d0          * Is it anything else but a LF?
00FF047C  67E4                     680      beq.s   .loop            * Ignore LFs and get the next character
00FF047E                           681   .char:                      * Normal character to be inserted into the buffer
00FF047E  B47C 0050                682      cmp.w   #MAX_LINE_LENGTH, d2
00FF0482  6CDE                     683      bge.s   .loop            * If the buffer is full ignore the character
00FF0484  14C0                     684      move.b  d0, (a2)+        * Otherwise store the character
00FF0486  5242                     685      addq.w  #1, d2           * Increment character count
00FF0488  6100 0140                686      bsr.w   outChar          * Echo the character
00FF048C  60D4                     687      bra.s   .loop            * And get the next one
00FF048E                           688   .backspace:
00FF048E  4A42                     689      tst.w   d2               * Are we at the beginning of the line?
00FF0490  67D0                     690      beq.s   .loop            * Then ignore it
00FF0492  6100 0136                691      bsr.w   outChar          * Backspace
00FF0496  103C 0020                692      move.b  #' ', d0
00FF049A  6100 012E                693      bsr.w   outChar          * Space
00FF049E  103C 0008                694      move.b  #BKSP, d0
00FF04A2  6100 0126                695      bsr.w   outChar          * Backspace
00FF04A6  538A                     696      subq.l  #1, a2           * Move back in the buffer
00FF04A8  5382                     697      subq.l  #1, d2           * And current character count
00FF04AA  60B6                     698      bra.s   .loop            * And goto the next character
00FF04AC                           699   .lineclear:
00FF04AC  4A42                     700      tst     d2               * Anything to clear?
00FF04AE  67B2                     701      beq.s   .loop            * If not, fetch the next character
00FF04B0  95C2                     702      suba.l  d2, a2           * Return to the start of the buffer
00FF04B2                           703   .lineclearloop:
00FF04B2  103C 0008                704      move.b  #BKSP, d0
00FF04B6  6100 0112                705      bsr.w   outChar          * Backspace
00FF04BA  103C 0020                706      move.b  #' ', d0
00FF04BE  6100 010A                707      bsr.w   outChar          * Space
00FF04C2  103C 0008                708      move.b  #BKSP, d0
00FF04C6  6100 0102                709      bsr.w   outChar          * Backspace
00FF04CA  5342                     710      subq.w  #1, d2          
00FF04CC  66E4                     711      bne.s   .lineclearloop   * Go till the start of the line
00FF04CE  6092                     712      bra.s   .loop   
00FF04D0                           713   .endline:
00FF04D0  6100 00F8                714      bsr.w   outChar          * Echo the CR
00FF04D4                           715     * move.b  #LF, d0
00FF04D4                           716     * bsr.w   outChar          * Line feed to be safe
00FF04D4  14BC 0000                717      move.b  #0, (a2)         * Terminate the line (Buffer is longer than max to allow this at full length)
00FF04D8  204A                     718      movea.l a2, a0           * Ready the pointer to return (if needed)
00FF04DA  4CDF 0404                719      movem.l (SP)+, d2/a2     * Restore registers
00FF04DE  4E75                     720      rts                      * And return
00FF04E0                           721  
00FF04E0                           722  
00FF04E0                           723  
00FF04E0                           724  ******
00FF04E0                           725  * Set Color
00FF04E0                           726  * 
00FF04E0                           727  setColor:
00FF04E0  48E7 2000                728      movem.l d2, -(SP)
00FF04E4  2400                     729      move.l  d0, d2          * Save our color argument
00FF04E6  6166                     730      bsr.s   printCSI         * Escape code start
00FF04E8  B4BC 0000000F            731      cmp.l   #15, d2         * Only colours 0-15 supported
00FF04EE  6E32                     732      bgt.s   .ignore
00FF04F0                           733      
00FF04F0  103C 0030                734      move.b  #'0', d0
00FF04F4  B4BC 00000008            735      cmp.l   #8, d2
00FF04FA  6D06                     736      blt.s   .normal
00FF04FC  5182                     737      sub.l   #8, d2          * If color >= 8 then it should be bolded
00FF04FE  103C 0031                738      move.b  #'1', d0
00FF0502                           739   .normal:
00FF0502  6100 00C6                740      bsr.w   outChar
00FF0506  103C 003B                741      move.b  #';', d0
00FF050A  6100 00BE                742      bsr.w   outChar
00FF050E  103C 0033                743      move.b  #'3', d0        * Foreground text is 30-37
00FF0512  6100 00B6                744      bsr.w   outChar
00FF0516  0682 00000030            745      add.l   #'0', d2        * Adjust our color 
00FF051C  1002                     746      move.b  d2, d0
00FF051E  6100 00AA                747      bsr.w   outChar
00FF0522                           748   .ignore:
00FF0522  103C 006D                749      move.b  #'m', d0        * End of escape sequence, graphical changes
00FF0526  6100 00A2                750      bsr.w   outChar
00FF052A                           751      
00FF052A  4CDF 0004                752      movem.l (SP)+, d2
00FF052E  4E75                     753      rts
00FF0530                           754      
00FF0530                           755  ******
00FF0530                           756  * Clear screen
00FF0530                           757  clearScreen:
00FF0530  611C                     758     bsr.s    printCSI    * Clear the entire screen
00FF0532  103C 0032                759     move.b   #'2', d0
00FF0536  6100 0092                760     bsr.w    outChar
00FF053A  103C 004A                761     move.b   #'J', d0
00FF053E  6100 008A                762     bsr.w    outChar
00FF0542                           763     
00FF0542  610A                     764     bsr.s    printCSI    * Home the cursor
00FF0544  103C 0048                765     move.b   #'H', d0
00FF0548  6100 0080                766     bsr.w    outChar
00FF054C  4E75                     767     rts
00FF054E                           768     
00FF054E                           769  ******
00FF054E                           770  * Prints the CSI (Control Sequence Indicatior) ESC[ to signal escape sequence
00FF054E                           771  printCSI:
00FF054E  103C 001B                772      move.b #27, d0
00FF0552  6176                     773      bsr.s  outChar
00FF0554  103C 005B                774      move.b #'[', d0
00FF0558  6170                     775      bsr.s  outChar
00FF055A  4E75                     776      rts
00FF055C                           777  ******
00FF055C                           778  * Prints a newline (LF,CR, LF)
00FF055C                           779  printNewline:
00FF055C  41F9 00FF07BA            780      lea     msgNewline, a0
00FF0562                           781  ******
00FF0562                           782  * Print a null terminated string
00FF0562                           783  *
00FF0562                           784  printString:
00FF0562                           785   .loop:
00FF0562  1018                     786      move.b  (a0)+, d0    * Read in character
00FF0564  6704                     787      beq.s   .end         * Check for the null
00FF0566                           788      
00FF0566  6162                     789      bsr.s   outChar      * Otherwise write the character
00FF0568  60F8                     790      bra.s   .loop        * And continue
00FF056A                           791   .end:
00FF056A  4E75                     792      rts
00FF056C                           793  
00FF056C                           794  ** KEEP All printHex functions together **
00FF056C                           795  ******
00FF056C                           796  * Print a hex word
00FF056C                           797  printHexWord:
00FF056C  2F02                     798      move.l  d2, -(SP)    * Save D2
00FF056E  2400                     799      move.l  d0, d2       * Save the address in d2
00FF0570                           800      
00FF0570  E19A                     801      rol.l   #8, d2       * 4321 -> 3214
00FF0572  E19A                     802      rol.l   #8, d2       * 3214 -> 2143 
00FF0574  6018                     803      bra.s   printHex_wordentry  * Print out the last 16 bits
00FF0576                           804  *****
00FF0576                           805  * Print a hex 24-bit address
00FF0576                           806  printHexAddr:
00FF0576  2F02                     807      move.l d2, -(SP)     * Save D2
00FF0578  2400                     808      move.l d0, d2          * Save the address in d2
00FF057A                           809      
00FF057A  E19A                     810      rol.l   #8, d2       * 4321 -> 3214
00FF057C  600A                     811      bra.s   printHex_addrentry  * Print out the last 24 bits
00FF057E                           812  ******
00FF057E                           813  * Print a hex long
00FF057E                           814  printHexLong:
00FF057E  2F02                     815      move.l  d2, -(SP)     * Save D2
00FF0580  2400                     816      move.l  d0, d2        * Save the address in d2
00FF0582                           817      
00FF0582  E19A                     818      rol.l   #8, d2        * 4321 -> 3214 high byte in low
00FF0584  2002                     819      move.l  d2, d0
00FF0586  6116                     820      bsr.s   printHexByte  * Print the high byte (24-31)
00FF0588                           821  printHex_addrentry:     
00FF0588  E19A                     822      rol.l   #8, d2        * 3214 -> 2143 middle-high byte in low
00FF058A  2002                     823      move.l  d2, d0              
00FF058C  6110                     824      bsr.s   printHexByte  * Print the high-middle byte (16-23)
00FF058E                           825  printHex_wordentry:    
00FF058E  E19A                     826      rol.l   #8, d2        * 2143 -> 1432 Middle byte in low
00FF0590  2002                     827      move.l  d2, d0
00FF0592  610A                     828      bsr.s   printHexByte  * Print the middle byte (8-15)
00FF0594  E19A                     829      rol.l   #8, d2
00FF0596  2002                     830      move.l  d2, d0
00FF0598  6104                     831      bsr.s   printHexByte  * Print the low byte (0-7)
00FF059A                           832      
00FF059A  241F                     833      move.l (SP)+, d2      * Restore D2
00FF059C  4E75                     834      RTS
00FF059E                           835      
00FF059E                           836  ******
00FF059E                           837  * Print a hex byte
00FF059E                           838  *  - Takes byte in D0
00FF059E                           839  printHexByte:
00FF059E  2F02                     840      move.l  D2, -(SP)
00FF05A0  1400                     841      move.b  D0, D2
00FF05A2  E808                     842      lsr.b   #$4, D0
00FF05A4  0600 0030                843      add.b   #'0', D0
00FF05A8  B03C 0039                844      cmp.b   #'9', D0     * Check if the hex number was from 0-9
00FF05AC  6F02                     845      ble.s   .second
00FF05AE  5E00                     846      add.b   #7, D0       * Shift 0xA-0xF from ':' to 'A'
00FF05B0                           847  .second:
00FF05B0  6118                     848      bsr.s   outChar      * Print the digit
00FF05B2  0202 000F                849      andi.b  #$0F, D2     * Now we want the lower digit Mask only the lower digit
00FF05B6  0602 0030                850      add.b   #'0', D2
00FF05BA  B43C 0039                851      cmp.b   #'9', D2     * Same as before    
00FF05BE  6F02                     852      ble.s   .end
00FF05C0  5E02                     853      add.b   #7, D2
00FF05C2                           854  .end:
00FF05C2  1002                     855      move.b  D2, D0
00FF05C4  6104                     856      bsr.s   outChar      * Print the lower digit
00FF05C6  241F                     857      move.l  (SP)+, D2
00FF05C8  4E75                     858      rts
00FF05CA                           859      
00FF05CA                           860      
00FF05CA                           861      
00FF05CA                           862      
00FF05CA                           863      
00FF05CA                           864  *****
00FF05CA                           865  * Writes a character to Port A, blocking if not ready (Full buffer)
00FF05CA                           866  *  - Takes a character in D0
00FF05CA                           867  outChar:
00FF05CA  0839 0002 00200003       868      btst    #2, SRA      * Check if transmitter ready bit is set
00FF05D2  67F6                     869      beq     outChar     
00FF05D4  13C0 00200007            870      move.b  d0, TBA      * Transmit Character
00FF05DA  4E75                     871      rts
00FF05DC                           872  
00FF05DC                           873  *****
00FF05DC                           874  * Reads in a character from Port A, blocking if none available
00FF05DC                           875  *  - Returns character in D0
00FF05DC                           876  *
00FF05DC                           877  inChar:
00FF05DC  41F9 000FFF27            878      lea     varSRingStart, a0
00FF05E2  43F9 000FFF26            879      lea     varSRingEnd,   a1
00FF05E8                           880   .nodata:
00FF05E8  B180                     881      eor.l   d0, d0
00FF05EA  1211                     882      move.b  (a1), d1
00FF05EC  1010                     883      move.b  (a0), d0
00FF05EE  B200                     884      cmp.b   d0, d1     * Check if the ring buffer has data in it
00FF05F0  67F6                     885      beq.s   .nodata
00FF05F2                           886      
00FF05F2                           887      * POSSIBLE RACE CONDITION - if ring buffer is full when we read this byte
00FF05F2                           888      *  the buffer may be double incremented (start and end) and lose bytes, I think?
00FF05F2  5210                     889      add.b   #1, (a0)     * Increment the start of the buffer
00FF05F4  0C10 0080                890      cmp.b   #SERIAL_RING_LENGTH, (a0)
00FF05F8  6D04                     891      blt.s   .nowrap      * Check if we hit the end and need to wrap
00FF05FA  0410 0080                892      sub.b   #SERIAL_RING_LENGTH, (a0)
00FF05FE                           893   .nowrap:
00FF05FE  43F9 000FFF28            894      lea     varSerialRing, a1
00FF0604  5200                     895      add.b   #1, d0
00FF0606  D3C0                     896      add.l   d0, a1       * Address the ring buffer start
00FF0608  1011                     897      move.b (a1), d0      * We got this byte
00FF060A                           898  
00FF060A  4E75                     899      rts
00FF060C                           900      
00FF060C                           901  *****
00FF060C                           902  * Reads in a character from Port A, blocking if none available
00FF060C                           903  *  - Returns character in D0
00FF060C                           904  *    
00FF060C                           905  inCharPoll:
00FF060C  0839 0000 00200003       906      btst    #0,  SRA     * Check if receiver ready bit is set
00FF0614  67C6                     907      beq     inChar
00FF0616  1039 00200007            908      move.b  RBA, d0      * Read Character into D0
00FF061C  4E75                     909      rts
00FF061E                           910      
00FF061E                           911  *****
00FF061E                           912  * Initializes the 68681 DUART port A as 19200 8N1 
00FF061E                           913  initDuart:
00FF061E  13FC 0030 00200005       914      move.b  #$30, CRA       * Reset Transmitter
00FF0626  13FC 0020 00200005       915      move.b  #$20, CRA       * Reset Reciever
00FF062E  13FC 0010 00200005       916      move.b  #$10, CRA       * Reset Mode Register Pointer
00FF0636                           917      
00FF0636  13FC 0000 00200009       918      move.b  #$00, ACR       * Baud Rate Set #2, Timer (Crystal/16)
00FF063E  13FC 00CC 00200003       919      move.b  #$CC, CSRA      * Set Tx and Rx rates to 19.2k
00FF0646  13FC 0013 00200001       920      move.b  #$13, MRA       * 8-bit, No Parity ($13 for 8-bit, $12 for 7-bit), RxRDY irq type
00FF064E  13FC 0007 00200001       921      move.b  #$07, MRA       * Normal Mode, Not CTS/RTS, 1 stop bit
00FF0656                           922        
00FF0656  13FC 0002 0020000B       923      move.b  #$02, IMR       * Enable Interrupts: RxRDYA interrupt (bit 1)
00FF065E  13FC 0005 00200005       924      move.b  #$05, CRA       * Enable Transmit/Recieve
00FF0666  4E75                     925      rts    
00FF0668                           926  
00FF0668                           927  
00FF0668                           928  
00FF0668                           929  
00FF0668                           930  
00FF0668                           931  ********** Interrupts and Exception Handlers ************
00FF0668                           932  
00FF0668                           933  
00FF0668                           934  
00FF0668                           935  
00FF0668                           936  
00FF0668                           937  ********************************************
00FF0668                           938  * Unhandled vector
00FF0668                           939  UNHANDLED:
00FF0668  4E73                     940      rte
00FF066A                           941   
00FF066A                           942  ********************************************
00FF066A                           943  * RESETVECT
00FF066A                           944  RESETVECT:
00FF066A  4E70                     945      reset
00FF066C  4E73                     946      rte
00FF066E                           947  
00FF066E                           948  ********************************************
00FF066E                           949  * AUTOVECT1 - Currently 68681 DUART, only interrupting device
00FF066E                           950  AUTOVECT1:
00FF066E  48E7 C0C0                951      movem.l d0-d1/a0-a1, -(SP)        * Save registers touched by handler
00FF0672                           952      
00FF0672                           953      * Check which interrupt the DUART is asserting
00FF0672  0839 0001 0020000B       954      btst.b   #1, ISR            * RxRDYA
00FF067A  6702                     955      beq.s   .test2              * If no data is waiting
00FF067C                           956      
00FF067C  6112                     957      bsr.s   serialReadIntCharacter
00FF067E                           958   .test2:
00FF067E  0839 0003 0020000B       959      btst.b   #3, ISR            * Counter/Timer Ready
00FF0686  6700 0002                960      beq     .done               * If the timer hasn't fired yet
00FF068A                           961          
00FF068A                           962   .done:
00FF068A  4CDF 0303                963      movem.l (SP)+, d0-d1/a0-a1     * Restore registers
00FF068E  4E73                     964      rte                         * Return from exception
00FF0690                           965      
00FF0690                           966  ********************************************
00FF0690                           967  * Read the character from the DUART (assume it's there from interrupt)
00FF0690                           968  serialReadIntCharacter:
00FF0690                           969      * We've got data available
00FF0690  41F9 000FFF27            970      lea     varSRingStart, a0   * Ring buffer ends   
00FF0696  43F9 000FFF26            971      lea     varSRingEnd,   a1
00FF069C                           972      
00FF069C  B180                     973      eor.l   d0, d0              * Clear the full d0 register
00FF069E  5211                     974      add.b   #1, (a1)            * Increment the end of the buffer
00FF06A0  0C11 0080                975      cmp.b   #SERIAL_RING_LENGTH, (a1)
00FF06A4  6D04                     976      blt.s   .noendwrap          * Check if we hit the end and need to wrap
00FF06A6  0411 0080                977      sub.b   #SERIAL_RING_LENGTH, (a1)
00FF06AA                           978   .noendwrap:
00FF06AA  1011                     979      move.b  (a1), d0
00FF06AC  1210                     980      move.b  (a0), d1
00FF06AE  B200                     981      cmp.b   d0, d1            * Check if the ring buffer is full
00FF06B0  660C                     982      bne.s   .notfull            
00FF06B2                           983      * When buffer is full we'll overwrite the oldest data
00FF06B2  5210                     984      add.b   #1, (a0)            * Make room by removing the oldest element
00FF06B4  0C10 0080                985      cmp.b   #SERIAL_RING_LENGTH, (a0)
00FF06B8  6D04                     986      blt.s   .notfull
00FF06BA  0410 0080                987      sub.b   #SERIAL_RING_LENGTH, (a0)
00FF06BE                           988   .notfull:
00FF06BE  41F9 000FFF28            989      lea     varSerialRing, a0   * Ring buffer
00FF06C4  D1C0                     990      add.l   d0, a0              * Offset of the last byte in ring buffer
00FF06C6                           991                                  * d0 still contains the end offset
00FF06C6                           992      * Read one byte from the DUART into the ring buffer
00FF06C6  1039 00200007            993      move.b  RBA, d0             * Read Character into D0
00FF06CC  1080                     994      move.b  d0, (a0)
00FF06CE  4E75                     995      rts
00FF06D0                           996  
00FF06D0                           997  ************************* ROM ROUTINES ********************************
00FF06D0                           998  
00FF06D0                           999      
00FF06D0                          1000      
00FF06D0                          1001  
00FF06D0                          1002  
00FF06D0                          1003  **********************************
00FF06D0                          1004  * Strings
00FF06D0                          1005  *
00FF06D0                          1006  msgBanner:
00FF06D0= 0A 0D 43 68 61 72 ...   1007      dc.b LF,CR,'Chartreuse''s 68000 ROM Monitor',LF,CR
00FF06F2= 3D 3D 3D 3D 3D 3D ...   1008      dc.b    '===============================',LF,CR,0
00FF0714                          1009  msgHelp:
00FF0714= 41 76 61 69 6C 61 ...   1010      dc.b 'Available Commands: ',LF,CR
00FF072A= 20 28 45 29 78 61 ...   1011      dc.b ' (E)xamine    (D)eposit',LF,CR
00FF0743= 20 28 52 29 75 6E ...   1012      dc.b ' (R)un        (H)elp',LF,CR,0
00FF075A                          1013  msgDepositPrompt:
00FF075A= 3A 20 00                1014      dc.b ': ',0
00FF075D                          1015  msgPrompt:
00FF075D= 3E 20 00                1016      dc.b '> ',0
00FF0760                          1017  msgInvalidCommand:
00FF0760= 49 6E 76 61 6C 69 ...   1018      dc.b 'Invalid Command',LF,CR,0
00FF0772                          1019  msgInvalidAddress:
00FF0772= 49 6E 76 61 6C 69 ...   1020      dc.b 'Invalid Address',LF,CR,0
00FF0784                          1021  msgInvalidValue:
00FF0784= 49 6E 76 61 6C 69 ...   1022      dc.b 'Invalid Value',LF,CR,0
00FF0794                          1023  msgRamCheck:
00FF0794= 43 68 65 63 6B 69 ...   1024      dc.b 'Checking RAM...',0
00FF07A4                          1025  msgRamFail:
00FF07A4= 46 61 69 6C 65 64 ...   1026      dc.b 'Failed at: ',0
00FF07B0                          1027  msgRamPass:
00FF07B0= 50 61 73 73 65 64 ...   1028      dc.b 'Passed.',LF,CR,0
00FF07BA                          1029  msgNewline:
00FF07BA= 0A 0D 00                1030      dc.b LF,CR,0
00FF07BD                          1031  msgColonSpace:
00FF07BD= 3A 20 00                1032      dc.b ': ',0
00FF07C0                          1033  
00FF07C0                          1034  
00FF07C0                          1035      END    START            * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ACR                 200009
AUTOVECT1           FF066E
AUTOVECT1:DONE      FF068A
AUTOVECT1:TEST2     FF067E
BEL                 7
BKSP                8
CLEARSCREEN         FF0530
CLR                 20000F
COLOR_ADDR          D
COLOR_ASCII         F
COLOR_BANNER        A
COLOR_BLACK         0
COLOR_BLUE          C
COLOR_BYTES         E
COLOR_CYAN          E
COLOR_DBLUE         4
COLOR_DCYAN         6
COLOR_DEFAULT       F
COLOR_DGREEN        2
COLOR_DGREY         8
COLOR_DMAGENTA      5
COLOR_DRED          1
COLOR_DYELLOW       3
COLOR_ERROR         1
COLOR_GREEN         A
COLOR_HELP          C
COLOR_INPUT         F
COLOR_LGREY         7
COLOR_MAGENTA       D
COLOR_ORANGE        3
COLOR_PROMPT        D
COLOR_PURPLE        5
COLOR_RED           9
COLOR_WHITE         F
COLOR_YELLOW        B
CR                  D
CRA                 200005
CRB                 200015
CSRA                200003
CSRB                200013
CTLR                20000F
CTRLC               3
CTRLX               18
CTUR                20000D
CUR                 20000D
DUART               200000
DUMPRAM             FF03A8
DUMPRAM:END         FF0450
DUMPRAM:ENDBYTES    FF0410
DUMPRAM:ENDBYTESLOOP  FF0418
DUMPRAM:ENDBYTESSHORT  FF03EA
DUMPRAM:ENDBYTESSHORTLOOP  FF03F0
DUMPRAM:ENDLINE     FF043E
DUMPRAM:HEXBYTE     FF03CE
DUMPRAM:LINE        FF03B0
DUMPRAM:UNPRINTABLE  FF0434
DUMP_BYTES_LINE     6
DUMP_BYTES_PAGE     8A
DUMP_BYTES_QUICK    10
ESC                 1B
IMR                 20000B
INCHAR              FF05DC
INCHAR:NODATA       FF05E8
INCHAR:NOWRAP       FF05FE
INCHARPOLL          FF060C
INITDUART           FF061E
IPUL                20001B
ISR                 20000B
IVR                 200019
LF                  A
LINETOUPPER         FF01AA
LINETOUPPER:LOOP    FF01B0
LINETOUPPER:NEXT    FF01C2
MAX_LINE_LENGTH     50
MONITORLINE         FF0180
MONITORSTART        FF0160
MRA                 200001
MRB                 200011
MSGBANNER           FF06D0
MSGCOLONSPACE       FF07BD
MSGDEPOSITPROMPT    FF075A
MSGHELP             FF0714
MSGINVALIDADDRESS   FF0772
MSGINVALIDCOMMAND   FF0760
MSGINVALIDVALUE     FF0784
MSGNEWLINE          FF07BA
MSGPROMPT           FF075D
MSGRAMCHECK         FF0794
MSGRAMFAIL          FF07A4
MSGRAMPASS          FF07B0
OPCR                20001B
OPR_CLR             20001D
OPR_SET             20001D
OUTCHAR             FF05CA
PARSELINE           FF01C8
PARSELINE:DEPCONT   FF02D2
PARSELINE:DEPEND    FF0302
PARSELINE:DEPLOOP   FF02B2
PARSELINE:DEPMULTILINE  FF02DC
PARSELINE:DEPOSIT   FF02A0
PARSELINE:EXAMINE   FF0218
PARSELINE:EXEND     FF0264
PARSELINE:EXINTER   FF026C
PARSELINE:EXINTEREND  FF027A
PARSELINE:EXINTERPAGE  FF028C
PARSELINE:EXIT      FF0212
PARSELINE:EXLENGTH  FF025A
PARSELINE:EXLOOP    FF0224
PARSELINE:EXQUICK   FF0256
PARSELINE:EXRANGE   FF0248
PARSELINE:FINDCOMMAND  FF01D2
PARSELINE:HELP      FF031E
PARSELINE:INVALID   FF0202
PARSELINE:INVALIDADDR  FF032C
PARSELINE:INVALIDVAL  FF033A
PARSELINE:RUN       FF030C
PARSENUMBER         FF0348
PARSENUMBER:DIGIT1  FF039E
PARSENUMBER:DIGIT2  FF0398
PARSENUMBER:DIGIT3  FF03A2
PARSENUMBER:END     FF0392
PARSENUMBER:FIRSTDIGIT1  FF0374
PARSENUMBER:FIRSTDIGIT2  FF036E
PARSENUMBER:INVALID  FF036A
PARSENUMBER:LOOP    FF0378
PRINTCSI            FF054E
PRINTHEXADDR        FF0576
PRINTHEXBYTE        FF059E
PRINTHEXBYTE:END    FF05C2
PRINTHEXBYTE:SECOND  FF05B0
PRINTHEXLONG        FF057E
PRINTHEXWORD        FF056C
PRINTHEX_ADDRENTRY  FF0588
PRINTHEX_WORDENTRY  FF058E
PRINTNEWLINE        FF055C
PRINTSTRING         FF0562
PRINTSTRING:END     FF056A
PRINTSTRING:LOOP    FF0562
RAMCHECK            FF0152
RAM_END             100000
RAM_START           0
RBA                 200007
RBB                 200017
READLINE            FF0456
READLINE:BACKSPACE  FF048E
READLINE:CHAR       FF047E
READLINE:ENDLINE    FF04D0
READLINE:LINECLEAR  FF04AC
READLINE:LINECLEARLOOP  FF04B2
READLINE:LOOP       FF0462
RESETVECT           FF066A
SERIALREADINTCHARACTER  FF0690
SERIALREADINTCHARACTER:NOENDWRAP  FF06AA
SERIALREADINTCHARACTER:NOTFULL  FF06BE
SERIAL_RING_LENGTH  80
SETCOLOR            FF04E0
SETCOLOR:IGNORE     FF0522
SETCOLOR:NORMAL     FF0502
SRA                 200003
SRB                 200013
STACK_START         FF6FC
START               FF0140
STOP_CNTR           20001F
STRT_CNTR           20001D
TAB                 9
TBA                 200007
TBB                 200017
TERM_HEIGHT         18
TERM_WIDTH          50
UNHANDLED           FF0668
VARCURADDR          FFFFC
VARHNDLR50HZ        FFF20
VARHNDLR60HZ        FFF1C
VARHNDLRSIGINT      FFF18
VARLAST             FF6FC
VARLINEBUF          FFFA8
VARMYMBITPOS        FFF0D
VARMYMBUF           FF6FC
VARMYMCURBYTE       FFF0E
VARMYMCURREGS       FFEFC
VARMYMENDPOS        FFF10
VARMYMFILLBUF       FFF0C
VARMYMFRAMEPOS      FFF0F
VARMYMINDEX         FFF14
VARSERIALRING       FFF28
VARSRINGEND         FFF26
VARSRINGSTART       FFF27
VARSYSCNTR5         FFF25
VARSYSCNTR6         FFF24
